Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_battery
File: Create_0.gml
event_inherited();
item_name = "Battery";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_beta_hat
File: Create_0.gml
event_inherited();
item_name = "Beta Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_big_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bot
File: Create_0.gml
/// @description Initialize Bot

// Bot properties
type = BotType.SCOUT;
state = BotState.IDLE;
pattern = noone;

// Movement variables
movement_speed = 0;
target_x = x;
target_y = y;
path_index = 0;
wait_timer = 0;

// Interaction variables
detection_radius = 0;
alert_level = 0;
last_known_player_x = 0;
last_known_player_y = 0;

// Visual feedback
flash_alpha = 0;
alert_indicator = false;

/// @function initialize_bot(bot_type)
function initialize_bot(bot_type) {
    type = bot_type;
    // Get pattern from bot manager
    pattern = obj_bot_manager.bot_patterns[$ string_lower(BotType[type])];
    movement_speed = pattern.movement_speed;
    detection_radius = pattern.detection_radius;
}

/// @function update_movement()
function update_movement() {
    if (state == BotState.PATROLLING || state == BotState.INVESTIGATING) {
        var dir = point_direction(x, y, target_x, target_y);
        var dist = point_distance(x, y, target_x, target_y);
        
        if (dist > movement_speed) {
            x += lengthdir_x(movement_speed, dir);
            y += lengthdir_y(movement_speed, dir);
        } else {
            // Reached target
            if (state == BotState.PATROLLING) {
                // Get next patrol point
                var path = obj_bot_manager.bot_paths[? id];
                if (path != undefined) {
                    path_index = (path_index + 1) % array_length(path);
                    target_x = path[path_index].x;
                    target_y = path[path_index].y;
                }
            } else if (state == BotState.INVESTIGATING) {
                // Start searching at investigation point
                wait_timer = pattern.patrol_time;
                state = BotState.IDLE;
            }
        }
    }
}

/// @function handle_state()
function handle_state() {
    switch(state) {
        case BotState.IDLE:
            if (wait_timer > 0) {
                wait_timer--;
            } else {
                // Request new behavior from manager
                with (obj_bot_manager) {
                    update_bot_behavior(other.id);
                }
            }
            break;
            
        case BotState.COLLECTING:
            // Attempt to collect nearby items
            var item = instance_nearest(x, y, obj_collectible);
            if (item != noone && point_distance(x, y, item.x, item.y) < 20) {
                with (item) {
                    instance_destroy();
                }
                wait_timer = pattern.collect_time;
                state = BotState.IDLE;
            }
            break;
            
        case BotState.RETURNING:
            // Return to original position or designated return point
            target_x = xstart;
            target_y = ystart;
            if (point_distance(x, y, xstart, ystart) < movement_speed) {
                state = BotState.IDLE;
            }
            break;
    }
    
    // Update movement
    update_movement();
    
    // Check for player interaction
    with (obj_bot_manager) {
        check_bot_player_interaction(other.id);
    }
}

/// @function draw_bot()
function draw_bot() {
    // Draw bot sprite
    draw_self();
    
    // Draw alert indicator if active
    if (alert_indicator) {
        draw_sprite_ext(spr_alert_indicator, 0, x, y - sprite_height, 1, 1, 0, c_white, 1);
    }
    
    // Draw detection radius in debug mode
    if (global.debug_mode) {
        draw_set_alpha(0.2);
        draw_circle(x, y, detection_radius, true);
        draw_set_alpha(1);
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bot
File: Draw_0.gml
/// @description Draw Bot

// Call draw function
draw_bot(); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bot
File: Step_0.gml
/// @description Update Bot Behavior

// Handle state and movement
handle_state();

// Update visual feedback
if (alert_indicator) {
    flash_alpha = (flash_alpha + 0.1) % 1;
}

// Update alert level decay
if (alert_level > 0) {
    alert_level = max(0, alert_level - 0.01);
    if (alert_level == 0) {
        alert_indicator = false;
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bot_manager
File: Create_0.gml
/// @description Initialize Bot System

// Make persistent
persistent = true;

// Initialize bot system
active_bots = ds_list_create();
bot_paths = ds_map_create();
bot_behaviors = ds_map_create();

// Bot states
enum BotState {
    IDLE,
    PATROLLING,
    INVESTIGATING,
    COLLECTING,
    RETURNING
}

// Bot types
enum BotType {
    SCOUT,
    COLLECTOR,
    GUARD,
    MAINTENANCE
}

// Bot behavior patterns
bot_patterns = {
    scout: {
        movement_speed: 2,
        detection_radius: 150,
        patrol_time: 10 * room_speed,
        behavior_weights: {
            patrol: 0.6,
            investigate: 0.3,
            idle: 0.1
        }
    },
    collector: {
        movement_speed: 1.5,
        detection_radius: 100,
        collect_time: 5 * room_speed,
        behavior_weights: {
            collect: 0.7,
            return: 0.2,
            idle: 0.1
        }
    },
    guard: {
        movement_speed: 1,
        detection_radius: 200,
        guard_time: 15 * room_speed,
        behavior_weights: {
            guard: 0.8,
            investigate: 0.15,
            idle: 0.05
        }
    }
}

/// @function spawn_bot(type, x, y)
function spawn_bot(type, x, y) {
    var bot = instance_create_layer(x, y, "Instances", obj_bot);
    bot.type = type;
    bot.state = BotState.IDLE;
    bot.pattern = bot_patterns[$ string_lower(BotType[type])];
    ds_list_add(active_bots, bot);
    return bot;
}

/// @function assign_bot_path(bot_id, path_points)
function assign_bot_path(bot_id, path_points) {
    bot_paths[? bot_id] = path_points;
}

/// @function update_bot_behavior(bot_id)
function update_bot_behavior(bot_id) {
    var bot = instance_find(obj_bot, bot_id);
    if (bot != noone) {
        var pattern = bot.pattern;
        var weights = pattern.behavior_weights;
        
        // Random behavior selection based on weights
        var roll = random(1);
        var cumulative = 0;
        
        var behavior_names = variable_struct_get_names(weights);
        for (var i = 0; i < array_length(behavior_names); i++) {
            var behavior = behavior_names[i];
            cumulative += weights[$ behavior];
            if (roll <= cumulative) {
                switch(behavior) {
                    case "patrol":
                        bot.state = BotState.PATROLLING;
                        break;
                    case "investigate":
                        bot.state = BotState.INVESTIGATING;
                        break;
                    case "collect":
                        bot.state = BotState.COLLECTING;
                        break;
                    case "return":
                        bot.state = BotState.RETURNING;
                        break;
                    default:
                        bot.state = BotState.IDLE;
                        break;
                }
                break;
            }
        }
    }
}

/// @function check_bot_player_interaction(bot_id)
function check_bot_player_interaction(bot_id) {
    var bot = instance_find(obj_bot, bot_id);
    if (bot != noone) {
        var player = instance_nearest(bot.x, bot.y, obj_player);
        if (player != noone) {
            var dist = point_distance(bot.x, bot.y, player.x, player.y);
            if (dist <= bot.pattern.detection_radius) {
                // Handle player detection based on bot type
                switch(bot.type) {
                    case BotType.SCOUT:
                        // Record player location and investigate
                        bot.state = BotState.INVESTIGATING;
                        bot.target_x = player.x;
                        bot.target_y = player.y;
                        break;
                    case BotType.GUARD:
                        // Alert nearby bots and pursue player
                        alert_nearby_bots(bot.x, bot.y, 300);
                        bot.state = BotState.INVESTIGATING;
                        break;
                    case BotType.COLLECTOR:
                        // Flee from player
                        bot.state = BotState.RETURNING;
                        break;
                }
                return true;
            }
        }
    }
    return false;
}

/// @function alert_nearby_bots(x, y, radius)
function alert_nearby_bots(x, y, radius) {
    for (var i = 0; i < ds_list_size(active_bots); i++) {
        var bot = active_bots[| i];
        if (point_distance(x, y, bot.x, bot.y) <= radius) {
            bot.state = BotState.INVESTIGATING;
            bot.target_x = x;
            bot.target_y = y;
        }
    }
}

/// @function cleanup_bots()
function cleanup_bots() {
    ds_list_destroy(active_bots);
    ds_map_destroy(bot_paths);
    ds_map_destroy(bot_behaviors);
}

// Register cleanup handler
array_push(global.game_state.cleanup_handlers, cleanup_bots); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_boxpuffleo_item
File: Create_0.gml
event_inherited();
item_name = "Box Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_box_decoration
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_broken_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Broken Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bulletin_board
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Alarm_0.gml
/// obj_camera: Alarm[0] Event (Handles delayed camera setup after room transition)
if (instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance);  // Attach camera to player
    camera_set_view_pos(global.camera, 
        global.player_instance.x - (camera_get_view_width(global.camera) / 2),
        global.player_instance.y - (camera_get_view_height(global.camera) / 2));
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);  // Reset zoom
    show_debug_message("DEBUG: Camera attached to player at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
} else {
    show_debug_message("ERROR: Player instance still not found. Retrying...");
    alarm[0] = 2;  // Retry after 2 frames if player instance is not found yet
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Create_0.gml
// Create Event for obj_camera
    global.camera = camera_create();
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New global camera created. ID: " + string(global.camera));
	
	global.camera_reset = false;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Other_4.gml
/// obj_camera - Room Start Event
if (global.camera_reset) {
    alarm[0] = 2; // Delay camera setup by 2 frames
    global.camera_reset = false;
} else {
    alarm[0] = 2; // Always delay on room start to ensure player exists
}

show_debug_message("DEBUG: Room Start - Camera setup delayed by 2 frames.");

// Ensure the camera is valid
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New global camera created. ID: " + string(global.camera));
} else {
    view_set_camera(0, global.camera);
    show_debug_message("DEBUG: Reattached to existing global camera. ID: " + string(global.camera));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Step_0.gml
/// @description Update camera position and handle edge cases

// Camera smoothing factor (0 to 1)
var smooth_factor = 0.1;

// Handle camera target
if (instance_exists(global.player_instance)) {
    // Calculate target position with deadzone
    var deadzone = 20;  // Pixels of movement before camera follows
    var current_x = camera_get_view_x(global.camera);
    var current_y = camera_get_view_y(global.camera);
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);
    
    // Apply deadzone
    var dx = target_x - current_x;
    var dy = target_y - current_y;
    
    if (abs(dx) > deadzone) {
        target_x = current_x + (dx - sign(dx) * deadzone);
    } else {
        target_x = current_x;
    }
    
    if (abs(dy) > deadzone) {
        target_y = current_y + (dy - sign(dy) * deadzone);
    } else {
        target_y = current_y;
    }
    
    // Clamp to room boundaries with smooth transition
    target_x = clamp(target_x, 0, room_width - camera_get_view_width(global.camera));
    target_y = clamp(target_y, 0, room_height - camera_get_view_height(global.camera));
    
    // Apply smoothing with delta time
    var dt_smooth = smooth_factor * (delta_time / 16667);  // Normalize to ~60fps
    dt_smooth = clamp(dt_smooth, 0, 1);
    
    var new_x = lerp(current_x, target_x, dt_smooth);
    var new_y = lerp(current_y, target_y, dt_smooth);
    
    // Handle room transition edge case
    if (global.camera_reset) {
        new_x = target_x;
        new_y = target_y;
        global.camera_reset = false;
    }
    
    // Update camera position with boundary check
    camera_set_view_pos(global.camera, 
        clamp(new_x, 0, room_width - camera_get_view_width(global.camera)),
        clamp(new_y, 0, room_height - camera_get_view_height(global.camera))
    );
    
    // Update debug info if enabled
    if (global.debug_mode) {
        show_debug_message("Camera Position: " + string(new_x) + ", " + string(new_y));
    }
} else if (alarm[0] == -1) {
    // Retry finding player if alarm isn't set
    alarm[0] = 2;
    show_debug_message("WARNING: Player instance not found, retrying in 2 frames...");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Create_0.gml
// In obj_chat_window Create Event
dialog_data = [];        // Will be assigned by the NPC
dialog_index = 0;        // Current dialogue line
choice_selected = -1;    // Index of selected choice (-1 means none)
depth = -1001;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_64.gml
// obj_chat_window: Draw GUI Event
if (global.chat_active && array_length(dialog_data) > 0 && global.chat_npc != noone) {
    // Get GUI dimensions (matches viewport: 288x216)
    var gui_width = display_get_gui_width();  // 288
    var gui_height = display_get_gui_height(); // 216

    // Get original window sprite size
    var orig_width = sprite_get_width(spr_npc_dialouge_full_window);
    var orig_height = sprite_get_height(spr_npc_dialouge_full_window);

    // Calculate scale to fill viewport width (288 pixels)
    var window_scale = gui_width / orig_width; // e.g., 288 / 100 = 2.88

    // Check height constraint (ensure it fits within 216 pixels)
    var scaled_height = orig_height * window_scale;
    if (scaled_height > gui_height) {
        window_scale = gui_height / orig_height;
    }

    // Recalculate scaled dimensions
    var scaled_width = orig_width * window_scale;
    scaled_height = orig_height * window_scale;

    // Calculate window position: centered horizontally, touching the bottom
    var window_x = (gui_width - scaled_width) / 2;
    var window_y = gui_height - scaled_height;

    // Draw the dialogue window (scaled to fill width)
    draw_sprite_ext(spr_npc_dialouge_full_window, 0, window_x, window_y, window_scale, window_scale, 0, c_white, 1);

    // Draw NPC portrait (shifted 2 units left and up, scaled)
    var portrait_x = window_x + 2 * window_scale;
    var portrait_y = window_y + 2 * window_scale;
    draw_sprite_ext(spr_npc_dialouge_full_colour_portrait, 0, portrait_x, portrait_y, window_scale, window_scale, 0, global.chat_npc.npc_color, 1);
    draw_sprite_ext(spr_npc_dialouge_full_outline_portrait, 0, portrait_x, portrait_y, window_scale, window_scale, 0, c_white, 1);

    // Set font
    draw_set_font(fnt_bonkfatty);

    // Draw dialogue text (scaled positions) with validation
    var text_x = window_x + 77 * window_scale;
    var text_y = window_y + 20 * window_scale;
    var max_text_width = (256 - 77) * window_scale;
    var separation = 20 * window_scale;

    if (dialog_data != undefined && dialog_index < array_length(dialog_data)) {
        var dialog_entry = dialog_data[dialog_index];

        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "text") && is_string(dialog_entry.text)) {
            // Draw the dialogue text
            draw_set_color(c_black);
            draw_text_ext(text_x, text_y, dialog_entry.text, separation, max_text_width);
        } else {
            // Log an error if the data is invalid
            show_debug_message("ERROR: Invalid dialog_data entry or missing 'text' property at index " + string(dialog_index));
        }

        // Draw dialogue choices if available
        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "choices") && array_length(dialog_entry.choices) > 0) {
            // Define button height before using it
            var button_height = sprite_get_height(spr_button) * window_scale;
            var choices_y = window_y - button_height - 10 * window_scale;

            // Button and chat sprite sizes
            var button_width = sprite_get_width(spr_button) * window_scale;
            var chat_width = sprite_get_width(spr_chat) * window_scale;
            var chat_height = sprite_get_height(spr_chat) * window_scale;
            var spacing = 10 * window_scale;

            var num_choices = array_length(dialog_entry.choices);
            var total_choices_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var choices_start_x = window_x + (scaled_width - total_choices_width) / 2;

            for (var i = 0; i < num_choices; i++) {
                var button_x = choices_start_x + i * (button_width + spacing);
                // Draw spr_button as background
                draw_sprite_ext(spr_button, 0, button_x, choices_y, window_scale, window_scale, 0, c_white, 1);
                // Center spr_chat within spr_button
                var chat_x = button_x + (button_width - chat_width) / 2;
                var chat_y = choices_y + (button_height - chat_height) / 2;
                draw_sprite_ext(spr_chat, 0, chat_x, chat_y, window_scale, window_scale, 0, c_white, 1);
                // Draw choice text centered in spr_chat
                draw_set_color(i == choice_selected ? c_red : c_black);
                draw_set_halign(fa_center);
                draw_set_valign(fa_middle);
                draw_text(chat_x + chat_width / 2, chat_y + chat_height / 2, dialog_entry.choices[i]);
                draw_set_halign(fa_left);
                draw_set_valign(fa_top);
            }
        }
    } else {
        // Log an error if the index or data is invalid
        show_debug_message("ERROR: dialog_data is undefined or dialog_index out of bounds. Index: " + string(dialog_index));
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Mouse_4.gml
// obj_chat_window: Mouse Left Pressed Event
if (global.chat_active) {
    // Convert mouse coordinates to GUI coordinates
    var gui_mouse_x = device_mouse_x_to_gui(0);
    var gui_mouse_y = device_mouse_y_to_gui(0);

    // GUI dimensions
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var menu_width = 300;
    var menu_height = 150;
    var menu_x = (gui_width - menu_width) / 2;
    var menu_y = gui_height - menu_height - 50;

    // Close button logic
    var close_button_size = 20;
    var close_x = menu_x + menu_width - close_button_size - 20;
    var close_y = menu_y + 20;

    if (gui_mouse_x >= close_x && gui_mouse_x <= close_x + close_button_size &&
        gui_mouse_y >= close_y && gui_mouse_y <= close_y + close_button_size) {
        global.chat_active = false;
        global.chat_npc = noone;
        dialog_queue = [];
        show_debug_message("Close button clicked. Chat deactivated.");
        exit;
    }

    // Dialogue choice logic (example)
    if (dialog_index < array_length(dialog_data)) {
        var dialog_entry = dialog_data[dialog_index];
        if (is_struct(dialog_entry) && variable_struct_exists(dialog_entry, "choices") && array_length(dialog_entry.choices) > 0) {
            var button_width = 100;  // Adjust based on your button sprite/size
            var button_height = 30;  // Adjust based on your button sprite/size
            var spacing = 10;
            var choices_y = menu_y + menu_height - button_height - 10;  // Position below dialogue text
            var num_choices = array_length(dialog_entry.choices);
            var total_choices_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var choices_start_x = menu_x + (menu_width - total_choices_width) / 2;

            for (var i = 0; i < num_choices; i++) {
                var button_x = choices_start_x + i * (button_width + spacing);
                if (gui_mouse_x >= button_x && gui_mouse_x <= button_x + button_width &&
                    gui_mouse_y >= choices_y && gui_mouse_y <= choices_y + button_height) {
                    choice_selected = i;
                    dialog_index++;  // Advance to next dialogue
                    show_debug_message("Choice " + string(i) + " selected: " + dialog_entry.choices[i]);
                    // Add your action logic here (e.g., start quest, update variables)
                    break;
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Step_0.gml
/// @description Handle chat window logic
if (!global.chat_active || global.chat_npc == noone) exit;

// Handle choice selection
if (array_length(dialog_data) > 0 && dialog_index < array_length(dialog_data)) {
    var current_dialog = dialog_data[dialog_index];
    
    if (is_struct(current_dialog) && variable_struct_exists(current_dialog, "choices")) {
        var choices = current_dialog.choices;
        var next_states = current_dialog.next_states;
        
        // Handle mouse input for choices
        if (mouse_check_button_pressed(mb_left)) {
            var gui_width = display_get_gui_width();
            var gui_height = display_get_gui_height();
            var button_height = sprite_get_height(spr_button);
            var choices_y = gui_height - button_height - 10;
            
            var num_choices = array_length(choices);
            var button_width = sprite_get_width(spr_button);
            var spacing = 10;
            var total_width = (num_choices * button_width) + ((num_choices - 1) * spacing);
            var start_x = (gui_width - total_width) / 2;
            
            for (var i = 0; i < num_choices; i++) {
                var button_x = start_x + i * (button_width + spacing);
                if (point_in_rectangle(device_mouse_x_to_gui(0), device_mouse_y_to_gui(0),
                    button_x, choices_y, button_x + button_width, choices_y + button_height)) {
                    // Handle choice selection
                    var next_state = next_states[i];
                    
                    if (next_state == "end") {
                        // End dialogue
                        global.chat_active = false;
                        instance_destroy();
                    } else {
                        // Check for actions
                        if (variable_struct_exists(current_dialog, "actions")) {
                            var actions = current_dialog.actions;
                            if (i < array_length(actions)) {
                                with (global.chat_npc) {
                                    switch(actions[i]) {
                                        case "activate_quest":
                                            activate_quest();
                                            break;
                                        case "complete_quest":
                                            complete_quest();
                                            break;
                                    }
                                }
                            }
                        }
                        
                        // Move to next dialogue state
                        if (next_state != "") {
                            var next_dialog = global.chat_npc.dialog_tree[? next_state];
                            if (next_dialog != undefined) {
                                dialog_data = [next_dialog];
                                dialog_index = 0;
                            }
                        }
                    }
                    break;
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Create_0.gml
// Initialize state
image_index = 0; // Default: not selected
is_selected = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Mouse_4.gml

// Deselect all other color icons
with (obj_color_icon) {
    image_index = 0; // Not selected
    is_selected = false;
}

// Select this icon
image_index = 1; // Selected
is_selected = true;

// Set global player color
global.player_color = icon_color;
global.last_player_color = global.player_color; // Save the choice persistently


// Ensure this icon is assigned a valid color
if (icon_color == undefined) {
    show_debug_message("ERROR: Icon color is undefined in obj_color_icon.");
    icon_color = c_white; // Default to white
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_picker_controller
File: Create_0.gml
// Define custom colors
var c_notblack = make_color_rgb(51, 51, 51);
var c_bluer = make_color_rgb(46, 71, 170);
var c_brown = make_color_rgb(153, 102, 0);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(255, 102, 0);
var c_pink = make_color_rgb(255, 51, 153);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(204, 0, 0);
var c_salmon = make_color_rgb(255, 67, 63);
var c_yellower = make_color_rgb(255, 204, 0);

// Colors array
var colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Sprites for color icons
var sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid dimensions
var cols = 5;
var rows = 3;
var spacing = 70; // Distance between grid items
var start_x = room_width / 2.2 - ((cols - 1) * spacing) / 2;
var start_y = room_height / 2.2 - ((rows - 1) * spacing) / 2;

// Create the grid
for (var i = 0; i < array_length(colors); i++) { // Use array_length explicitly
    var x_pos = start_x + (i mod cols) * spacing;
    var y_pos = start_y + (i div cols) * spacing;

    // Create color icon instance
    var color_icon = instance_create_layer(x_pos, y_pos, "Instances", obj_color_icon);
    color_icon.icon_color = colors[i];       // Assign color
    color_icon.sprite_index = sprites[i];    // Assign corresponding sprite
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Create_0.gml
depth = -1000;
// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Initialize variables
selected_color = c_white;
global.player_color = c_white;

// Define selection areas
color_wheel_x = x + 31;
color_wheel_y = y + 19;
color_wheel_width = 46;
color_wheel_height = 46;

exit_x = x + 6;
exit_y = y + 6;
exit_width = 9;
exit_height = 9;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Draw_0.gml
// Draw the background first
draw_sprite(spr_colorpicker_background, 0, x, y);

// Draw the color wheel directly without using the surface
draw_sprite(spr_color_bar, 0, x + 31, y + 19);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Mouse_4.gml
var mx = (device_mouse_x_to_gui(0) / display_get_gui_width()) * camera_get_view_width(global.camera) + camera_get_view_x(global.camera);
var my = (device_mouse_y_to_gui(0) / display_get_gui_height()) * camera_get_view_height(global.camera) + camera_get_view_y(global.camera);

// Check if the player clicked inside the exit button (6,6 to 14,14)
if (point_in_rectangle(mx, my, exit_x, exit_y, exit_x + exit_width, exit_y + exit_height)) {
    show_debug_message("Closing color wheel...");
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
    return;
}

// Check if the click is inside the color wheel selection area
if (point_in_rectangle(mx, my, color_wheel_x, color_wheel_y, color_wheel_x + color_wheel_width, color_wheel_y + color_wheel_height)) {
    var sx = mx - color_wheel_x; // Convert to surface coordinates
	var sy = my - color_wheel_y;

	if (sx >= 0 && sy >= 0 && sx < sprite_get_width(spr_color_bar) && sy < sprite_get_height(spr_color_bar)) {
		selected_color = surface_getpixel(surf_color_wheel, sx, sy);
	}

   if (selected_color != c_black) { // Avoid selecting transparent areas
    global.player_color = selected_color;

    if (instance_exists(global.player_instance)) {
        global.player_instance.image_blend = global.player_color;
    }

    show_debug_message("Color selected: " + string(selected_color));
    
    // Close color wheel & pause menu
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
	}
}

show_debug_message("Color picked: " + string(draw_getpixel(mx, my)));
show_debug_message("Fixed Mouse World X: " + string(mouse_world_x) + " | Y: " + string(mouse_world_y));
show_debug_message("View X: " + string(camera_get_view_x(global.camera)) + " | View Y: " + string(camera_get_view_y(global.camera)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Step_0.gml
// Handle mouse click for selecting a color
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);

    if (point_in_rectangle(mx, my, x, y, x + sprite_width, y + sprite_height)) {
        var sx = mx - x; // Convert to surface coordinates
        var sy = my - y;

        // Ensure the surface exists before sampling
        if (surface_exists(surf_color_wheel)) {
            selected_color = surface_getpixel(surf_color_wheel, sx, sy);
        } else {
            selected_color = c_black; // Fallback
        }

        // Apply color globally if valid
        if (selected_color != c_black) {
            global.player_color = selected_color;
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            show_debug_message("Color selected: " + string(selected_color));
        }
        
        // Close the color wheel and return to previous room
        if (variable_global_exists("last_room") && global.last_room != noone) {
            room_goto(global.last_room);
        } else {
            room_goto(rm_town); // Default return room
        }
        instance_destroy();
    }
}


// Debug mouse position
show_debug_message("Mouse X: " + string(mouse_x) + " | Mouse Y: " + string(mouse_y));
show_debug_message("GUI Mouse X: " + string(device_mouse_x_to_gui(0)) + " | GUI Mouse Y: " + string(device_mouse_y_to_gui(0)));
show_debug_message("View X: " + string(camera_get_view_x(view_camera[0])) + " | View Y: " + string(camera_get_view_y(view_camera[0])));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Create_0.gml
// obj_config_menu: Create Event
depth = -10000; // Draw on top of other UI
item_scroll = 0; // Starting position for item list scrolling

// Center the panel
panel_width = sprite_get_width(spr_blue_square_panel);
panel_height = sprite_get_height(spr_blue_square_panel);
panel_x = (display_get_gui_width() - panel_width) / 2;
panel_y = (display_get_gui_height() - panel_height) / 2;

/// @description Initialize config menu
event_inherited();

// Menu state
menu_active = true;
selected_tab = "General";

// Define tabs and their options
tabs = {
    General: {
        name: "General Settings",
        options: [
            {name: "Music Volume", type: "slider", value: 1.0, min: 0, max: 1, step: 0.1},
            {name: "Sound Volume", type: "slider", value: 1.0, min: 0, max: 1, step: 0.1},
            {name: "Fullscreen", type: "toggle", value: false},
            {name: "Show FPS", type: "toggle", value: false}
        ]
    },
    Developer: {
        name: "Developer Tools",
        options: [
            {name: "Debug Mode", type: "toggle", value: false},
            {name: "Show Collisions", type: "toggle", value: false},
            {name: "Show Quest Areas", type: "toggle", value: false},
            {name: "Show NPC Paths", type: "toggle", value: false},
            {name: "Invincibility", type: "toggle", value: false},
            {name: "Fast Travel", type: "toggle", value: false},
            {name: "Complete Current Quest", type: "button", action: "complete_quest"},
            {name: "Give All Items", type: "button", action: "give_items"},
            {name: "Reset Quests", type: "button", action: "reset_quests"},
            {name: "Toggle Room Grid", type: "toggle", value: false}
        ]
    },
    Quest: {
        name: "Quest Debug",
        options: [
            {name: "Show Quest Status", type: "toggle", value: false},
            {name: "Quest Stage", type: "dropdown", value: 0, options: ["None", "Stage 1", "Stage 2", "Stage 3", "Stage 4", "Stage 5"]},
            {name: "Force Quest Complete", type: "button", action: "force_quest"},
            {name: "Reset Quest Progress", type: "button", action: "reset_quest"},
            {name: "Show Quest Markers", type: "toggle", value: true},
            {name: "Quest Debug Log", type: "toggle", value: false}
        ]
    },
    Player: {
        name: "Player Debug",
        options: [
            {name: "Speed Multiplier", type: "slider", value: 1, min: 1, max: 5, step: 0.5},
            {name: "No Clip Mode", type: "toggle", value: false},
            {name: "Show Hitbox", type: "toggle", value: false},
            {name: "Force State", type: "dropdown", value: "normal", options: ["normal", "sliding", "swimming", "driving"]},
            {name: "Reset Position", type: "button", action: "reset_position"},
            {name: "Give Coins", type: "button", action: "give_coins"}
        ]
    }
};

// Initialize option values from saved settings or defaults
function init_settings() {
    if (file_exists("debug_config.json")) {
        var file = file_text_open_read("debug_config.json");
        var json = file_text_read_string(file);
        file_text_close(file);
        
        var saved_settings = json_parse(json);
        var tab_names = variable_struct_get_names(tabs);
        
        for (var i = 0; i < array_length(tab_names); i++) {
            var tab = tabs[$ tab_names[i]];
            if (variable_struct_exists(saved_settings, tab_names[i])) {
                var saved_tab = saved_settings[$ tab_names[i]];
                for (var j = 0; j < array_length(tab.options); j++) {
                    var option = tab.options[j];
                    if (variable_struct_exists(saved_tab, option.name)) {
                        option.value = saved_tab[$ option.name];
                    }
                }
            }
        }
    }
}

// Save settings
function save_settings() {
    var settings = {};
    var tab_names = variable_struct_get_names(tabs);
    
    for (var i = 0; i < array_length(tab_names); i++) {
        var tab = tabs[$ tab_names[i]];
        settings[$ tab_names[i]] = {};
        for (var j = 0; j < array_length(tab.options); j++) {
            var option = tab.options[j];
            settings[$ tab_names[i]][$ option.name] = option.value;
        }
    }
    
    var file = file_text_open_write("debug_config.json");
    file_text_write_string(file, json_stringify(settings));
    file_text_close(file);
}

// Handle button actions
function handle_action(action) {
    switch(action) {
        case "complete_quest":
            if (ds_list_size(global.active_quests) > 0) {
                var quest_id = global.active_quests[| 0];
                with(obj_npc) {
                    if (quest_id == quest_id) complete_quest();
                }
            }
            break;
            
        case "give_items":
            var items = ["EPF Phone", "EPF Badge", "Spy Phone", "Signal Tracker", 
                        "Battery", "Circuit Board", "Antenna", "Elite EPF Badge"];
            for (var i = 0; i < array_length(items); i++) {
                array_push(global.inventory, items[i]);
            }
            break;
            
        case "reset_quests":
            ds_list_clear(global.active_quests);
            ds_list_clear(global.completed_quests);
            with(obj_npc) {
                if (quest_id != -1) quest_state = "available";
            }
            break;
            
        case "force_quest":
            var quest_stage = get_option_value("Quest", "Quest Stage");
            if (quest_stage > 0) {
                // Complete all quests up to this stage
                for (var i = 1; i < quest_stage; i++) {
                    var quest_id = get_quest_by_stage(i);
                    if (quest_id != "") {
                        ds_list_add(global.completed_quests, quest_id);
                    }
                }
                // Set current quest as active
                var current_quest = get_quest_by_stage(quest_stage);
                if (current_quest != "") {
                    ds_list_add(global.active_quests, current_quest);
                }
            }
            break;
            
        case "reset_position":
            with(global.player_instance) {
                x = xstart;
                y = ystart;
            }
            break;
            
        case "give_coins":
            global.coins += 1000;
            break;
    }
}

// Helper function to get quest by stage
function get_quest_by_stage(stage) {
    var quest_names = ds_map_keys_to_array(global.quest_data);
    for (var i = 0; i < array_length(quest_names); i++) {
        var quest = global.quest_data[? quest_names[i]];
        if (quest.stage == stage) return quest_names[i];
    }
    return "";
}

// Helper function to get option value
function get_option_value(tab_name, option_name) {
    var tab = tabs[$ tab_name];
    for (var i = 0; i < array_length(tab.options); i++) {
        if (tab.options[i].name == option_name) {
            return tab.options[i].value;
        }
    }
    return undefined;
}

// Initialize settings
init_settings();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Draw_64.gml
/// @description Draw config menu
if (!menu_active) exit;

// Draw panel background
draw_set_color(c_black);
draw_set_alpha(0.8);
draw_rectangle(panel_x, panel_y, panel_x + panel_width, panel_y + panel_height, false);
draw_set_alpha(1);

// Draw tabs
var tab_names = variable_struct_get_names(tabs);
var tab_width = panel_width / array_length(tab_names);
var tab_height = 30;

for (var i = 0; i < array_length(tab_names); i++) {
    var tab_x = panel_x + (i * tab_width);
    var tab_color = (tab_names[i] == selected_tab) ? c_white : c_gray;
    
    draw_set_color(c_dkgray);
    draw_rectangle(tab_x, panel_y, tab_x + tab_width, panel_y + tab_height, false);
    
    draw_set_color(tab_color);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(tab_x + (tab_width / 2), panel_y + (tab_height / 2), tab_names[i]);
}

// Draw current tab options
var current_tab = tabs[$ selected_tab];
var option_start_y = panel_y + tab_height + 10;
var option_height = 30;

draw_set_halign(fa_left);
draw_set_color(c_white);

for (var i = 0; i < array_length(current_tab.options); i++) {
    var option = current_tab.options[i];
    var option_y = option_start_y + (i * option_height);
    
    // Draw option name
    draw_text(panel_x + 10, option_y + 10, option.name);
    
    // Draw option control based on type
    switch(option.type) {
        case "slider":
            var slider_x = panel_x + panel_width * 0.6;
            var slider_width = panel_width * 0.3;
            
            // Draw slider background
            draw_set_color(c_dkgray);
            draw_rectangle(slider_x, option_y + 12, slider_x + slider_width, option_y + 18, false);
            
            // Draw slider position
            draw_set_color(c_white);
            var normalized = (option.value - option.min) / (option.max - option.min);
            var slider_pos = slider_x + (slider_width * normalized);
            draw_rectangle(slider_pos - 2, option_y + 8, slider_pos + 2, option_y + 22, false);
            
            // Draw value
            draw_set_halign(fa_right);
            draw_text(slider_x - 10, option_y + 10, string_format(option.value, 0, 2));
            draw_set_halign(fa_left);
            break;
            
        case "toggle":
            var toggle_x = panel_x + panel_width * 0.8;
            draw_set_color(option.value ? c_lime : c_red);
            draw_rectangle(toggle_x, option_y + 5, toggle_x + 20, option_y + 25, false);
            draw_set_color(c_white);
            draw_rectangle(toggle_x, option_y + 5, toggle_x + 20, option_y + 25, true);
            break;
            
        case "button":
            var button_x = panel_x + panel_width * 0.6;
            var button_width = panel_width * 0.3;
            draw_set_color(c_dkgray);
            draw_rectangle(button_x, option_y, button_x + button_width, option_y + option_height, false);
            draw_set_color(c_white);
            draw_rectangle(button_x, option_y, button_x + button_width, option_y + option_height, true);
            draw_set_halign(fa_center);
            draw_text(button_x + (button_width / 2), option_y + 10, "Execute");
            draw_set_halign(fa_left);
            break;
            
        case "dropdown":
            var dropdown_x = panel_x + panel_width * 0.6;
            var dropdown_width = panel_width * 0.3;
            draw_set_color(c_dkgray);
            draw_rectangle(dropdown_x, option_y, dropdown_x + dropdown_width, option_y + option_height, false);
            draw_set_color(c_white);
            draw_rectangle(dropdown_x, option_y, dropdown_x + dropdown_width, option_y + option_height, true);
            draw_set_halign(fa_center);
            draw_text(dropdown_x + (dropdown_width / 2), option_y + 10, string(option.value));
            draw_set_halign(fa_left);
            break;
    }
}

// Reset draw properties
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white);
draw_set_alpha(1);

//obj_config_menu Draw GUI event
// Draw background
draw_sprite(spr_blue_square_panel, 0, panel_x, panel_y);

// Skin buttons
var title = "Skins";
var title_width = string_width(title);
draw_text(panel_x + 20 + (100 - title_width) / 2, panel_y + 20, title);
var button_y = panel_y + 40;
for (var i = 0; i < array_length(global.skins); i++) {
    draw_set_color(c_white);
    draw_rectangle(panel_x + 20, button_y, panel_x + 120, button_y + 30, false); // 100x30 rectangle
    draw_set_color(c_black);
    var text = "Switch to " + global.skins[i].name;
    var text_width = string_width(text);
    var text_height = string_height(text);
    var text_x = panel_x + 20 + (100 - text_width) / 2; // Center horizontally
    var text_y = button_y + (30 - text_height) / 2; // Center vertically
    draw_text(text_x, text_y, text);
    button_y += 40;
}

// Item buttons with sprites
draw_set_color(c_black);
draw_text(panel_x + 170, panel_y + 20, "Items");
var items = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
var item_display_count = 5;
button_y = panel_y + 40;
for (var i = item_scroll; i < item_scroll + item_display_count && i < array_length(items); i++) {
    var square_x = panel_x + 150;
    var square_y = button_y;
    draw_set_color(c_white);
    draw_rectangle(square_x, square_y, square_x + 30, square_y + 30, false); // 30x30 square
    var item_index = ds_map_find_value(global.item_index_map, items[i]);
    if (!is_undefined(item_index)) {
        draw_sprite_part(spr_inventory_items, 0, item_index * 18, 0, 18, 18, square_x + 6, square_y + 6); // Centered sprite
    }
    button_y += 40;
}

// Scroll buttons
draw_set_color(c_white);
draw_rectangle(panel_x + 190, panel_y + 40, panel_x + 210, panel_y + 60, false); // Up button
draw_rectangle(panel_x + 190, panel_y + 60, panel_x + 210, panel_y + 80, false); // Down button
draw_set_color(c_black);
draw_text(panel_x + 200, panel_y + 45, "^");
draw_text(panel_x + 200, panel_y + 65, "v");

// Color picker buttons
draw_set_color(c_black);
draw_text(panel_x + 220, panel_y + 20, "Colors");
draw_set_color(c_white);
draw_rectangle(panel_x + 220, panel_y + 40, panel_x + 320, panel_y + 70, false);  // Player Color button
draw_set_color(c_black);
draw_set_halign(fa_center);
draw_text(panel_x + 270, panel_y + 55, "Player Color");
draw_set_color(c_white);
draw_rectangle(panel_x + 220, panel_y + 80, panel_x + 320, panel_y + 110, false); // Icetruck Color button
draw_set_color(c_black);
draw_text(panel_x + 270, panel_y + 95, "Icetruck Color");
draw_set_halign(fa_left);

// Close button
draw_set_color(c_red);
draw_rectangle(panel_x + panel_width - 30, panel_y + 10, panel_x + panel_width - 10, panel_y + 30, false);
draw_set_color(c_white);
draw_set_halign(fa_center);
draw_text(panel_x + panel_width - 20, panel_y + 12, "X"); // Center of 20x20 button
draw_set_halign(fa_left); // Reset to default


//npc dialouge code!!
if (global.chat_active && array_length(dialog_data) > 0 && variable_struct_exists(current_dialog, "choices") && array_length(current_dialog.choices) > 0) {
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    
    // Determine inventory height based on HUD state
    var inventory_height;
    if (instance_exists(obj_hud_expanded) && global.is_expanded) {
        inventory_height = sprite_get_height(spr_hud_expanded) * 3; // Assuming ui_scale = 3
    } else {
        inventory_height = 50; // Default height for regular inventory
    }
    
    // Position choices above inventory
    var choices_y = gui_height - inventory_height - 20; // 20px buffer
    var num_choices = array_length(current_dialog.choices);
    var choice_width = 100; // Fixed width per choice
    var spacing = 10; // Space between choices
    var total_width = choice_width * num_choices + spacing * (num_choices - 1);
    var start_x = (gui_width - total_width) / 2; // Center horizontally

    // Draw each choice
    for (var i = 0; i < num_choices; i++) {
        var choice_x = start_x + i * (choice_width + spacing);
        draw_set_color(i == choice_selected ? c_red : c_black);
        draw_text(choice_x, choices_y, current_dialog.choices[i]);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_config_menu
File: Step_0.gml
/// @description Handle config menu logic

// Handle menu visibility
if (!menu_active) exit;

// Get mouse position in GUI coordinates
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);

// Handle tab selection
var tab_names = variable_struct_get_names(tabs);
var tab_width = panel_width / array_length(tab_names);
var tab_height = 30;

for (var i = 0; i < array_length(tab_names); i++) {
    var tab_x = panel_x + (i * tab_width);
    if (point_in_rectangle(gui_mouse_x, gui_mouse_y, 
        tab_x, panel_y, tab_x + tab_width, panel_y + tab_height)) {
        if (mouse_check_button_pressed(mb_left)) {
            selected_tab = tab_names[i];
        }
    }
}

// Handle option interactions
var current_tab = tabs[$ selected_tab];
var option_start_y = panel_y + tab_height + 10;
var option_height = 30;

for (var i = 0; i < array_length(current_tab.options); i++) {
    var option = current_tab.options[i];
    var option_y = option_start_y + (i * option_height);
    
    switch(option.type) {
        case "slider":
            var slider_x = panel_x + panel_width * 0.6;
            var slider_width = panel_width * 0.3;
            if (point_in_rectangle(gui_mouse_x, gui_mouse_y,
                slider_x, option_y, slider_x + slider_width, option_y + option_height)) {
                if (mouse_check_button(mb_left)) {
                    var normalized = (gui_mouse_x - slider_x) / slider_width;
                    option.value = clamp(
                        option.min + (normalized * (option.max - option.min)),
                        option.min,
                        option.max
                    );
                    apply_setting(selected_tab, option.name, option.value);
                }
            }
            break;
            
        case "toggle":
            var toggle_x = panel_x + panel_width * 0.8;
            if (point_in_rectangle(gui_mouse_x, gui_mouse_y,
                toggle_x, option_y, toggle_x + 20, option_y + 20)) {
                if (mouse_check_button_pressed(mb_left)) {
                    option.value = !option.value;
                    apply_setting(selected_tab, option.name, option.value);
                }
            }
            break;
            
        case "button":
            var button_x = panel_x + panel_width * 0.6;
            var button_width = panel_width * 0.3;
            if (point_in_rectangle(gui_mouse_x, gui_mouse_y,
                button_x, option_y, button_x + button_width, option_y + option_height)) {
                if (mouse_check_button_pressed(mb_left)) {
                    handle_action(option.action);
                }
            }
            break;
            
        case "dropdown":
            var dropdown_x = panel_x + panel_width * 0.6;
            var dropdown_width = panel_width * 0.3;
            if (point_in_rectangle(gui_mouse_x, gui_mouse_y,
                dropdown_x, option_y, dropdown_x + dropdown_width, option_y + option_height)) {
                if (mouse_check_button_pressed(mb_left)) {
                    // Cycle through options
                    var current_index = array_get_index(option.options, option.value);
                    current_index = (current_index + 1) % array_length(option.options);
                    option.value = option.options[current_index];
                    apply_setting(selected_tab, option.name, option.value);
                }
            }
            break;
    }
}

// Apply settings based on current values
function apply_setting(tab_name, option_name, value) {
    switch(tab_name) {
        case "General":
            switch(option_name) {
                case "Music Volume":
                    audio_group_set_gain(audiogroup_music, value, 0);
                    break;
                case "Sound Volume":
                    audio_group_set_gain(audiogroup_default, value, 0);
                    break;
                case "Fullscreen":
                    window_set_fullscreen(value);
                    break;
                case "Show FPS":
                    show_debug_overlay(value);
                    break;
            }
            break;
            
        case "Developer":
            switch(option_name) {
                case "Debug Mode":
                    global.debug_mode = value;
                    break;
                case "Show Collisions":
                    global.show_collisions = value;
                    break;
                case "Show Quest Areas":
                    global.show_quest_areas = value;
                    break;
                case "Show NPC Paths":
                    global.show_npc_paths = value;
                    break;
                case "Invincibility":
                    global.player_invincible = value;
                    break;
                case "Fast Travel":
                    global.fast_travel_enabled = value;
                    break;
                case "Toggle Room Grid":
                    global.show_room_grid = value;
                    break;
            }
            break;
            
        case "Player":
            switch(option_name) {
                case "Speed Multiplier":
                    with(global.player_instance) {
                        move_spd = base_move_spd * value;
                    }
                    break;
                case "No Clip Mode":
                    global.no_clip = value;
                    break;
                case "Show Hitbox":
                    global.show_hitbox = value;
                    break;
                case "Force State":
                    with(global.player_instance) {
                        state = value;
                    }
                    break;
            }
            break;
    }
}

// obj_config_menu Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Skin buttons
    var button_y = panel_y + 40;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (point_in_rectangle(mx, my, panel_x + 20, button_y, panel_x + 120, button_y + 30)) {
            obj_controller.switch_skin(global.skins[i].name);
            show_debug_message("Switched to skin: " + global.skins[i].name);
            global.ui_manager.close_ui();
            if (instance_exists(obj_inventory)) {
                obj_inventory.visible = true;  // Restore inventory
                show_debug_message("Inventory visibility set to true after skin switch.");
            }
            break;
        }
        button_y += 40;
    }
    
    // Item buttons
    var items = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone", "Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice", "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
    var item_display_count = 5;
    button_y = panel_y + 40;
    var should_close = false;
    for (var i = item_scroll; i < item_scroll + item_display_count && i < array_length(items); i++) {
        if (point_in_rectangle(mx, my, panel_x + 150, button_y, panel_x + 180, button_y + 30)) {
            obj_inventory.add_to_inventory(items[i]);
            show_debug_message("Spawned item: " + items[i]);
            should_close = true;  // Flag to close after spawning
            break;
        }
        button_y += 40;
    }
    
    // Scroll buttons
    if (point_in_rectangle(mx, my, panel_x + 190, panel_y + 40, panel_x + 210, panel_y + 60)) {
        item_scroll = max(0, item_scroll - 1);
    } else if (point_in_rectangle(mx, my, panel_x + 190, panel_y + 60, panel_x + 210, panel_y + 80)) {
        item_scroll = min(array_length(items) - item_display_count, item_scroll + 1);
    }
    
    // Color picker buttons
    if (point_in_rectangle(mx, my, panel_x + 220, panel_y + 40, panel_x + 320, panel_y + 70)) {
        instance_create_layer(0, 0, "Instances", obj_player_colourpicker);
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after player colour picker.");
        }
    } else if (point_in_rectangle(mx, my, panel_x + 220, panel_y + 80, panel_x + 320, panel_y + 110)) {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after icetruck colour picker.");
        }
    }
    
    // Close button
    if (point_in_rectangle(mx, my, panel_x + panel_width - 30, panel_y + 10, panel_x + panel_width - 10, panel_y + 30)) {
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after close button.");
        }
        show_debug_message("Configuration menu closed.");
    }
    
    // Close after spawning item
    if (should_close) {
        global.ui_manager.close_ui();
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
            show_debug_message("Inventory visibility set to true after spawning item.");
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_continue_button
File: Create_0.gml
depth = -1000;
visible = file_exists("savegame.sav");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_continue_button
File: Mouse_4.gml
load_game();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Alarm_0.gml
// Ensure the new player instance is created after the previous one is destroyed
if (global.skin_to_spawn != noone) {
    var player_x = global.last_player_x;
    var player_y = global.last_player_y;

    // Create the new player instance
    global.player_instance = instance_create_layer(player_x, player_y, "Instances", global.skin_to_spawn);
    global.current_skin = global.skin_name_to_spawn;

    // Reset the temporary skin variables
    global.skin_to_spawn = noone;
    global.skin_name_to_spawn = "";

    // Ensure camera follows the new player
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
        show_debug_message("Skin switched to: " + global.current_skin + ". New instance ID: " + string(global.player_instance));
    } else {
        show_debug_message("ERROR: Failed to create player instance.");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Create_0.gml
/// Create Event for obj_controller
global.is_loading_game = false;
if (!global.is_loading_game) {
    init_globals();
} 
global.chat_active = false;
global.chat_npc = noone;
global.player_controls_enabled = true;

persistent = true; // Ensure persistence across rooms

// Initialize global variables early to avoid undefined references
global.dialogue_active = false; // Dialogue system starts inactive

// Track clicks processed by any UI elements
global.click_handled = false;
global.is_expanded = false;

// Get the FPS value for the room
var room_fps = game_get_speed(gamespeed_fps);

// Initialize countdown_timer with the desired duration in seconds multiplied by room_fps
global.countdown_timer = 1 * room_fps; // 1 second countdown 
global.is_pause_menu_active = false;
global.game_started = false; // Flag to check if the game has started
global.lives = 3; // Initialize player lives
game_timer = 0; // Initialize game timer
global.skin_switching = false; // Initialize the skin switching flag

// Initialize global variables
global.skins = [
    { name: "player", object: obj_player },
    { name: "icetruck", object: obj_player_icetruck },
    { name: "tube", object: obj_player_tube },
    { name: "toboggan", object: obj_player_toboggan },
    { name: "sled_player", object: obj_sled_player },
    { name: "ninja", object: obj_player_ninja }
];

global.current_skin = "player"; // Starting skin
global.player_instance = noone; // Initialize player instance
global.icetruck_destroyed = false; // Initialize icetruck_destroyed

// Define player colors globally
global.player_colors = [
    make_color_rgb(51, 51, 51),    // notblack
    make_color_rgb(46, 71, 170),   // bluer
    make_color_rgb(153, 102, 0),   // brown
    make_color_rgb(7, 167, 163),   // cyan
    make_color_rgb(7, 106, 68),    // emerald
    make_color_rgb(6, 155, 77),    // greener
    make_color_rgb(176, 126, 194), // lavender
    make_color_rgb(8, 153, 211),   // lightblue
    make_color_rgb(189, 252, 201), // mint
    make_color_rgb(255, 102, 0),   // oranger
    make_color_rgb(255, 51, 153),  // pink
    make_color_rgb(102, 49, 158),  // purpler
    make_color_rgb(204, 0, 0),     // reder
    make_color_rgb(255, 67, 63),   // salmon
    make_color_rgb(255, 204, 0)    // yellower
];

// Room state management
if (!variable_global_exists("room_states")) {
    global.room_states = ds_map_create();
}
global.current_room = room; // Track current room

// Ensure player instance exists
if (global.player_instance == noone) {
    if (global.current_skin == "player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player);
    } else if (global.current_skin == "icetruck") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_icetruck);
    } else if (global.current_skin == "tube") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_tube);
    } else if (global.current_skin == "sled_player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_sled_player);
    } else if (global.current_skin == "ninja") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_ninja);
    } else if (global.current_skin == "toboggan") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_toboggan);
    }
}

if (instance_exists(global.player_instance)) {
    global.player_instance.image_blend = global.player_color;
    show_debug_message("Restored player color: " + string(global.player_color));
} 

if (!variable_global_exists("following_puffles")) {
    global.following_puffles = ds_list_create();
}

// Quest management
global.active_quests = ds_list_create();
global.completed_quests = ds_list_create();
global.quest_progress = ds_map_create();
global.quest_definitions = ds_map_create();

// Define a sample quest
function create_quest(_id, _name, _description, _objectives, _rewards) {
    var quest = ds_map_create();
    ds_map_add(quest, "id", _id);
    ds_map_add(quest, "name", _name);
    ds_map_add(quest, "description", _description);
    ds_map_add(quest, "objectives", _objectives);
    ds_map_add(quest, "rewards", _rewards);
    return quest;
}

// Sample quest: Find the Missing Puffle
var quest1 = create_quest(
    1,
    "Find the Missing Puffle",
    "Help the NPC find their lost puffle.",
    [
        { "type": "collect", "item": "Puffle O", "amount": 1 },
        { "type": "talk", "npc": "NPC1" }
    ],
    { "coins": 100, "item": "Beta Hat" }
);
ds_map_add(global.quest_definitions, 1, quest1);

// Debugging
if (instance_exists(global.player_instance)) {
    show_debug_message("Player instance created: " + string(global.player_instance));
} else {
    show_debug_message("Error: Failed to create player instance.");
}

// Add debug message to confirm Create event runs
show_debug_message("obj_controller created with ID: " + string(id));
show_debug_message("obj_controller Create event executed");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_3.gml
function cleanup_game() {
if (ds_exists(global.room_states, ds_type_map)) {
    ds_map_destroy(global.room_states);
}
if (ds_exists(global.following_puffles, ds_type_list)) {
    ds_list_destroy(global.following_puffles);
}
if (ds_exists(global.active_quests, ds_type_list)) {
    ds_list_destroy(global.active_quests);
}
if (ds_exists(global.completed_quests, ds_type_list)) {
    ds_list_destroy(global.completed_quests);
}
if (ds_exists(global.quest_progress, ds_type_map)) {
    ds_map_destroy(global.quest_progress);
}
if (ds_exists(global.quest_definitions, ds_type_map)) {
    ds_map_destroy(global.quest_definitions);
}
// Add destruction for other global data structures used in your project
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_4.gml
/// Room Start Event for obj_controller
show_debug_message("obj_controller Room Start event started in room: " + room_get_name(room));

// Handle player creation
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || 
                  room == rm_pause_menu || room == rm_settings_menu || room == rm_saveload);

if (!instance_exists(global.player_instance) && !is_ui_room) {
    var player_x = global.is_loading_game ? global.player_x : (variable_global_exists("last_player_x") ? global.last_player_x : 170);
    var player_y = global.is_loading_game ? global.player_y : (variable_global_exists("last_player_y") ? global.last_player_y : 154);
    var player_obj;
    switch (global.current_skin) {
        case "player": player_obj = obj_player; break;
        case "toboggan": player_obj = obj_player_toboggan; break;
        case "tube": player_obj = obj_player_tube; break;
        case "icetruck": player_obj = obj_player_icetruck; break;
        case "sled_player": player_obj = obj_sled_player; break;
        case "ninja": player_obj = obj_player_ninja; break;
        default:
            player_obj = obj_player;
            show_debug_message("WARNING: Unknown skin '" + global.current_skin + "', defaulting to obj_player.");
    }
    global.player_instance = instance_create_layer(player_x, player_y, "Instances", player_obj);
    if (instance_exists(global.player_instance)) {
        global.player_instance.persistent = true;
        global.player_instance.image_blend = global.player_color;
        global.player_instance.face = global.is_loading_game ? global.last_player_face : DOWN;
        show_debug_message("DEBUG: Player created at (" + string(player_x) + ", " + string(player_y) + ") with skin: " + global.current_skin);
    } else {
        show_debug_message("ERROR: Failed to create player instance.");
    }
    if (global.is_loading_game) {
        global.is_loading_game = false;
        show_debug_message("Loading complete, reset is_loading_game flag.");
    }
} else if (is_ui_room && instance_exists(global.player_instance)) {
    global.last_player_x = global.player_instance.x;
    global.last_player_y = global.player_instance.y;
    instance_destroy(global.player_instance);
    global.player_instance = noone;
    camera_set_view_target(global.camera, noone);
    var cam_x = room_width / 2;
    var cam_y = room_height / 2;
    camera_set_view_pos(global.camera, cam_x - (camera_get_view_width(global.camera) / 2), cam_y - (camera_get_view_height(global.camera) / 2));
}

// Load room state
load_room_state(room);
show_debug_message("DEBUG: Room Start Event triggered in obj_controller.");

// Set camera to follow player
if (instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance);
    show_debug_message("DEBUG: Camera now follows player.");
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);
    camera_set_view_pos(global.camera, target_x, target_y);
} else if (!is_ui_room) {
    show_debug_message("WARNING: No player instance in non-UI room.");
}

// Handle Puffle instance
if (instance_exists(obj_puffle)) {
    with (obj_puffle) {
        if (!variable_instance_exists(id, "following_player")) {
            following_player = false;
        }
        if (following_player) { 
            x = global.player_instance.x + 16;
            y = global.player_instance.y + 16;
        }
    }
}

// Ensure a "UI" layer exists for GUI elements
if (!layer_exists("UI")) {
    layer_create(0, "UI");
    show_debug_message("DEBUG: UI layer created.");
} else {
    show_debug_message("DEBUG: UI layer already exists.");
}

// Pause system
if (global.dialogue_active) {
    with (obj_player) { move_speed = 0; }
    with (obj_npc) { move_speed = 0; }
} else {
    with (obj_player) { move_speed = move_spd; }
    with (obj_npc) { move_speed = move_spd; }
}

// Hide Inventory in the Pause Menu
if (room == rm_pause_menu) {
    with (obj_inventory) {
        visible = false;
    }
    show_debug_message("DEBUG: Inventory hidden in pause menu.");
} else {
    with (obj_inventory) {
        visible = true;
    }
    show_debug_message("DEBUG: Inventory restored after pause menu.");
}

// Ensure the ice truck remains destroyed if it was destroyed previously
if (global.icetruck_destroyed && instance_exists(obj_icetruck)) {
    with (obj_icetruck) {
        instance_destroy();
    }
}

// Create UI manager if it doesn't exist
if (!instance_exists(obj_ui_manager)) {
    instance_create_layer(0, 0, "UI", obj_ui_manager);
    show_debug_message("DEBUG: Created obj_ui_manager in Room Start.");
}

// Final debug messages
show_debug_message("Pause menu closed.");
if (instance_exists(obj_skinpicker)) {
    show_debug_message("Skin picker opened successfully.");
} else if (instance_exists(obj_color_wheel)) {
    show_debug_message("Color wheel opened successfully.");
}
show_debug_message("DEBUG: Room Start Event completed. Current skin: " + global.current_skin);
show_debug_message("DEBUG: Player instance ID: " + string(global.player_instance));
show_debug_message("obj_controller Room Start event for ID: " + string(id));
show_debug_message("Room Start Event triggered in obj_controller.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_5.gml

if (!global.is_loading_game) {
    save_room_state(room);
show_debug_message("Saved state for room: " + room_get_name(room));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Step_0.gml
/// Step Event for obj_controller
global.click_handled = false;
// Toggle Pause Menu with ESC
if (keyboard_check_pressed(vk_escape) && !global.colour_picker_active) {
    global.is_pause_menu_active = !global.is_pause_menu_active;
    if (global.is_pause_menu_active) {
        global.player_controls_enabled = false;
        show_debug_message("Game Paused");
    } else {
        global.player_controls_enabled = true;
        if (instance_exists(obj_inventory)) {
            obj_inventory.visible = true;  // Restore inventory
        }
        show_debug_message("Game Resumed");
    }
}

// Toggle expanded inventory
if (keyboard_check_pressed(ord("I"))) {
    if (instance_exists(obj_inventory_expanded)) {
        with (obj_inventory_expanded) {
            instance_destroy();
        }
        global.game_paused = false;
    } else {
        instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
        global.game_paused = true;
    }
}

// Toggle icetruck colour picker with "C" when skin is icetruck
if (keyboard_check_pressed(ord("C")) && global.current_skin == "icetruck") {
    if (instance_exists(obj_icetruck_colourpicker)) {
        with (obj_icetruck_colourpicker) instance_destroy();
    } else {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
    }
}

// Ensure inventory visibility in non-UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);
if (!is_ui_room && instance_exists(obj_inventory)) {
    if (!global.is_pause_menu_active) {  // Only show when not paused
        obj_inventory.visible = false;
    }
}
if (!is_ui_room && instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance);
}

// Hide or show the player in UI rooms
if (is_ui_room) {
    if (instance_exists(global.player_instance)) {
        global.player_instance.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (!instance_exists(global.player_instance)) {
        show_debug_message("WARNING: No player instance found. Recreating...");
        var player_x = global.player_x;
        var player_y = global.player_y;
        var player_obj;
        switch (global.current_skin) {
            case "player":
                player_obj = obj_player;
                break;
            case "toboggan":
                player_obj = obj_player_toboggan;
                break;
            case "tube":
                player_obj = obj_player_tube;
                break;
            case "icetruck":
                player_obj = obj_player_icetruck;
                break;
            case "sled_player":
                player_obj = obj_sled_player;
                break;
            case "ninja":
                player_obj = obj_player_ninja;
                break;
            default:
                player_obj = obj_player;
        }
        global.player_instance = instance_create_layer(player_x, player_y, "Instances", player_obj);
        show_debug_message("DEBUG: Player recreated in Step event at (" + string(player_x) + ", " + string(player_y) + ") with skin: " + global.current_skin);
    } else {
        global.player_instance.visible = true;
    }
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
    } else {
        show_debug_message("ERROR: Camera could not follow player instance.");
    }
}

// Function to switch player skins
function switch_skin(new_skin) {
    if (global.skin_switching) return;
    global.skin_switching = true;

    var player_x = global.player_instance != noone ? global.player_instance.x : global.player_x;
    var player_y = global.player_instance != noone ? global.player_instance.y : global.player_y;
    var player_face = DOWN;
    var saved_icetruck_tint = c_white;

    // Preserve tint if switching from icetruck
    if (instance_exists(global.player_instance) && global.current_skin == "icetruck") {
        saved_icetruck_tint = global.player_instance.icetruck_tint;
    }

    if (instance_exists(global.player_instance)) {
        if (variable_instance_exists(global.player_instance, "face")) {
            player_face = global.player_instance.face;
        }
        instance_destroy(global.player_instance);
    }

    var new_instance = noone;
    var skin_found = false;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (global.skins[i].name == new_skin) {
            new_instance = instance_create_layer(player_x, player_y, "Instances", global.skins[i].object);
            global.current_skin = new_skin;
            skin_found = true;
            break;
        }
    }

    if (!skin_found || new_instance == noone) {
        new_instance = instance_create_layer(player_x, player_y, "Instances", obj_player);
        global.current_skin = "player";
        show_debug_message("WARNING: Defaulted to player skin. Invalid skin name: " + new_skin);
    }

    if (variable_instance_exists(new_instance, "face")) {
        new_instance.face = player_face;
    }
    if (new_skin == "icetruck" && variable_instance_exists(new_instance, "icetruck_tint")) {
        new_instance.icetruck_tint = saved_icetruck_tint;
    }

    global.player_instance = new_instance;
    camera_set_view_target(global.camera, global.player_instance);
    show_debug_message("Switched to skin: " + new_skin + ". New instance ID: " + string(new_instance));

    global.skin_switching = false;
}

if (room == rm_sled_racing) {
    switch_skin("sled_player");
}

// Function to start a quest
function start_quest(quest_id) {
    if (!ds_list_find_index(global.active_quests, quest_id)) {
        ds_list_add(global.active_quests, quest_id);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var progress = ds_map_create();
        for (var i = 0; i < array_length(quest[?"objectives"]); i++) {
            ds_map_add(progress, i, false); // Not completed
        }
        ds_map_add(global.quest_progress, quest_id, progress);
        show_debug_message("Started quest: " + quest[?"name"]);
    }
}

// Function to check quest completion
function check_quest_completion(quest_id) {
    var progress = ds_map_find_value(global.quest_progress, quest_id);
    if (progress == undefined) return false;
    var quest = ds_map_find_value(global.quest_definitions, quest_id);
    var objectives = quest[?"objectives"];
    for (var i = 0; i < array_length(objectives); i++) {
        var obj = objectives[i];
        if (obj.type == "collect") {
            var item_count = obj_inventory.get_inventory_item_count(obj.item);
            if (item_count < obj.amount) return false;
        } else if (obj.type == "talk") {
            if (!ds_map_find_value(progress, i)) return false;
        }
    }
    return true;
}

// Function to complete a quest
function complete_quest(quest_id) {
    var index = ds_list_find_index(global.active_quests, quest_id);
    if (index != -1) {
        ds_list_delete(global.active_quests, index);
        ds_list_add(global.completed_quests, quest_id);
        var quest = ds_map_find_value(global.quest_definitions, quest_id);
        var rewards = quest[?"rewards"];
        if (variable_struct_exists(rewards, "coins")) {
            global.coins = variable_global_exists("coins") ? global.coins + rewards.coins : rewards.coins;
        }
        if (variable_struct_exists(rewards, "item")) {
            obj_inventory.add_to_inventory(rewards.item);
        }
        var progress = ds_map_find_value(global.quest_progress, quest_id);
        ds_map_destroy(progress);
        ds_map_delete(global.quest_progress, quest_id);
        show_debug_message("Completed quest: " + quest[?"name"]);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_crates
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Create_0.gml
// Set item properties
item_type = ""; // Set when the object is created
sprite_index = spr_inventory_items;
is_savable = true; // Mark as savable
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Draw_0.gml
// Draw the dropped item
draw_sprite(sprite_index, 0, x, y);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Step_0.gml
// Check if player picks up the item
if (distance_to_object(global.player_instance) < 16 && keyboard_check_pressed(ord("E"))) {
    obj_inventory.add_to_inventory(item_type);
    instance_destroy();
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_epfphone_item
File: Create_0.gml
event_inherited();
item_name = "EPF Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel1
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel2
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel3
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel4
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishing_rod
File: Create_0.gml
event_inherited();
item_name = "Fishing Rod";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_game_manager
File: CleanUp_0.gml
/// @description Clean up game manager resources

// Execute all registered cleanup handlers
for (var i = 0; i < array_length(game_end_handlers); i++) {
    var handler = game_end_handlers[i];
    handler();
}

show_debug_message("Game manager cleanup complete"); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_game_manager
File: Create_0.gml
/// @description Initialize game systems

// Initialize core systems
global.game_state = new GameState().init();
global.resource_manager = new ResourceManager().init();
global.collision_system = new CollisionSystem().init();
global.save_load_system = new SaveLoadSystem().init();
global.transition_manager = new RoomTransitionManager().init();
global.network_manager = new NetworkManager().init();

// Initialize room configurations
init_room_configurations();

// Initialize performance monitoring
global.fps_real = fps_real;
global.instance_count = instance_count;
global.memory_usage = memory_get_usage();

// Debug mode
global.debug_mode = false;

// Initialize game timer
global.play_time = 0;

// Make persistent
persistent = true;

// Initialize debug variables
global.debug_overlay = false;
global.show_collisions = false;
global.show_quest_areas = false;
global.show_npc_paths = false;
global.show_hitbox = false;
global.show_room_grid = false;

// Set up cleanup on game end
game_end_handlers = [];
array_push(game_end_handlers, method(global.resource_manager, global.resource_manager.cleanup));

// Initialize asset management
asset_config = {
    fonts: {
        default: fnt_bumbastika_sml,
        title: fnt_acme_explosive,
        ui: fnt_AgentCode,
        impact: fnt_bonkfatty
    },
    sprites: {
        ui: {
            panel: spr_blue_square_panel,
            button: spr_button,
            dialog: spr_npc_dialouge_box
        },
        effects: {
            snow: spr_snow_item,
            transition: spr_warp_transition
        }
    },
    sounds: {
        // Add your existing sound assets here
    }
};

// Initialize room variants
room_variants = {
    dojo: {
        base_room: rm_snow_fort,
        layout: "dojo",
        music: "dojo_theme",
        background_color: c_black
    },
    arena: {
        base_room: rm_plaza,
        layout: "arena",
        music: "battle_theme",
        clear_center: true
    },
    tutorial: {
        base_room: rm_welcome_room,
        layout: "tutorial",
        music: "tutorial_theme",
        simplified: true
    },
    achievement_hall: {
        base_room: rm_ski_village,
        layout: "hall",
        music: "celebration_theme",
        add_displays: true
    }
};

// Initialize weather system using existing sprites
weather_system = {
    enabled: false,
    current: "none",
    types: {
        snow: {
            sprite: spr_snow_item,
            particle_system: undefined,
            settings: {
                scale: 0.3,
                speed: 2,
                direction: 270,
                spread: 20
            }
        },
        rain: {
            sprite: spr_snow_item,  // Reuse snow sprite with different settings
            particle_system: undefined,
            settings: {
                scale: 0.1,
                speed: 8,
                direction: 270,
                spread: 10
            }
        }
    }
};

// Initialize achievement system using existing assets
achievement_system = {
    display_sprite: spr_npc_dialouge_box,
    display_font: fnt_acme_explosive,
    display_time: 3,
    achievements: ds_map_create()
};

show_debug_message("Game Manager initialized with consolidated assets");

// Migration function for transitioning to new system
function migrate_to_new_system() {
    show_debug_message("Starting migration to new system...");
    
    // Migrate player state
    with(global.game_state) {
        if (instance_exists(global.player_instance)) {
            player.instance = global.player_instance;
            player.x = global.player_instance.x;
            player.y = global.player_instance.y;
            player.color = global.player_instance.image_blend;
            player.skin = global.current_skin;
        }
        
        // Migrate game flags
        flags.is_paused = global.is_pause_menu_active;
        flags.inventory_open = global.inventory_open;
        flags.expanded_hud_open = global.expanded_hud_open;
        flags.debug_mode = global.debug_mode;
        
        // Migrate room state
        if (variable_global_exists("last_player_x")) {
            room_state.last_player_x = global.last_player_x;
            room_state.last_player_y = global.last_player_y;
            room_state.last_player_face = global.last_player_face;
        }
    }
}

// Auto-load last save if it exists
if (file_exists("saves/save_0.sav")) {
    global.save_load_system.load_game(0);
} else {
    migrate_to_new_system();
}

// Performance optimization settings
gpu_set_tex_filter(false);
gpu_set_tex_mip_enable(false);
gpu_set_tex_mip_filter(tf_none);
draw_set_font(-1); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_game_manager
File: Draw_64.gml
/// @description Draw GUI elements

// Set default font
draw_set_font(asset_config.fonts.default);

// Draw achievements if any are displaying
var achievement_y = 20;
if (!ds_map_empty(achievement_system.achievements)) {
    for (var key = ds_map_find_first(achievement_system.achievements); 
         key != undefined; 
         key = ds_map_find_next(achievement_system.achievements, key)) {
        var achievement = achievement_system.achievements[? key];
        if (achievement.is_displaying) {
            var alpha = min(1, achievement.display_timer / achievement_system.display_time);
            draw_sprite_ext(
                achievement_system.display_sprite,
                0,
                20,
                achievement_y,
                1,
                1,
                0,
                c_white,
                alpha
            );
            
            draw_set_font(achievement_system.display_font);
            draw_set_alpha(alpha);
            draw_text(
                40,
                achievement_y + 10,
                achievement.title + "\n" + achievement.description
            );
            draw_set_alpha(1);
            draw_set_font(asset_config.fonts.default);
            
            achievement_y += 80;
        }
    }
}

// Draw debug overlay if enabled
if (global.debug_overlay) {
    draw_set_font(asset_config.fonts.ui);
    draw_set_color(c_black);
    draw_set_alpha(0.7);
    draw_rectangle(0, 0, 200, 160, false);
    draw_set_alpha(1);
    draw_set_color(c_white);
    
    var debug_text = 
        "FPS: " + string(fps_real) + "\n" +
        "Memory: " + string(round(memory_get_usage() / 1024 / 1024)) + "MB\n" +
        "Instances: " + string(instance_count) + "\n" +
        "Room: " + room_get_name(room) + "\n" +
        "Play Time: " + string(floor(global.play_time / 60)) + "m " + 
        string(floor(global.play_time % 60)) + "s";
    
    draw_text(10, 10, debug_text);
    
    // Draw current weather status if enabled
    if (weather_system.enabled) {
        draw_text(
            10,
            120,
            "Weather: " + weather_system.current + "\n" +
            "Particles: " + string(part_particles_count(
                weather_system.types[? weather_system.current].particle_system
            ))
        );
    }
}

// Draw room variant info if in debug mode
if (global.debug_mode) {
    var current_variant = noone;
    for (var key = ds_map_find_first(room_variants); key != undefined; key = ds_map_find_next(room_variants, key)) {
        var variant = room_variants[? key];
        if (room == variant.base_room) {
            current_variant = variant;
            break;
        }
    }
    
    if (current_variant != noone) {
        draw_set_font(asset_config.fonts.ui);
        draw_set_color(c_black);
        draw_set_alpha(0.7);
        draw_rectangle(0, display_get_gui_height() - 60, 250, display_get_gui_height(), false);
        draw_set_alpha(1);
        draw_set_color(c_white);
        
        var variant_text = 
            "Variant: " + string(key) + "\n" +
            "Layout: " + string(current_variant.layout) + "\n" +
            "Music: " + string(current_variant.music);
        
        draw_text(10, display_get_gui_height() - 50, variant_text);
    }
}

// Reset drawing properties
draw_set_font(-1);
draw_set_color(c_white);
draw_set_alpha(1);

// Draw transition effects
global.transition_manager.draw_transition();

// Draw collision view if enabled
if (global.show_collisions) {
    draw_collision_view();
}

// Draw quest areas if enabled
if (global.show_quest_areas) {
    draw_quest_areas();
}

// Draw NPC paths if enabled
if (global.show_npc_paths) {
    draw_npc_paths();
}

// Draw hitboxes if enabled
if (global.show_hitbox) {
    draw_hitboxes();
}

// Draw room grid if enabled
if (global.show_room_grid) {
    draw_room_grid();
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_game_manager
File: Step_0.gml
/// @description Update game systems

// Update core systems
global.game_state.update();
global.resource_manager.update();
global.collision_system.update();
global.network_manager.update();
global.transition_manager.update();

// Update play time
global.play_time += delta_time / 1000000;

// Update performance monitoring
global.fps_real = fps_real;
global.instance_count = instance_count;
global.memory_usage = memory_get_usage();

// Handle room variant updates
if (room != -1) {
    var current_variant = noone;
    
    // Check if current room is a variant
    for (var key = ds_map_find_first(room_variants); key != undefined; key = ds_map_find_next(room_variants, key)) {
        var variant = room_variants[? key];
        if (room == variant.base_room) {
            current_variant = variant;
            break;
        }
    }
    
    // Apply variant-specific updates
    if (current_variant != noone) {
        // Update music if needed
        if (audio_is_playing(global.current_music) && 
            asset_get_index(current_variant.music) != global.current_music) {
            audio_stop_sound(global.current_music);
            global.current_music = audio_play_sound(
                asset_get_index(current_variant.music),
                10,
                true
            );
        }
        
        // Update room appearance
        if (current_variant.background_color != undefined) {
            draw_set_color(current_variant.background_color);
        }
        
        // Handle specific variant logic
        switch (current_variant.layout) {
            case "dojo":
                update_dojo_layout();
                break;
            case "arena":
                update_arena_layout();
                break;
            case "tutorial":
                update_tutorial_layout();
                break;
            case "hall":
                update_achievement_hall();
                break;
        }
    }
}

// Update weather system
if (weather_system.enabled) {
    var weather = weather_system.types[? weather_system.current];
    if (weather != undefined && weather.particle_system != undefined) {
        part_system_update(weather.particle_system);
        
        // Adjust particle emission based on weather intensity
        var emit_count = 2;  // Default emission rate
        switch (weather_system.current) {
            case "snow":
                emit_count = 2 + sin(current_time / 1000) * 1;  // Varying snow intensity
                break;
            case "rain":
                emit_count = 5;  // Consistent rain
                break;
        }
        
        repeat(emit_count) {
            var px = random(room_width);
            var py = -10;
            part_particles_create(
                weather.particle_system,
                px,
                py,
                weather.particle_type,
                1
            );
        }
    }
}

// Update achievement system
if (!ds_map_empty(achievement_system.achievements)) {
    for (var key = ds_map_find_first(achievement_system.achievements); 
         key != undefined; 
         key = ds_map_find_next(achievement_system.achievements, key)) {
        var achievement = achievement_system.achievements[? key];
        if (achievement.display_timer > 0) {
            achievement.display_timer -= delta_time / 1000000;
            if (achievement.display_timer <= 0) {
                achievement.is_displaying = false;
            }
        }
    }
}

// Debug mode updates
if (global.debug_mode) {
    if (keyboard_check_pressed(vk_f3)) {
        global.debug_overlay = !global.debug_overlay;
    }
    if (keyboard_check_pressed(vk_f4)) {
        global.show_collisions = !global.show_collisions;
    }
    if (keyboard_check_pressed(vk_f5)) {
        global.show_quest_areas = !global.show_quest_areas;
    }
    if (keyboard_check_pressed(vk_f6)) {
        global.show_npc_paths = !global.show_npc_paths;
    }
    if (keyboard_check_pressed(vk_f7)) {
        global.show_hitbox = !global.show_hitbox;
    }
    if (keyboard_check_pressed(vk_f8)) {
        global.show_room_grid = !global.show_room_grid;
    }
}

// Room-specific layout update functions
function update_dojo_layout() {
    // Update dojo-specific elements
    if (!variable_instance_exists(id, "dojo_initialized")) {
        // First-time initialization
        dojo_initialized = true;
        // Set up dojo-specific objects and layout
    }
}

function update_arena_layout() {
    if (!variable_instance_exists(id, "arena_initialized")) {
        arena_initialized = true;
        // Clear center area if needed
        if (room_variants.arena.clear_center) {
            // Clear objects in center
        }
    }
}

function update_tutorial_layout() {
    if (!variable_instance_exists(id, "tutorial_initialized")) {
        tutorial_initialized = true;
        if (room_variants.tutorial.simplified) {
            // Simplify room layout
        }
    }
}

function update_achievement_hall() {
    if (!variable_instance_exists(id, "hall_initialized")) {
        hall_initialized = true;
        if (room_variants.achievement_hall.add_displays) {
            // Add achievement displays
        }
    }
}

// Update game state from current instance states
with(global.game_state) {
    update_from_player();
    sync_globals();
}

// Update room transition manager
global.transition_manager.update();

// Handle network updates
if (global.network_manager.current_state != NETWORK_STATE.DISCONNECTED) {
    // Send player state update
    global.network_manager.send_player_state();
    
    // Handle network messages
    var type = network_type_data;
    var sock = ds_map_find_first(global.network_manager.connected_players);
    while (sock != undefined) {
        var buff = network_receive_packet(sock, type);
        if (buff != undefined) {
            global.network_manager.handle_network_message(buff, sock);
            buffer_delete(buff);
        }
        sock = ds_map_find_next(global.network_manager.connected_players, sock);
    }
    
    // Update ping every second
    if (current_time - global.network_manager.last_ping_time > 1000) {
        global.network_manager.last_ping_time = current_time;
        global.network_manager.send_ping();
    }
}

// Handle network updates if connected
if (variable_global_exists("network_manager")) {
    with(global.network_manager) {
        // Update world state if host
        if (is_host && current_time - sync_config.last_world_sync >= sync_config.world_sync_interval) {
            send_world_state();
            sync_config.last_world_sync = current_time;
        }
        
        // Interpolate network objects
        interpolate_objects();
        
        // Send ping every second if connected
        if (current_state == NETWORK_STATE.CONNECTED && current_time - last_ping_time >= 1000) {
            send_ping();
        }
    }
}

// Performance monitoring
if (global.game_state.flags.debug_mode) {
    global.fps_real = fps_real;
    global.instance_count = instance_count;
    global.memory_usage = memory_get_usage();
    
    // Add network stats if connected
    if (variable_global_exists("network_manager")) {
        with(global.network_manager) {
            if (current_state == NETWORK_STATE.CONNECTED) {
                other.debug_stats.network = {
                    ping: ping,
                    connected_players: ds_map_size(connected_players),
                    is_host: is_host,
                    snapshot_count: ds_list_size(sync_config.snapshot_history)
                };
            }
        }
    }
}

// Auto-save every 5 minutes (300 seconds)
if (global.play_time mod 300 < delta_time / 1000000) {
    global.save_load_system.save_game(0);
}

// Performance optimization checks
if (global.game_state.flags.debug_mode) {
    // Check for potential memory leaks
    var current_memory = memory_get_usage();
    if (current_memory > global.memory_usage * 1.5) { // 50% increase threshold
        show_debug_message("WARNING: Significant memory usage increase detected!");
        show_debug_message("Current memory: " + string(current_memory) + " bytes");
    }
    
    // Check for FPS drops
    if (fps_real < room_speed * 0.8) { // 20% drop threshold
        show_debug_message("WARNING: FPS drop detected!");
        show_debug_message("Current FPS: " + string(fps_real) + "/" + string(room_speed));
    }
    
    // Instance count monitoring
    if (instance_count > 1000) { // Arbitrary threshold, adjust based on your game
        show_debug_message("WARNING: High instance count detected: " + string(instance_count));
    }
    
    // Network status monitoring
    if (global.network_manager.current_state != NETWORK_STATE.DISCONNECTED) {
        show_debug_message("Network Status:");
        show_debug_message("- State: " + string(global.network_manager.current_state));
        show_debug_message("- Connected Players: " + string(ds_map_size(global.network_manager.connected_players)));
        show_debug_message("- Ping: " + string(global.network_manager.ping) + "ms");
    }
}

// Draw debug overlay if enabled
if (global.game_state.flags.debug_mode) {
    draw_debug_overlay();
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Create_0.gml
// obj_hud_expanded: Create Event
depth = -10000;
inventory = obj_inventory.inventory;
inventory_size = obj_inventory.inventory_size;
active_slot = obj_inventory.active_slot;
global.active_item_index = active_slot;
global.is_special_actions_open = false
is_active = true;
global.expanded_hud_instance = id;

// Add config button
config_button = {
    x: display_get_gui_width() - 40,
    y: 10,
    width: 30,
    height: 30,
    sprite: spr_config_button,
    hover: false
};
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Draw_64.gml
/// @description Draw expanded HUD

// obj_hud_expanded: Draw GUI Event
if (is_active) {
if (global.is_expanded) {
    var ui_scale = 3;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var inv_width = sprite_get_width(spr_hud_expanded) * ui_scale;
    var inv_height = sprite_get_height(spr_hud_expanded) * ui_scale;
    var inv_x = (gui_width - inv_width) / 2;
    var inv_y = gui_height - inv_height;
    draw_sprite_ext(spr_hud_expanded, 0, inv_x, inv_y, ui_scale, ui_scale, 0, c_white, 1);

    // Draw inventory items
    var slot_positions = [
        [inv_x + 5 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 25 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 45 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 65 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 85 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 105 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 125 * ui_scale, inv_y + 14 * ui_scale],
        [inv_x + 145 * ui_scale, inv_y + 14 * ui_scale]
    ];

    for (var i = 0; i < 8; i++) {
        if (inventory[i] != -1) {
            var slot_x = slot_positions[i][0];
            var slot_y = slot_positions[i][1];
            draw_sprite_part_ext(spr_inventory_items, 0, inventory[i] * 18, 0, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
            if (i == active_slot) {
                draw_sprite_ext(spr_inventory_highlight, 0, slot_x - 1 * ui_scale, slot_y - 1 * ui_scale, ui_scale, ui_scale, 0, c_white, 1);
            }
        }
    }

    // Draw special actions menu
    if (global.is_special_actions_open) {
        var special_x = inv_x + 85 * ui_scale;
        var special_y = inv_y + 37 * ui_scale - sprite_get_height(spr_hud_special_actions) * ui_scale;
        draw_sprite_ext(spr_hud_special_actions, 0, special_x, special_y, ui_scale, ui_scale, 0, c_white, 1);
    }

    // Draw config button
    draw_sprite_ext(config_button.sprite, 0,
        config_button.x, config_button.y,
        1, 1, 0,
        config_button.hover ? c_gray : c_white,
        1);
}
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_hud_expanded
File: Step_0.gml
// obj_hud_expanded Step event
if (global.chat_active) exit;
// Handle mouse clicks
if (is_active) {
    if (mouse_check_button_pressed(mb_left)) {
        var mx = device_mouse_x_to_gui(0);
        var my = device_mouse_y_to_gui(0);
	
    var ui_scale = 3;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    var inv_width = sprite_get_width(spr_hud_expanded) * ui_scale;
    var inv_x = (gui_width - inv_width) / 2;
    var inv_y = gui_height - sprite_get_height(spr_hud_expanded) * ui_scale;
    var close_area_left = inv_x + 54 * ui_scale;
    var close_area_top = inv_y + 2 * ui_scale;
    var close_area_right = inv_x + 112 * ui_scale;
    var close_area_bottom = inv_y + 9 * ui_scale;
	// Define the special actions button area
    var special_area_left = inv_x + 85 * ui_scale;
    var special_area_top = inv_y + 37 * ui_scale;
    var special_area_right = inv_x + 102 * ui_scale;
    var special_area_bottom = inv_y + 54 * ui_scale;

	if (point_in_rectangle(mx, my, close_area_left, close_area_top, close_area_right, close_area_bottom)) {
	    global.expanded_hud_open = false; // Add this line
	    global.is_expanded = false;
	    instance_destroy();
	    global.expanded_hud_instance = noone;
	    show_debug_message("Expanded HUD closed successfully.");
	    global.click_handled = true;
	    return;
	}
		// Open expanded inventory menu
        else if (point_in_rectangle(mx, my, inv_x + 65 * ui_scale, inv_y + 37 * ui_scale, inv_x + 82 * ui_scale, inv_y + 54 * ui_scale)) {
            instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
            show_debug_message("Expanded inventory menu opened.");
        }
        // Open special actions menu
        else if (point_in_rectangle(mx, my, special_area_left, special_area_top, special_area_right, special_area_bottom)) {
        global.is_special_actions_open = !global.is_special_actions_open;
        show_debug_message("Special actions menu toggled: " + (global.is_special_actions_open ? "open" : "closed"));
        return;
		}
        // Throw a snowball (placeholder)
        else if (point_in_rectangle(mx, my, inv_x + 105 * ui_scale, inv_y + 37 * ui_scale, inv_x + 122 * ui_scale, inv_y + 54 * ui_scale)) {
            global.is_expanded = false;
            show_debug_message("Throw snowball clicked - to be implemented.");
            // Add snowball logic here later
        }
        // Go to igloo (placeholder)
        else if (point_in_rectangle(mx, my, inv_x + 125 * ui_scale, inv_y + 37 * ui_scale, inv_x + 142 * ui_scale, inv_y + 54 * ui_scale)) {
            global.is_expanded = false;
            show_debug_message("Go to igloo clicked - to be implemented.");
            // Add igloo room transition here later
        }
        // Open configuration menu
        else if (point_in_rectangle(mx, my, inv_x + 145 * ui_scale, inv_y + 37 * ui_scale, inv_x + 162 * ui_scale, inv_y + 54 * ui_scale)) {
            global.ui_manager.open_ui(obj_config_menu);
            show_debug_message("Configuration menu opened.");
            is_active = false; // Deactivate the expanded HUD
            return;
        }
        
         // Handle special actions menu clicks
    if (global.is_special_actions_open) {
        var special_x = inv_x + 85 * ui_scale;
        var special_y = inv_y + 37 * ui_scale - sprite_get_height(spr_hud_special_actions) * ui_scale;
        
        // Wave action (coordinates: adjust as per your sprite layout)
        if (point_in_rectangle(mx, my, special_x + 1 * ui_scale, special_y + 41 * ui_scale, special_x + 16 * ui_scale, special_y + 55 * ui_scale)) {
            obj_player.action_state = "wave";
            obj_player.action_timer = 0;
            obj_player.action_duration = 80; // 16 frames * 5 steps (0.2 speed)
            obj_player.image_index = 0;
            show_debug_message("Wave action triggered");
            global.is_special_actions_open = false;
            global.is_expanded = false;
            instance_destroy();
        }
        // Sit action
        else if (point_in_rectangle(mx, my, inv_x + 145 * ui_scale, inv_y + 37 * ui_scale, inv_x + 162 * ui_scale, inv_y + 54 * ui_scale)) {
        if (instance_exists(global.player_instance)) {
            if (global.player_instance.action_state == "sit") {
                global.player_instance.action_state = "none";
                show_debug_message("Stopped sitting via HUD.");
            } else {
                global.player_instance.action_state = "sit";
                global.player_instance.action_timer = 0;
                global.player_instance.action_duration = -1;
                global.player_instance.image_index = 0;
                show_debug_message("Started sitting via HUD.");
            }
        }
        global.click_handled = true;
    }
        // Dance action
        else if (point_in_rectangle(mx, my, special_x + 1 * ui_scale, special_y + 1 * ui_scale, special_x + 16 * ui_scale, special_y + 24 * ui_scale)) {
            obj_player.action_state = "dance";
            obj_player.action_timer = 0;
            obj_player.action_duration = 224; // 56 frames * 4 steps (0.25 speed)
            obj_player.image_index = 0;
            show_debug_message("Dance action triggered");
            global.is_special_actions_open = false;
            global.is_expanded = false;
            instance_destroy();
        }
    }
}

// Handle config button
var gui_x = device_mouse_x_to_gui(0);
var gui_y = device_mouse_y_to_gui(0);

config_button.hover = point_in_rectangle(gui_x, gui_y,
    config_button.x, config_button.y,
    config_button.x + config_button.width,
    config_button.y + config_button.height);

if (config_button.hover && mouse_check_button_pressed(mb_left)) {
    instance_create_layer(0, 0, "Instances", obj_config_menu);
}

show_debug_message("obj_hud_expanded is_active = " + string(is_active));
show_debug_message("obj_hud_expanded exists: " + string(instance_exists(obj_hud_expanded)));
// Keep existing depth setting
depth = -1000;

// Function: Check if player has an item
function has_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) return false;
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) return true;
    }
    return false;
}

// Function: Add an item to the inventory
function add_to_inventory(item_name) {
    if (has_item(item_name)) {
        show_debug_message("WARNING: " + item_name + " is already in the inventory.");
        return false;
    }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == -1) { // Empty slot
            inventory[i] = item_index;
            show_debug_message("Added " + item_name + " to inventory in slot " + string(i));
            return true;
        }
    }

    show_debug_message("Inventory full!");
    return false;
}

// Function: Remove an item from the inventory
function remove_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            inventory[i] = -1;
            show_debug_message("Removed " + item_name + " from inventory slot " + string(i));
            return true;
        }
    }

    show_debug_message("ERROR: Item " + item_name + " not found in inventory!");
    return false;
}

// Function: Drop the active item
function drop_active_item() {
    var item_index = inventory[active_slot];
    if (item_index == -1) {
        show_debug_message("No item in active slot to drop.");
        return;
    }

    // Find the item name from the index
    var item_name = "";
    var keys = ds_map_keys_to_array(global.item_index_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (ds_map_find_value(global.item_index_map, keys[i]) == item_index) {
            item_name = keys[i];
            break;
        }
    }

    if (item_name != "") {
        // Get the corresponding object from item_object_map
        var dropped_object = ds_map_find_value(global.item_object_map, item_name);
        if (!is_undefined(dropped_object) && object_exists(dropped_object)) {
            // Create the specific object instance at the player's position
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", dropped_object);
            show_debug_message("Dropped " + item_name + " as " + object_get_name(dropped_object) + " at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
        } else {
            show_debug_message("ERROR: No valid object mapped for item " + item_name + ". Dropping as generic obj_dropped_item.");
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", obj_dropped_item);
            dropped_item.item_type = item_name; // Fallback to generic item
        }
    } else {
        show_debug_message("ERROR: Could not find item name for index " + string(item_index));
        return;
    }

    // Remove the item from the inventory
    inventory[active_slot] = -1;
    show_debug_message("Removed " + item_name + " from inventory slot " + string(active_slot));
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint
mask_index = spr_icetruck_down; // For collision detection

// Existing state variables
repair_required = false;
is_driveable = true;
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming DOWN direction
var frame_y = 0;
var frame_width = 48;
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display interaction prompt when player is close
if (distance_to_object(global.player_instance) < 16 && global.current_skin == "player") {
    var text = "Press 'E' to drive";
    var text_width = string_width(text);
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x + (sprite_width / 2) - (text_width / 2), y - 20, text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Step_0.gml
// Ensure the truck is repaired before allowing entry
if (!repair_required) { 
    if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 32) {
        if (global.current_skin == "player") {
            // Enter the ice truck
            var player_x = global.player_instance.x;
            var player_y = global.player_instance.y;

            instance_destroy(global.player_instance); // Remove player
            instance_destroy(id); // Remove icetruck

            global.player_instance = instance_create_layer(player_x, player_y, "Instances", obj_player_icetruck);
            global.current_skin = "icetruck";

            show_debug_message("Entered ice truck. Current skin: " + global.current_skin);
        }
    }
} else {
    show_debug_message("The truck is still broken! Repair it first.");
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_0.gml
global.repair_cooldown = false;
show_debug_message("Repair cooldown ended. You can now enter the truck.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_1.gml
show_debug_message("DEBUG: Resetting repair flag...");
global.repair_complete = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty_repairable;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint, consistent with obj_player_icetruck
mask_index = spr_icetruck_facedown; // For collision detection

// Existing state variables
repair_required = true;
repair_complete = false;
global.repair_complete = false;
is_driveable = false;

alarm[1] = 5; // Keep the repair flag active for 5 frames
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming frame 0 is the DOWN direction
var frame_y = 0;
var frame_width = 48; // Match sprite sheet dimensions
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display repair prompt if player is near
if (distance_to_object(obj_player) < 24) {
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x - 20, y - 20, "Press 'R' to repair");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Step_0.gml
// Ensure player is near and pressing "R" to repair
if (keyboard_check_pressed(ord("R")) && distance_to_object(obj_player) < 16) {
    if (obj_inventory.has_item("Wrench") > 0 || obj_inventory.has_item("Battery") > 0) {
    
        show_debug_message("Repairing ice truck...");
        
        // Destroy the broken truck
        instance_destroy();
        
        // Replace with repaired version
        var new_truck = instance_create_layer(x, y, "Instances", obj_icetruck);
        new_truck.repair_required = false;
		new_truck.repair_complete = true;
		global.repair_complete = true;
		show_debug_message("DEBUG: Setting global.repair_complete = true");
        new_truck.is_driveable = true;

        // Prevent instant entry by disabling key input for a short time
        global.repair_cooldown = true;
        alarm[0] = 30; // 0.5 sec cooldown
        
        show_debug_message("Ice truck repaired! It is now driveable.");
    } else {
        show_debug_message("You need a wrench or a battery to repair this!");
		show_debug_message("Has Wrench: " + string(obj_inventory.has_item("Wrench")));
		show_debug_message("Has Battery: " + string(obj_inventory.has_item("Battery")));
		show_debug_message("Distance to player: " + string(distance_to_object(obj_player)));
		if (keyboard_check_pressed(ord("R"))) {
	    show_debug_message("R key pressed");
	}
    }
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Create_0.gml
// Create Event
scale = 2; // Adjust as needed
panel_width = sprite_get_width(spr_colourpicker_panel) * scale;
panel_height = sprite_get_height(spr_colourpicker_panel) * scale;
x = (display_get_gui_width() - panel_width) / 2;
y = (display_get_gui_height() - panel_height) / 2;
depth = -10000;

// Define colors (unchanged)
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Grid positioning
var grid_width = (5 * 20 + 4 * 5) * scale;
var grid_height = (3 * 20 + 2 * 5) * scale;
start_x = x + 108 * scale + (135 * scale - grid_width) / 2;
start_y = y + 35 * scale + (115 * scale - grid_height) / 2;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Destroy_0.gml
// Destroy Event for obj_icetruck_colourpicker
show_debug_message("Icetruck colourpicker destroyed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Draw_64.gml
// Draw GUI Event
draw_sprite_ext(spr_colourpicker_panel, 0, x, y, scale, scale, 0, c_white, 1);

// Viewer
var viewer_x = x + 9 * scale;
var viewer_y = y + 35 * scale;
var viewer_width = (83 - 9) * scale;
var viewer_height = (150 - 35) * scale;
var scale_preview = min(viewer_width / 48, viewer_height / 48) * scale;
var tint = instance_exists(obj_player_icetruck) ? obj_player_icetruck.icetruck_tint : c_white;
draw_sprite_part_ext(spr_icetruck_base, 0, 48, 48, 48, 48, viewer_x + viewer_width / 2 - 24 * scale_preview, viewer_y + viewer_height / 2 - 24 * scale_preview, scale_preview, scale_preview, c_white, 1);
draw_sprite_part_ext(spr_icetruck_colour, 0, 48, 48, 48, 48, viewer_x + viewer_width / 2 - 24 * scale_preview, viewer_y + viewer_height / 2 - 24 * scale_preview, scale_preview, scale_preview, tint, 1);

// Color previews
var scale_icon = (20 * scale) / 48;
for (var i = 0; i < 15; i++) {
    var col = i mod 5;
    var row = i div 5;
    var icon_x = start_x + col * 25 * scale;
    var icon_y = start_y + row * 25 * scale;
    draw_sprite_part_ext(spr_icetruck_base, 0, 48, 48, 48, 48, icon_x, icon_y, scale_icon, scale_icon, c_white, 1);
    draw_sprite_part_ext(spr_icetruck_colour, 0, 48, 48, 48, 48, icon_x, icon_y, scale_icon, scale_icon, colors[i], 1);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Mouse_4.gml
// Mouse Pressed Event for obj_icetruck_colourpicker
var mx = device_mouse_x_to_gui(0);
var my = device_mouse_y_to_gui(0);

for (var i = 0; i < array_length(colour_slots[i]); i++) {
    var slot_x = x + slot_positions[i][0];
    var slot_y = y + slot_positions[i][1];
    if (point_in_rectangle(mx, my, slot_x, slot_y, slot_x + 17, slot_y + 17)) {
        if (instance_exists(obj_player_icetruck)) {
            obj_player_icetruck.icetruck_tint = color_options[i];
            show_debug_message("Ice truck color changed to: " + string(color_options[i]));
        }
        break;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Step_0.gml
// Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Close area
    if (point_in_rectangle(mx, my, x + 98 * scale, y + 1 * scale, x + 156 * scale, y + 11 * scale)) {
        instance_destroy();
        show_debug_message("Icetruck color picker closed.");
        global.ui_manager.close_ui();
        global.click_handled = true;
        return;
    }
    
    // Color selection
    for (var i = 0; i < 15; i++) {
        var col = i mod 5;
        var row = i div 5;
        var icon_x = start_x + col * 25;
        var icon_y = start_y + row * 25;
        if (point_in_rectangle(mx, my, icon_x, icon_y, icon_x + 20, icon_y + 20)) {
            if (instance_exists(obj_player_icetruck)) {
                obj_player_icetruck.icetruck_tint = colors[i];
                show_debug_message("Icetruck tint set to: " + string(colors[i]));
            } else {
                show_debug_message("No icetruck instance found to set tint.");
            }
            instance_destroy();
            global.ui_manager.close_ui();
            global.click_handled = true;
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Create_0.gml
/// Create Event for obj_initializer
if (!variable_global_exists("following_puffles") || !ds_exists(global.following_puffles, ds_type_list)) {
    global.following_puffles = ds_list_create();
}
// Initialize inventory items
if (!variable_global_exists("item_index_map")) {
    global.item_index_map = ds_map_create();
    var item_names = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone","Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice",  "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
    for (var i = 0; i < array_length(item_names); i++) {
        ds_map_add(global.item_index_map, item_names[i], i);
    }
    show_debug_message("DEBUG: global.item_index_map initialized in obj_initializer.");
} else {
    show_debug_message("DEBUG: global.item_index_map already exists.");
}

// Initialize dropped items
if (!variable_global_exists("item_object_map")) {
    global.item_object_map = ds_map_create();
    ds_map_add(global.item_object_map, "Battery", obj_battery);
    ds_map_add(global.item_object_map, "Box Puffle O", obj_boxpuffleo_item);
    ds_map_add(global.item_object_map, "EPF Phone", obj_epfphone_item);
    ds_map_add(global.item_object_map, "Fishing Rod", obj_fishing_rod);
    ds_map_add(global.item_object_map, "Jackhammer", obj_Jackhammer_item);
    ds_map_add(global.item_object_map, "Map", obj_map_item);
    ds_map_add(global.item_object_map, "Party Hat", obj_party_hat);
	ds_map_add(global.item_object_map, "Beta Hat", obj_beta_hat);
    ds_map_add(global.item_object_map, "Pizza Slice", obj_pizzaslice_item);
    ds_map_add(global.item_object_map, "Puffle O", obj_puffleo_item);
    ds_map_add(global.item_object_map, "Puffle Whistle", obj_pufflewhistle_item);
    ds_map_add(global.item_object_map, "Snow", obj_snow_item);
    ds_map_add(global.item_object_map, "Snow Shovel", obj_snowshovel_item);
	ds_map_add(global.item_object_map, "Broken_Spy Phone", obj_broken_spyphone_item);
    ds_map_add(global.item_object_map, "Spy Phone", obj_spyphone_item);
    ds_map_add(global.item_object_map, "Stamp Book", obj_stampbook_item);
    ds_map_add(global.item_object_map, "Starter Deck", obj_starterdeck_item);
    ds_map_add(global.item_object_map, "Wood", obj_wood_item);
	ds_map_add(global.item_object_map, "Wrench", obj_wrench_item);
    ds_map_add(global.item_object_map, "Tube", obj_tube);
	ds_map_add(global.item_object_map, "Toboggan", obj_toboggan);
    show_debug_message("DEBUG: global.item_object_map initialized in obj_initializer.");
} else {
    show_debug_message("DEBUG: global.item_object_map already exists.");
}

//initialize expanded inventory
if (!variable_global_exists("inventory_expanded")) {
    global.inventory_expanded = false;
}

// obj_initializer: Create Event (append to existing code)
if (!instance_exists(obj_inventory)) {
    instance_create_layer(0, 0, "Instances", obj_inventory);
}
if (!instance_exists(obj_map_icon)) {
    instance_create_layer(0, 0, "Instances", obj_map_icon);
}

// obj_initializer: Create Event (append)
if (!variable_global_exists("game_paused")) {
    global.game_paused = false;
}
//init expanded inventory equipped items
if (!variable_global_exists("equipped_items")) {
    global.equipped_items = ds_map_create();
    ds_map_add(global.equipped_items, "head", -1);
    ds_map_add(global.equipped_items, "face", -1);
    ds_map_add(global.equipped_items, "neck", -1);
    ds_map_add(global.equipped_items, "body", -1);
    ds_map_add(global.equipped_items, "hand", -1);
    ds_map_add(global.equipped_items, "feet", -1);
}

//init special action sprites
if (!variable_global_exists("item_player_sprites")) {
    global.item_player_sprites = ds_map_create();
    ds_map_add(global.item_player_sprites, 0, spr_player_betahat); // Beta Hat
	ds_map_add(global.item_player_sprites, 1, spr_player_partyhat); // Party Hat
    ds_map_add(global.item_player_sprites, ds_map_find_value(global.item_index_map, "Jackhammer"), spr_jackhammer_object);
    ds_map_add(global.item_player_sprites, ds_map_find_value(global.item_index_map, "Snow Shovel"), spr_snowshovel_object);
}
//init expanded inventory clothing item sprites
if (!variable_global_exists("item_type_map")) {
    global.item_type_map = ds_map_create();
    ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Beta Hat"), "head");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Party Hat"), "head");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Cool Shades"), "face");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Scarf"), "neck");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Jacket"), "body");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Gloves"), "hand");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Boots"), "feet");
// Add all other clothing items similarly
}

// Ensure party_hat_visible is set (default to false)
if (!variable_global_exists("party_hat_visible")) {
    global.party_hat_visible = false;
}

// Ensure beta_hat_visible is set (default to false)
if (!variable_global_exists("beta_hat_visible")) {
    global.beta_hat_visible = false;
}

// Initialize the global camera
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New camera created.");
}
view_set_camera(0, global.camera);

// Ensure global player instance is correctly set
if (!variable_global_exists("player_instance") || global.player_instance == noone) {
    if (instance_exists(obj_player)) {
        global.player_instance = obj_player;
    } else if (instance_exists(obj_sled_player)) {
        global.player_instance = obj_sled_player;
    } else if (instance_exists(obj_player_icetruck)) {
        global.player_instance = obj_player_icetruck;
    } else if (instance_exists(obj_player_tube)) {
        global.player_instance = obj_player_tube;
    } else if (instance_exists(obj_player_toboggan)) {
        global.player_instance = obj_player_toboggan;
	}
    show_debug_message("DEBUG: global.player_instance set to: " + string(global.player_instance));
}

//initialize icetruck colour picker
global.colour_picker_active = false;

show_debug_message("DEBUG: obj_initializer Create Event executed.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Other_2.gml
// Initialize all required global variables
global.player_instance = noone;
global.player_instance_initialized = false;
global.camera = noone;
global.current_skin = "player"; // Default skin
global.initialized = false; // To track overall initialization

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Step_0.gml
// Step Event for obj_initializer

// Ensure the camera is correctly set to follow the player
var cam = camera_create();
camera_set_view_target(cam, global.player_instance);
camera_apply(cam);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Create_0.gml
/// @description Initialize inventory system

// Initialize from game state if available
if (variable_global_exists("game_state")) {
    with(global.game_state) {
        var inventory_data = get_inventory_data();
        if (inventory_data != undefined) {
            other.items = inventory_data.items;
            other.equipped_items = inventory_data.equipped_items;
            other.max_items = inventory_data.max_items;
            other.coins = inventory_data.coins;
        } else {
            // New inventory initialization
            other.initialize_new_inventory();
        }
    }
} else {
    // Fallback initialization
    initialize_new_inventory();
}

// UI variables
inventory_width = 6;
inventory_height = 4;
slot_size = 32;
slot_padding = 4;
inventory_x = (display_get_gui_width() - (inventory_width * (slot_size + slot_padding))) / 2;
inventory_y = display_get_gui_height() - (inventory_height * (slot_size + slot_padding)) - 20;

// Selected slot
selected_slot = -1;
hover_slot = -1;
drag_slot = -1;
drag_offset_x = 0;
drag_offset_y = 0;

// Menu state
global.inventory_open_state = "closed";
global.inventory_visible = true;

// Function to initialize a new inventory
function initialize_new_inventory() {
    // Create inventory data structures
    items = ds_grid_create(inventory_width, inventory_height);
    equipped_items = ds_map_create();
    max_items = inventory_width * inventory_height;
    coins = 0;
    
    // Initialize all slots to empty
    for (var i = 0; i < inventory_width; i++) {
        for (var j = 0; j < inventory_height; j++) {
            items[# i, j] = {
                name: "",
                count: 0,
                sprite: -1,
                description: "",
                type: "",
                wearable: false
            };
        }
    }
    
    // Register with resource manager
    with(global.resource_manager) {
        set_structure("inventory_items", other.items);
        set_structure("equipped_items", other.equipped_items);
    }
}

// Function to toggle inventory
function toggle_inventory() {
    with(obj_menu_manager) {
        if (current_menu == MENU_STATE.INVENTORY) {
            close_menu();
            global.inventory_open_state = "closed";
        } else {
            open_menu(MENU_STATE.INVENTORY);
            global.inventory_open_state = "open";
        }
    }
}

// Function to add item to inventory
function add_item(item_name, count = 1) {
    // Find first empty slot or stack with same item
    for (var j = 0; j < inventory_height; j++) {
        for (var i = 0; i < inventory_width; i++) {
            var slot = items[# i, j];
            if (slot.name == "" || (slot.name == item_name && slot.count < 99)) {
                if (slot.name == "") {
                    // New slot
                    slot.name = item_name;
                    slot.count = count;
                    slot.sprite = get_item_sprite(item_name);
                    slot.description = get_item_description(item_name);
                    slot.type = get_item_type(item_name);
                    slot.wearable = is_item_wearable(item_name);
                } else {
                    // Stack with existing
                    slot.count = min(slot.count + count, 99);
                }
                show_debug_message("Added " + string(count) + "x " + item_name);
                return true;
            }
        }
    }
    show_debug_message("Inventory full - couldn't add " + item_name);
    return false;
}

// Function to remove item from inventory
function remove_item(item_name, count = 1) {
    for (var j = 0; j < inventory_height; j++) {
        for (var i = 0; i < inventory_width; i++) {
            var slot = items[# i, j];
            if (slot.name == item_name) {
                if (slot.count > count) {
                    slot.count -= count;
                } else {
                    // Clear slot
                    slot.name = "";
                    slot.count = 0;
                    slot.sprite = -1;
                    slot.description = "";
                    slot.type = "";
                    slot.wearable = false;
                }
                show_debug_message("Removed " + string(count) + "x " + item_name);
                return true;
            }
        }
    }
    show_debug_message("Item not found - couldn't remove " + item_name);
    return false;
}

// Function to check if item exists in inventory
function has_item(item_name) {
    for (var j = 0; j < inventory_height; j++) {
        for (var i = 0; i < inventory_width; i++) {
            var slot = items[# i, j];
            if (slot.name == item_name && slot.count > 0) {
                return true;
            }
        }
    }
    return false;
}

// Function to get item count
function get_item_count(item_name) {
    var total = 0;
    for (var j = 0; j < inventory_height; j++) {
        for (var i = 0; i < inventory_width; i++) {
            var slot = items[# i, j];
            if (slot.name == item_name) {
                total += slot.count;
            }
        }
    }
    return total;
}

// Helper functions for item properties
function get_item_sprite(item_name) {
    // Add your sprite lookup logic here
    return -1;
}

function get_item_description(item_name) {
    // Add your description lookup logic here
    return "";
}

function get_item_type(item_name) {
    // Add your type lookup logic here
    return "";
}

function is_item_wearable(item_name) {
    // Add your wearable check logic here
    return false;
}

// Register with game state
with(global.game_state) {
    register_inventory({
        items: other.items,
        equipped_items: other.equipped_items,
        max_items: other.max_items,
        coins: other.coins
    });
}

show_debug_message("Inventory initialized with new state system");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Draw_64.gml
/// @description Draw inventory GUI

// Draw inventory background
draw_set_alpha(0.8);
draw_set_color(c_black);
draw_rectangle(
    inventory_x - slot_padding,
    inventory_y - slot_padding,
    inventory_x + inventory_width * (slot_size + slot_padding),
    inventory_y + inventory_height * (slot_size + slot_padding),
    false
);
draw_set_alpha(1);

// Draw slots
for (var i = 0; i < inventory_width; i++) {
    for (var j = 0; j < inventory_height; j++) {
        var slot_x = inventory_x + i * (slot_size + slot_padding);
        var slot_y = inventory_y + j * (slot_size + slot_padding);
        var current_slot = i + j * inventory_width;
        
        // Draw slot background
        draw_set_color(current_slot == selected_slot ? c_yellow : c_gray);
        draw_rectangle(slot_x, slot_y, slot_x + slot_size, slot_y + slot_size, true);
        
        // Draw item in slot
        var item = items[# i, j];
        if (item.name != "") {
            // Skip if this is the dragged item
            if (current_slot != drag_slot) {
                // Draw item sprite
                if (item.sprite != -1) {
                    draw_sprite_stretched(
                        item.sprite,
                        0,
                        slot_x + 2,
                        slot_y + 2,
                        slot_size - 4,
                        slot_size - 4
                    );
                } else {
                    // Fallback: draw item name
                    draw_set_color(c_white);
                    draw_set_halign(fa_center);
                    draw_set_valign(fa_middle);
                    draw_text(
                        slot_x + slot_size/2,
                        slot_y + slot_size/2,
                        string_copy(item.name, 1, 1)
                    );
                }
                
                // Draw item count if more than 1
                if (item.count > 1) {
                    draw_set_color(c_white);
                    draw_set_halign(fa_right);
                    draw_set_valign(fa_bottom);
                    draw_text(
                        slot_x + slot_size - 2,
                        slot_y + slot_size - 2,
                        string(item.count)
                    );
                }
                
                // Draw equipped indicator
                if (item.wearable) {
                    var equipped = ds_map_find_value(equipped_items, item.type) == item.name;
                    if (equipped) {
                        draw_set_color(c_lime);
                        draw_circle(
                            slot_x + slot_size - 4,
                            slot_y + 4,
                            3,
                            false
                        );
                    }
                }
            }
        }
    }
}

// Draw dragged item
if (drag_slot != -1) {
    var drag_x = drag_slot mod inventory_width;
    var drag_y = drag_slot div inventory_width;
    var item = items[# drag_x, drag_y];
    
    if (item.name != "") {
        var mouse_x = device_mouse_x_to_gui(0);
        var mouse_y = device_mouse_y_to_gui(0);
        
        // Draw item sprite or name
        if (item.sprite != -1) {
            draw_sprite_stretched(
                item.sprite,
                0,
                mouse_x - drag_offset_x,
                mouse_y - drag_offset_y,
                slot_size,
                slot_size
            );
        } else {
            draw_set_color(c_white);
            draw_set_halign(fa_center);
            draw_set_valign(fa_middle);
            draw_text(
                mouse_x,
                mouse_y,
                string_copy(item.name, 1, 1)
            );
        }
        
        // Draw item count
        if (item.count > 1) {
            draw_set_color(c_white);
            draw_set_halign(fa_right);
            draw_set_valign(fa_bottom);
            draw_text(
                mouse_x - drag_offset_x + slot_size - 2,
                mouse_y - drag_offset_y + slot_size - 2,
                string(item.count)
            );
        }
    }
}

// Draw hover tooltip
if (hover_slot != -1 && drag_slot == -1) {
    var slot_x = hover_slot mod inventory_width;
    var slot_y = hover_slot div inventory_width;
    var item = items[# slot_x, slot_y];
    
    if (item.name != "") {
        var tooltip_x = device_mouse_x_to_gui(0) + 16;
        var tooltip_y = device_mouse_y_to_gui(0);
        var tooltip_width = string_width(item.description) + 16;
        var tooltip_height = string_height(item.description) + 16;
        
        // Draw tooltip background
        draw_set_alpha(0.9);
        draw_set_color(c_black);
        draw_rectangle(
            tooltip_x,
            tooltip_y,
            tooltip_x + tooltip_width,
            tooltip_y + tooltip_height,
            false
        );
        draw_set_alpha(1);
        
        // Draw tooltip text
        draw_set_color(c_white);
        draw_set_halign(fa_left);
        draw_set_valign(fa_top);
        draw_text(
            tooltip_x + 8,
            tooltip_y + 8,
            item.name + "\n" + item.description
        );
    }
}

// Reset draw settings
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white);
draw_set_alpha(1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Step_0.gml
/// @description Handle inventory interaction

// Skip if game is paused or menu is not open
if (global.game_state.flags.is_paused || !instance_exists(obj_menu_manager) || 
    obj_menu_manager.current_menu != MENU_STATE.INVENTORY) exit;

// Get mouse position relative to GUI
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);

// Toggle inventory open/closed state
if (keyboard_check_pressed(ord("I"))) {
    toggle_inventory();
}

// Only handle interactions if inventory is open
if (global.inventory_open_state == "open") {
    // Calculate slot under mouse
    var slot_x = floor((gui_mouse_x - inventory_x) / (slot_size + slot_padding));
    var slot_y = floor((gui_mouse_y - inventory_y) / (slot_size + slot_padding));
    
    // Update hover slot
    if (point_in_rectangle(gui_mouse_x, gui_mouse_y, 
        inventory_x, inventory_y,
        inventory_x + inventory_width * (slot_size + slot_padding),
        inventory_y + inventory_height * (slot_size + slot_padding)) &&
        slot_x >= 0 && slot_x < inventory_width &&
        slot_y >= 0 && slot_y < inventory_height) {
        hover_slot = slot_x + slot_y * inventory_width;
    } else {
        hover_slot = -1;
    }
    
    // Handle mouse input
    if (mouse_check_button_pressed(mb_left)) {
        if (hover_slot != -1) {
            // Start dragging
            if (items[# slot_x, slot_y].name != "") {
                drag_slot = hover_slot;
                selected_slot = hover_slot;
                drag_offset_x = gui_mouse_x - (inventory_x + slot_x * (slot_size + slot_padding));
                drag_offset_y = gui_mouse_y - (inventory_y + slot_y * (slot_size + slot_padding));
            }
        }
    } else if (mouse_check_button_released(mb_left)) {
        if (drag_slot != -1) {
            if (hover_slot != -1 && hover_slot != drag_slot) {
                // Swap items
                var drag_x = drag_slot mod inventory_width;
                var drag_y = drag_slot div inventory_width;
                var temp = items[# slot_x, slot_y];
                items[# slot_x, slot_y] = items[# drag_x, drag_y];
                items[# drag_x, drag_y] = temp;
            }
            drag_slot = -1;
        }
    }
    
    // Handle keyboard shortcuts
    for (var i = 0; i < min(10, inventory_width * inventory_height); i++) {
        if (keyboard_check_pressed(ord(string(i == 9 ? 0 : i + 1)))) {
            selected_slot = i;
            var slot_x = i mod inventory_width;
            var slot_y = i div inventory_width;
            var item = items[# slot_x, slot_y];
            
            if (item.name != "") {
                // Use or equip item
                if (item.wearable) {
                    var currently_equipped = ds_map_find_value(equipped_items, item.type);
                    if (currently_equipped == item.name) {
                        // Unequip
                        ds_map_delete(equipped_items, item.type);
                    } else {
                        // Equip
                        ds_map_set(equipped_items, item.type, item.name);
                    }
                } else {
                    // Use consumable item
                    use_item(item.name);
                }
            }
        }
    }
}

// Update game state
with(global.game_state) {
    update_inventory_data({
        items: other.items,
        equipped_items: other.equipped_items,
        max_items: other.max_items,
        coins: other.coins
    });
}

// Debug mode
if (global.game_state.flags.debug_mode && keyboard_check_pressed(vk_f7)) {
    show_debug_message("Selected slot: " + string(selected_slot));
    if (selected_slot != -1) {
        var slot_x = selected_slot mod inventory_width;
        var slot_y = selected_slot div inventory_width;
        var item = items[# slot_x, slot_y];
        show_debug_message("Item: " + item.name + " (Count: " + string(item.count) + ")");
    }
}

// obj_inventory: Step Event
if (global.chat_active) exit;
// Existing logic (scroll, drop, Tube, Party Hat, Beta Hat)
if (mouse_wheel_up()) {
    active_slot = min(active_slot + 1, 7);
    global.active_item_index = inventory[active_slot];
}
if (mouse_wheel_down()) {
    active_slot = max(active_slot - 1, 0);
    global.active_item_index = inventory[active_slot];
}
if (keyboard_check_pressed(ord("F"))) {
    drop_active_item();
}

// Remove the used item from inventory
if (keyboard_check_pressed(ord("R")) && global.repair_complete) { 
    show_debug_message("DEBUG: Repair complete flag detected in inventory."); 
    if (has_item("Battery")) {
        show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
        remove_item("Battery");
        show_debug_message("Battery removed after repair.");
    } else {
        show_debug_message("ERROR: Neither Battery nor Wrench found in inventory!");
    }
}

// Auto-remove Tube when switching to obj_player_tube
if (keyboard_check_pressed(ord("T")) && global.current_skin == "tube") {
    show_debug_message("Switching from tube to player");
    obj_controller.switch_skin("player");
    if (!has_item("Tube")) {
        add_to_inventory("Tube");
    }
    show_debug_message("Exited tube. Switched back to player. Tube added back to inventory.");
} else if (keyboard_check_pressed(ord("T")) && global.current_skin == "player" && has_item("Tube")) {
    show_debug_message("Switching from player to tube");
    obj_controller.switch_skin("tube");
    if (has_item("Tube")) {
        show_debug_message("Removing Tube from inventory...");
        remove_item("Tube");
    } else {
        show_debug_message("ERROR: Tube not found in inventory!");
    }
}

// Auto-remove Toboggan when switching to obj_player_toboggan
if (keyboard_check_pressed(ord("T")) && global.current_skin == "toboggan") {
    show_debug_message("Switching from toboggan to player");
    obj_controller.switch_skin("player");
    if (!has_item("Toboggan")) {
        add_to_inventory("Toboggan");
    }
    show_debug_message("Exited toboggan. Switched back to player. Toboggan added back to inventory.");
} else if (keyboard_check_pressed(ord("T")) && global.current_skin == "player" && has_item("Toboggan")) {
    show_debug_message("Switching from player to tube");
    obj_controller.switch_skin("toboggan");
    if (has_item("Toboggan")) {
        show_debug_message("Removing Toboggan from inventory...");
        remove_item("Toboggan");
    } else {
        show_debug_message("ERROR: Toboggan not found in inventory!");
    }
}

// Toggle Party Hat when pressing "P"
if (keyboard_check_pressed(ord("P"))) {
    var item_index = inventory[active_slot];
    if (item_index != -1) {
        var item_type = ds_map_find_value(global.item_type_map, item_index);
	if (!is_undefined(item_type) && ds_map_exists(global.equipped_items, item_type)) {
	    var equipped_item = global.equipped_items[? item_type];
	    if (equipped_item != -1) {
	        // Swap back to inventory
	        var empty_slot = array_find_index(inventory, function(val) { return val == -1; });
	        if (empty_slot != -1) {
	            inventory[empty_slot] = equipped_item;
	        } else {
	            show_debug_message("Inventory full, cannot swap out equipped item.");
	            exit;
	        }
	    }
	    // Equip new item
	    global.equipped_items[? item_type] = item_index;
	    inventory[active_slot] = -1;
	    show_debug_message("Equipped " + item_type + " item: " + string(item_index));
	} else {
	    show_debug_message("Cannot equip this item.");
	}
    } else {
        // Unequip logic (only unequip head if no item in active slot)
        var category = "head"; // Adjust if needed to support other categories
        if (global.equipped_items[? category] != -1) {
            var empty_slot = array_find_index(inventory, function(val) { return val == -1; });
            if (empty_slot != -1) {
                inventory[empty_slot] = global.equipped_items[? category];
                global.equipped_items[? category] = -1;
                show_debug_message("Unequipped " + category + " item to slot " + string(empty_slot));
            } else {
                show_debug_message("Inventory full, cannot unequip " + category + " item.");
            }
        } else {
            show_debug_message("No equipped item in " + category + " to unequip.");
        }
    }
}

// Depth setting for UI layering
depth = -1000;

// Function: Check if player has an item
function has_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) return false;
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) return true;
    }
    return false;
}

// Function: Add an item to the inventory
function add_to_inventory(item_name) {
    if (has_item(item_name)) {
        show_debug_message("WARNING: " + item_name + " is already in the inventory.");
        return false;
    }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == -1) { // Empty slot
            inventory[i] = item_index;
            show_debug_message("Added " + item_name + " to inventory in slot " + string(i));
            return true;
        }
    }
	
	// Notify quest system
for (var i = 0; i < ds_list_size(global.active_quests); i++) {
    var quest_id = ds_list_find_value(global.active_quests, i);
    var quest = ds_map_find_value(global.quest_definitions, quest_id);
    var objectives = quest[?"objectives"];
    for (var j = 0; j < array_length(objectives); j++) {
        if (objectives[j].type == "collect" && objectives[j].item == item_name) {
            // Progress updated when completing the quest
        }
    }
}

    show_debug_message("Inventory full!");
    return false;
}

// Function: Remove an item from the inventory
function remove_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            inventory[i] = -1;
            show_debug_message("Removed " + item_name + " from inventory slot " + string(i));
            return true;
        }
    }

    show_debug_message("ERROR: Item " + item_name + " not found in inventory!");
    return false;
}

// Function: Drop the active item
function drop_active_item() {
    var item_index = inventory[active_slot];
    if (item_index == -1) {
        show_debug_message("No item in active slot to drop.");
        return;
    }

    // Find the item name from the index
    var item_name = "";
    var keys = ds_map_keys_to_array(global.item_index_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (ds_map_find_value(global.item_index_map, keys[i]) == item_index) {
            item_name = keys[i];
            break;
        }
    }

    if (item_name != "") {
        // Get the corresponding object from item_object_map
        var dropped_object = ds_map_find_value(global.item_object_map, item_name);
        if (!is_undefined(dropped_object) && object_exists(dropped_object)) {
            // Create the specific object instance at the player's position
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", dropped_object);
            show_debug_message("Dropped " + item_name + " as " + object_get_name(dropped_object) + " at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
        } else {
            show_debug_message("ERROR: No valid object mapped for item " + item_name + ". Dropping as generic obj_dropped_item.");
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", obj_dropped_item);
            dropped_item.item_type = item_name; // Fallback to generic item
        }
    } else {
        show_debug_message("ERROR: Could not find item name for index " + string(item_index));
        return;
    }

    // Remove the item from the inventory
    inventory[active_slot] = -1;
    show_debug_message("Removed " + item_name + " from inventory slot " + string(active_slot));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Create_0.gml
// obj_inventory_expanded: Create Event
global.game_paused = true;
depth = -10000;

// Default inventory states
global.inventory_open_state = "closed"; // Inventory starts in the closed state
global.inventory_visible = true; // Both sprites are visible by default

// Character variables
character_face = DOWN; // Default direction
character_action = "none"; // Default no action
character_image_index = 0; // Default animation frame

// Add snowball action to available actions if not already present
if (!variable_global_exists("available_actions")) {
    global.available_actions = ["snowball", "wave", "dance", "sit"];
}
if (!variable_global_exists("selected_action")) {
    global.selected_action = "";
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Destroy_0.gml
// obj_inventory_expanded: Destroy Event
global.game_paused = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Draw_64.gml
//obj_inventory_expanded Draw GUI
var ui_scale = 2.2;

// GUI dimensions
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (gui_width / 2) - closed_width - 0; // Slightly shifted right
var closed_y = (gui_height - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35; // Overlaps slightly with the closed inventory
var open_y = (gui_height - open_height) / 2;

// Draw sprites based on inventory state
if (global.inventory_visible) {
    // Draw the closed inventory sprite
    draw_sprite_ext(spr_inventory_closed, 0, closed_x, closed_y, ui_scale, ui_scale, 0, c_white, 1);
    
    // Draw equipped items in clothing slots
    var clothing_slots = [
        [9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]
    ];
    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var slot_x = closed_x + clothing_slots[i][0] * ui_scale;
        var slot_y = closed_y + clothing_slots[i][1] * ui_scale;
		var item_index = global.equipped_items[? slots[i]]; // slots[i] being "head", etc.
		if (!is_undefined(item_index) && item_index != -1) {
		    var sprite = ds_map_find_value(global.item_player_sprites, item_index);
		    if (!is_undefined(sprite)) {
				draw_sprite_part_ext(sprite, 0, item_index * 18, 0, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
        }
    }
    
    // Character viewer positioning
    var viewer_x = closed_x + 29 * ui_scale; // Relative to closed inventory
    var viewer_y = closed_y + 40 * ui_scale;
    var viewer_width = 75 * ui_scale; // Width based on provided dimensions
    var viewer_height = 115 * ui_scale; // Height based on provided dimensions

	// Define drawing position and scale (adjust as needed)
	var draw_x = x + viewer_x; // Example: viewer_x = 50
	var draw_y = y + viewer_y; // Example: viewer_y = 50
	var char_scale = 7; // Scale for visibility

    // Default frame settings
	var frame_x = 0; // DOWN direction
	var frame_width = 24;
	var frame_height = 24;

	switch (global.current_skin) {
	    case "player":
	        // Draw walking pose for regular player
	        var frame_y = 0; // Walking pose from spr_player_body
	        draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
	        break;
    
	    case "tube":
	        // Draw sitting pose for tube
	        var frame_y = 72; // Sitting pose from spr_player_body
			draw_sprite_part_ext(spr_tube_sheet, 0, 24, 0, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
	        break;
			
		case "toboggan":
	        // Draw sitting pose for tube
	        var frame_y = 72; // Sitting pose from spr_player_body
			draw_sprite_part_ext(spr_toboggan_sheet, 0, 24, 0, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
	        break;	
    
	    case "icetruck":
	        // Draw icetruck with penguin inside (simplified preview)
	        frame_width = 48; // Icetruck sprite size
	        frame_height = 48;
	        var frame_y = 0; // DOWN direction frame
	        draw_sprite_part_ext(spr_icetruck_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, c_white, 1);
	        draw_sprite_part_ext(spr_icetruck_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, obj_player_icetruck.icetruck_tint, 1);
	        draw_sprite_part_ext(spr_icetruck_penguin_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 20, char_scale - 2, char_scale - 2, global.player_color, 1);
			draw_sprite_part_ext(spr_icetruck_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, c_white, 1);
	        break;
	}
    // Draw equipped items with slight offset for head items
    for (var i = 0; i < array_length(slots); i++) {
        var item_index = global.equipped_items[? slots[i]];
        if (item_index != -1) {
            var item_sprite = ds_map_find_value(global.item_player_sprites, item_index);
            if (!is_undefined(item_sprite)) {
                var offset_x = (slots[i] == "head") ? 2 * char_scale : 0; // Adjust head item to the right
                draw_sprite_part_ext(item_sprite, 0, frame_x, frame_y, frame_width, frame_height, draw_x + offset_x - 10, draw_y, char_scale, char_scale, c_white, 1);
            }
        }
    }

    if (global.inventory_open_state == "open") {
        // Draw the open inventory sprite
        draw_sprite_ext(spr_inventory_open, 0, open_x, open_y, ui_scale, ui_scale, 0, c_white, 1);

        // Draw inventory grid
        var grid_start = [3, 6];
        var grid_size = [7, 6];
        for (var row = 0; row < grid_size[1]; row++) {
            for (var col = 0; col < grid_size[0]; col++) {
                var slot_index = row * grid_size[0] + col;
                if (slot_index < 42 && obj_inventory.inventory[slot_index] != -1) {
                    var item_index = obj_inventory.inventory[slot_index];
                    draw_sprite_part_ext(
                        spr_inventory_items, 0,
                        item_index * 18, 0, 18, 18,
                        open_x + (grid_start[0] + col * 20) * ui_scale,
                        open_y + (grid_start[1] + row * 20) * ui_scale,
                        ui_scale, ui_scale, c_white, 1
                    );
                }
            }
        }
    }
}
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Step_0.gml
// obj_inventory_expanded: Step Event
var ui_scale = 2.2;
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (display_get_gui_width() / 2) - closed_width - 0;
var closed_y = (display_get_gui_height() - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35;
var open_y = closed_y;

if (global.inventory_visible) {
    if (global.inventory_open_state == "closed") {
        // Define "Open Expanded Inventory" button area
        var open_left = closed_x + 117 * ui_scale;
        var open_top = closed_y + 61 * ui_scale;
        var open_right = closed_x + 125 * ui_scale;
        var open_bottom = closed_y + 93 * ui_scale;

        if (mouse_check_button_pressed(mb_left) &&
            gui_mouse_x >= open_left && gui_mouse_x <= open_right &&
            gui_mouse_y >= open_top && gui_mouse_y <= open_bottom) {
            show_debug_message("DEBUG: Opening expanded inventory.");
            global.inventory_open_state = "open";
        }
    } else if (global.inventory_open_state == "open") {
        // Define "Close Expanded Inventory" button area
        var close_left = open_x + 144 * ui_scale;
        var close_top = open_y + 47 * ui_scale;
        var close_right = open_x + 152 * ui_scale;
        var close_bottom = open_y + 79 * ui_scale;

        if (mouse_check_button_pressed(mb_left) &&
            gui_mouse_x >= close_left && gui_mouse_x <= close_right) {
            show_debug_message("DEBUG: Closing expanded inventory.");
            global.inventory_open_state = "closed";
        }
    }

    // Define "Close All Expanded Inventory" button
    var close_all_left = closed_x + 47 * ui_scale;
    var close_all_top = closed_y + 3 * ui_scale;
    var close_all_right = closed_x + 89 * ui_scale;
    var close_all_bottom = closed_y + 11 * ui_scale;

    if (mouse_check_button_pressed(mb_left) &&
        gui_mouse_x >= close_all_left && gui_mouse_x <= close_all_right) {
        show_debug_message("DEBUG: Closing all inventory.");
        global.inventory_visible = false;
        global.inventory_open_state = "closed";
        global.game_paused = false; // Unpause the game
        instance_destroy();
        exit;
    }
}

// Close inventory with "I" key
if (keyboard_check_pressed(ord("I"))) {
    show_debug_message("DEBUG: Closing inventory with 'I'.");
    global.game_paused = false;
    instance_destroy();
}

// Special actions and animation logic (unchanged)
if (keyboard_check_pressed(ord("H"))) {
    character_action = "dance";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("J"))) {
    character_action = "wave";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("K"))) {
    character_action = "none";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("B")) && obj_inventory.has_item("Jackhammer")) {
    character_action = "jackhammer";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("N")) && obj_inventory.has_item("Snow Shovel")) {
    character_action = "snowshovel";
    character_image_index = 0;
}

// Animate the character
if (character_action != "none") {
    var anim_speed = ds_map_find_value(global.player_instance.action_anim_speed, character_action);
    character_image_index += anim_speed;
    var frames = ds_map_find_value(global.player_instance.action_frame_data, character_action);
    if (character_image_index >= array_length(frames)) character_image_index = 0;
} else {
    character_image_index += 0.15; // Idle animation speed
    if (character_image_index >= 3) character_image_index = 0;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_investigation_manager
File: Create_0.gml
/// @description Initialize Investigation System

// Make persistent
persistent = true;

// Initialize investigation system
investigation_areas = ds_map_create();
active_clues = ds_list_create();
discovered_clues = ds_map_create();

// Investigation states
enum InvestigationState {
    NONE,
    SEARCHING,
    FOUND_CLUE,
    ANALYZING
}

current_state = InvestigationState.NONE;
current_area = noone;
search_progress = 0;
search_time = 3 * room_speed; // 3 seconds to search an area

// Clue types
enum ClueType {
    NOTE,
    FOOTPRINT,
    MECHANICAL_PART,
    BOT_PART,
    ELECTRONIC_DEVICE
}

/// @function register_investigation_area(area_id, x, y, width, height)
function register_investigation_area(area_id, x, y, width, height) {
    investigation_areas[? area_id] = {
        x: x,
        y: y,
        width: width,
        height: height,
        searched: false,
        available_clues: ds_list_create(),
        found_clues: ds_list_create()
    };
}

/// @function add_clue_to_area(area_id, clue_type, clue_data)
function add_clue_to_area(area_id, clue_type, clue_data) {
    var area = investigation_areas[? area_id];
    if (area != undefined) {
        ds_list_add(area.available_clues, {
            type: clue_type,
            data: clue_data,
            found: false
        });
        return true;
    }
    return false;
}

/// @function start_investigation(area_id)
function start_investigation(area_id) {
    var area = investigation_areas[? area_id];
    if (area != undefined && !area.searched) {
        current_state = InvestigationState.SEARCHING;
        current_area = area_id;
        search_progress = 0;
        return true;
    }
    return false;
}

/// @function update_investigation()
function update_investigation() {
    if (current_state == InvestigationState.SEARCHING) {
        search_progress += 1;
        
        // Random chance to find clues during search
        if (random(1) < 0.1) { // 10% chance each step
            var area = investigation_areas[? current_area];
            var available_clues = area.available_clues;
            
            // Find an unfound clue
            for (var i = 0; i < ds_list_size(available_clues); i++) {
                var clue = available_clues[| i];
                if (!clue.found) {
                    clue.found = true;
                    ds_list_add(area.found_clues, clue);
                    current_state = InvestigationState.FOUND_CLUE;
                    
                    // Trigger quest update if applicable
                    with (obj_quest_manager) {
                        update_quest_objective("QUEST_MISSING_GUIDE", 1, 1);
                    }
                    
                    // Create visual effect
                    instance_create_layer(mouse_x, mouse_y, "Effects", obj_clue_sparkle);
                    break;
                }
            }
        }
        
        // Complete search when time is up
        if (search_progress >= search_time) {
            var area = investigation_areas[? current_area];
            area.searched = true;
            current_state = InvestigationState.NONE;
            current_area = noone;
            
            // Notify quest system of area completion
            with (obj_quest_manager) {
                update_quest_objective("QUEST_MISSING_GUIDE", 0, 1);
            }
        }
    }
}

/// @function cleanup_investigation()
function cleanup_investigation() {
    // Clean up data structures
    var keys = ds_map_keys_to_array(investigation_areas);
    for (var i = 0; i < array_length(keys); i++) {
        var area = investigation_areas[? keys[i]];
        ds_list_destroy(area.available_clues);
        ds_list_destroy(area.found_clues);
    }
    ds_map_destroy(investigation_areas);
    ds_list_destroy(active_clues);
    ds_map_destroy(discovered_clues);
}

// Register cleanup handler
array_push(global.game_state.cleanup_handlers, cleanup_investigation); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_Jackhammer_item
File: Create_0.gml
event_inherited();
item_name = "Jackhammer";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lamp
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_long_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lrg_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_menu
File: Create_0.gml
if (!instance_exists(obj_new_game_button)) {
    instance_create_layer(room_width / 2, room_height / 2, "Instances", obj_new_game_button);
}
if (!instance_exists(obj_continue_button) && file_exists("savegame.sav")) {
    instance_create_layer(room_width / 2, room_height / 2 + 40, "Instances", obj_continue_button);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_menu
File: Step_0.gml
if (room == rm_main_menu) {
    if (!instance_exists(obj_new_game_button)) {
        instance_create_layer(room_width / 2, room_height / 2, "Instances", obj_new_game_button);
    }
    if (!instance_exists(obj_continue_button)) {
        if (file_exists("savegame.sav")) {
            instance_create_layer(room_width / 2, room_height / 2 + 40, "Instances", obj_continue_button);
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Create_0.gml
// obj_pause_menu create event
depth = -99990; // Ensure it's drawn above all other objects

// Disable player controls
global.player_controls_enabled = false;

width = display_get_width();
height = display_get_height();
op_border = 8;
op_space = 16;
pos = 0;

// Settings menu options
option[0, 0] = "Window Size";
option[0, 1] = "Brightness";
option[0, 2] = "Controls";
option[0, 3] = "Back";

menu_level = 0;
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid initial menu_level " + string(menu_level));
    menu_level = 0; // Reset to default
}
op_length = array_length(option[menu_level]); // Dynamically set op_length

// Pause the game
game_paused = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Draw_0.gml
draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid menu_level " + string(menu_level));
    return; // Exit the Draw Event
}

// Dynamically get width and height of menu
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check that index is within bounds
        var _op_w = string_width(option[menu_level][i]);
        _new_w = max(_new_w, _op_w);
    }
}
width = _new_w + op_border * 2;
height = op_border * 4.5 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    0, 
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw the options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check bounds again
        var _c = c_white;
        if (pos == i) { 
            _c = c_yellow; // Highlight the option being hovered over
        }
        draw_text_color(
            x + width / 2, 
            y + op_border + op_space * i, 
            option[menu_level][i], // Access using nested arrays
            _c, 
            _c, 
            _c, 
            _c, 
            1
        );
    } else {
        show_debug_message("ERROR: Invalid option index " + string(i) + " for menu_level " + string(menu_level));
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Step_0.gml
// Update op_length dynamically based on menu_level
op_length = array_length(option[menu_level]);

// Menu navigation using the mouse
var mouse_x_pos = device_mouse_x(0); // Get mouse x-coordinate
var mouse_y_pos = device_mouse_y(0); // Get mouse y-coordinate

var menu_width = 300; // Width of the menu
var menu_height = 40 * op_length + 20; // Height of the menu
var menu_top = y - menu_height / 2 + 20; // Top of the menu options
var menu_left = x - menu_width / 2; // Left of the menu

if (mouse_x_pos > menu_left && mouse_x_pos < menu_left + menu_width) {
    pos = floor((mouse_y_pos - menu_top) / 40); // Calculate option index
} else {
    pos = -1; // Mouse is not over the menu
}

// Ensure pos stays within bounds
if (pos < 0 || pos >= op_length) {
    pos = -1;
}

// Handle selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main settings menu
             switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
				case 3:	
					room_goto(rm_main_menu);
					break;
            }
            break;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Create_0.gml
// obj_map Create Event
depth = -9998; // Ensure it's drawn above all other objects

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Draw_0.gml
// obj_map Draw Event
draw_self(); // Draw the full map sprite

// Draw markers or labels for clickable regions (halved size)
draw_set_color(c_red);
draw_rectangle(185 - 25, 228 - 25, 185 + 25, 228 + 25, false); // Town
draw_rectangle(55 - 25, 190 - 25, 55 + 25, 190 + 25, false); // Beach
draw_rectangle(155 - 25, 128 - 25, 155 + 25, 128 + 25, false); // Ski village
draw_rectangle(280 - 25, 250 - 25, 280 + 25, 250 + 25, false); // Snow fort
draw_rectangle(410 - 25, 277 - 25, 410 + 25, 277 + 25, false); // Welcome room
draw_rectangle(380 - 25, 230 - 25, 380 + 25, 230 + 25, false); // Plaza
draw_rectangle(395 - 25, 170 - 25, 395 + 25, 170 + 25, false); // Forest
draw_rectangle(400 - 25, 130 - 25, 400 + 25, 130 + 25, false); // Cove
draw_rectangle(135 - 25, 60 - 25, 135 + 25, 60 + 25, false); // Mountain top

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_27.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

camera_set_view_size(global.camera, global.camera_width, global.camera_height); // Restore original camera view size
instance_destroy(id);
show_debug_message("Map closed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_77.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use

    // Ensure the player instance is recreated when switching back
    room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_4.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

// obj_map Mouse Left Pressed Event
var click_x = device_mouse_x_to_gui(0);
var click_y = device_mouse_y_to_gui(0);

show_debug_message("Mouse clicked at: " + string(click_x) + ", " + string(click_y));

// Define clickable regions for different rooms (halved size)
if (click_x > 87 - 25 && click_x < 87 + 25 && click_y > 283 - 25 && click_y < 283 + 25) {
    // Move to Beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 185 - 25 && click_x < 185 + 25 && click_y > 228 - 25 && click_y < 228 + 25) {
    // Move to town
    show_debug_message("Town region clicked");
    room_goto(rm_town);
} else if (click_x > 55 - 25 && click_x < 55 + 25 && click_y > 190 - 25 && click_y < 190 + 25) {
    // Move to beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 155 - 25 && click_x < 155 + 25 && click_y > 128 - 25 && click_y < 128 + 25) {
    // Move to ski village
    show_debug_message("Ski village region clicked");
    room_goto(rm_ski_village);
} else if (click_x > 280 - 25 && click_x < 280 + 25 && click_y > 250 - 25 && click_y < 250 + 25) {
    // Move to snow fort
    show_debug_message("Snow fort region clicked");
    room_goto(rm_snow_fort);
} else if (click_x > 410 - 25 && click_x < 410 + 25 && click_y > 277 - 25 && click_y < 277 + 25) {
    // Move to welcome room
    show_debug_message("Welcome room region clicked");
    room_goto(rm_welcome_room);
} else if (click_x > 380 - 25 && click_x < 380 + 25 && click_y > 230 - 25 && click_y < 230 + 25) {
    // Move to plaza
    show_debug_message("Plaza region clicked");
    room_goto(rm_plaza);
} else if (click_x > 395 - 25 && click_x < 395 + 25 && click_y > 170 - 25 && click_y < 170 + 25) {
    // Move to forest
    show_debug_message("Forest region clicked");
    room_goto(rm_forest);
} else if (click_x > 400 - 25 && click_x < 400 + 25 && click_y > 130 - 25 && click_y < 130 + 25) {
    // Move to cove
    show_debug_message("Cove region clicked");
    room_goto(rm_cove);
} else if (click_x > 135 - 25 && click_x < 135 + 25 && click_y > 60 - 25 && click_y < 60 + 25) {
    // Move to mountain top
    show_debug_message("Mountain top region clicked");
    room_goto(rm_ski_mountaintop);
} else {
    show_debug_message("No region matched. Click ignored.");
}

function create_warp_instance(target_room) {
    // Create a warp instance at the correct position
    var inst = instance_create_depth(0, 0, -9999, obj_warp);

    // Ensure the player warps to a valid position
    if (instance_exists(global.player_instance)) {
        inst.target_x = global.player_instance.x;
        inst.target_y = global.player_instance.y;
    } else {
        inst.target_x = 320; // Default center of the room (fallback)
        inst.target_y = 240;
    }

    inst.target_rm = target_room;
    inst.target_face = 0; // Set default direction
    inst.target_instance = global.player_instance;

    show_debug_message("DEBUG: Creating warp to " + string(target_room) + 
        " at (" + string(inst.target_x) + ", " + string(inst.target_y) + ")");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_5.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use
	room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Draw_64.gml
/// Draw GUI Event for obj_map_icon
draw_sprite_ext(
    sprite_index, image_index,
    10, display_get_height() - sprite_height - 10, // Fixed GUI position
    1, 1, 0, c_white, 1
);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Mouse_4.gml
if (room != rm_map) {
    if (instance_exists(global.player_instance)) {
        global.player_x = global.player_instance.x;
        global.player_y = global.player_instance.y;

        show_debug_message("DEBUG: Stored player position: (" + string(global.player_x) + ", " + string(global.player_y) + ")");
        
        // Hide the player instead of destroying
        global.player_instance.visible = false;
    } else {
        show_debug_message("WARNING: No player instance found before switching rooms! Using default coordinates.");
        
        // Set default safe position
        global.player_x = 170;
        global.player_y = 154;
    }

    show_debug_message("Switching to map room...");
    global.last_room = room;
    room_goto(rm_map);
}
else if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    room_goto(global.last_room);

}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Step_0.gml
//Step event
if (global.chat_active) exit;
depth = -1000;

// Position map icon in the corner of the screen
x = camera_get_view_x(global.camera);
y = camera_get_view_y(global.camera) + camera_get_view_height(global.camera) - sprite_height;

// Check if the mouse is hovering over the icon
if (position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1; // Change to highlighted sprite
} else {
    image_index = 0; // Revert to normal sprite
}

// Hide player instead of destroying in UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_sled_racing || room == rm_pause_menu || room == rm_settings_menu);

if (is_ui_room) {
    if (instance_exists(obj_map_icon)) {
        obj_map_icon.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (instance_exists(obj_map_icon)) {
       obj_map_icon.visible = true;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_item
File: Create_0.gml
event_inherited();
item_name = "Map";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Create_0.gml
offset_y = 0;
scroll_distance = sprite_get_height(spr_main_menu) - room_height;
move_speed = 2;
animation_complete = false;
button_alpha = 0;
fade_speed = 0.02;
button_ids = [];
delay_timer = 120;
jetpack_y = 80;
puffle_y = 80;
jetpack_frame_speed = 0.5;
puffle_frame_speed = 0.5;
jetpack_image_index = 0;
puffle_image_index = 0;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Draw_0.gml
// Draw main menu sprite
draw_sprite(spr_main_menu, 0, 0, offset_y);
draw_sprite_ext(spr_menu_puffle, floor(puffle_image_index), 120, puffle_y, 1, 1, 0, c_white, 1);
draw_sprite_ext(spr_menu_jetpackguy, floor(jetpack_image_index), 60, jetpack_y, 1, 1, 0, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Other_4.gml
button_ids = [];
var num_buttons = instance_number(obj_menu_button);
for (var i = 0; i < num_buttons; i++) {
    var btn = instance_find(obj_menu_button, i);
    if (btn != noone) {
        button_ids[i] = btn;
    }
}
show_debug_message("Number of buttons found: " + string(array_length(button_ids)));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_animation
File: Step_0.gml
// Existing logic for delay and scrolling
if (delay_timer > 0) {
    delay_timer -= 1;  // Countdown the delay timer
} else if (!animation_complete) {
    offset_y -= move_speed;  // Start scrolling after delay
    if (offset_y <= -scroll_distance) {
        offset_y = -scroll_distance;
        animation_complete = true;
    }
} else {
    if (button_alpha < 1) {
        button_alpha += fade_speed;  // Fade in buttons after animation
        if (button_alpha > 1) button_alpha = 1;
        
        for (var i = 0; i < array_length(button_ids); i++) {
            var btn_id = button_ids[i];
            if (instance_exists(btn_id)) {
                with (btn_id) {
                    image_alpha = other.button_alpha;
                }
            }
        }
    }
}

// Jetpack Guy Movement Logic
if (!animation_complete) {
    // Move `spr_menu_jetpackguy` upward as `offset_y` decreases
    jetpack_y = 80 - (offset_y * -1);
}

// Puffle Movement Logic
if (!animation_complete) {
    // Move `spr_menu_puffle` upward as `offset_y` decreases
    puffle_y = 80 - (offset_y * -1);
}

// Jetpack Guy Animation Logic
jetpack_image_index += jetpack_frame_speed;
if (jetpack_image_index >= sprite_get_number(spr_menu_jetpackguy)) {
    jetpack_image_index = 0;
}

// Puffle Animation Logic
puffle_image_index += puffle_frame_speed;
if (puffle_image_index >= sprite_get_number(spr_menu_puffle)) {
    puffle_image_index = 0;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Create_0.gml
// Create Event in obj_menu_button
btn_action = "";             // Action to perform (set via creation code)
btn_text = "";               // Text to display (set via creation code)
btn_font = fnt_bonkfatty;    // Font for button text
text_color = c_black;        // Text color
image_speed = 0;             // Prevent automatic frame switching
image_index = 0;             // Start on frame 0 (normal state)

// Set initial alpha based on room
if (room == rm_main_menu) {
    image_alpha = 0;         // Start invisible for fade-in
} else {
    image_alpha = 1;         // Visible in other rooms
}

// Show "Continue" button only if save file exists
if (btn_action == "continue") {
    visible = file_exists("savegame.sav");
} else {
    visible = true;          // Other buttons are visible by default
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Draw_0.gml
if (mouse_check_button(mb_left) && position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1;  // Show frame 1 when clicked
} else {
    image_index = 0;  // Revert to frame 0 when not clicked
}
draw_self();

// Set alpha for text to match button
draw_set_alpha(image_alpha);

// Set text alignment
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Calculate text position
var text_x = x + sprite_width / 2;
var text_y = y + sprite_height / 2;

// Draw the button text
draw_set_color(text_color);
draw_set_font(btn_font);
draw_text_ext(text_x, text_y, btn_text, -1, sprite_width - 100);

// Reset alpha and alignment
draw_set_alpha(1);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_10.gml
hover = true;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_11.gml
hover = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_4.gml
// Left Pressed Event in obj_menu_button
if (btn_action == "new_game") {
    room_goto(rm_colorpicker_menu);  // Go to color picker for new game
} else if (btn_action == "continue") {
    load_game();                  // Call the load_game function to resume saved game
} else if (btn_action == "play") {
    room_goto(rm_init);           // Existing action for play
} else if (btn_action == "start") {
    room_goto(rm_saveload);  // Redirect to rm_saveload instead of rm_colour_picker
} else if (btn_action == "settings") {
    room_goto(rm_settings_menu);  // Existing action for settings
} else if (btn_action == "exit") {
    game_end();                   // Existing action for exit
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Create_0.gml
global.menu_state = "none"; // Possible values: "none", "puffle_menu", "name_puffle"
global.selected_puffle = noone;
global.menu_index = 0; // Selected option
name = "";
owner = noone;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Draw_64.gml
if (global.menu_state == "puffle_menu") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false); // Menu background
    draw_set_color(c_white);
    draw_text(150, 120, "Adopt");
    draw_text(150, 140, "Cancel");
    draw_text(130, 120 + global.menu_index * 20, ">"); // Cursor
}

if (global.menu_state == "name_puffle") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false);
    draw_set_color(c_white);
    draw_text(150, 140, "Press Enter to name your puffle");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Step_0.gml
if (global.menu_state == "puffle_menu") {
    // Menu options
    var options = ["Adopt", "Cancel"];
    var choice = -1;
    
    // Simple keyboard navigation (expand for mouse if needed)
    if (keyboard_check_pressed(vk_down)) global.menu_index = min(global.menu_index + 1, 1);
    if (keyboard_check_pressed(vk_up)) global.menu_index = max(global.menu_index - 1, 0);
    if (keyboard_check_pressed(vk_enter)) choice = global.menu_index;
    
    // Handle choice
    if (choice == 0) { // Adopt
        global.menu_state = "name_puffle";
        global.menu_index = 0; // Reset for next menu
    } else if (choice == 1) { // Cancel
        global.menu_state = "none";
        global.selected_puffle = noone;
    }
}

if (global.menu_state == "name_puffle") {
    if (keyboard_check_pressed(vk_enter)) {
        var puffle_name = get_string("Enter a name for your puffle:", "Puffle");
        if (puffle_name != "") {
            with (global.selected_puffle) {
                name = puffle_name;
                owner = obj_player; // Mark as adopted
            }
            obj_player.puffle_os -= 1; // Consume one Puffle-O
            global.menu_state = "none";
            global.selected_puffle = noone;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_manager
File: CleanUp_0.gml
/// @description Clean up surfaces

if (surface_exists(surf)) {
    surface_free(surf);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_manager
File: Create_0.gml
/// @description Initialize menu manager

// Menu states
enum MENU_STATE {
    NONE,
    PAUSE,
    INVENTORY,
    QUEST,
    CONFIG
}

// Initialize variables
current_menu = MENU_STATE.NONE;
previous_menu = MENU_STATE.NONE;
blur_amount = 0;
target_blur = 0;
blur_speed = 0.1;
menu_alpha = 0;
menu_target_alpha = 0;

// Create surface for blur effect
surf = -1;
surf_width = display_get_gui_width();
surf_height = display_get_gui_height();

// Initialize shader uniforms
blur_uniform = shader_get_uniform(shd_gaussian_blur, "blur_amount");
texel_uniform = shader_get_uniform(shd_gaussian_blur, "texel_size");

// Menu transition variables
transition_speed = 0.1;
menu_y = display_get_gui_height();
menu_target_y = display_get_gui_height();

// Make persistent
persistent = true;

/// Function to open a menu
function open_menu(_menu_state) {
    if (current_menu == _menu_state) return;
    
    previous_menu = current_menu;
    current_menu = _menu_state;
    
    if (_menu_state != MENU_STATE.NONE) {
        target_blur = 2.0;
        menu_target_alpha = 0.5;
        menu_target_y = 0;
    }
}

/// Function to close current menu
function close_menu() {
    if (current_menu == MENU_STATE.NONE) return;
    
    previous_menu = current_menu;
    current_menu = MENU_STATE.NONE;
    target_blur = 0;
    menu_target_alpha = 0;
    menu_target_y = display_get_gui_height();
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_manager
File: Draw_64.gml
/// @description Draw menus with blur effect

// Create surface if it doesn't exist
if (!surface_exists(surf)) {
    surf = surface_create(surf_width, surf_height);
}

// Only draw if we have a menu open
if (current_menu != MENU_STATE.NONE) {
    // Copy screen to surface
    surface_set_target(surf);
    draw_surface(application_surface, 0, 0);
    surface_reset_target();
    
    // Apply blur shader
    shader_set(shd_gaussian_blur);
    shader_set_uniform_f(blur_uniform, blur_amount);
    shader_set_uniform_f(texel_uniform, 1.0/surf_width, 1.0/surf_height);
    
    // Draw blurred background
    draw_surface(surf, 0, 0);
    shader_reset();
    
    // Draw semi-transparent overlay
    draw_set_alpha(menu_alpha);
    draw_set_color(c_black);
    draw_rectangle(0, 0, surf_width, surf_height, false);
    draw_set_alpha(1);
    
    // Draw appropriate menu based on state
    switch(current_menu) {
        case MENU_STATE.PAUSE:
            draw_pause_menu();
            break;
            
        case MENU_STATE.INVENTORY:
            draw_inventory_menu();
            break;
            
        case MENU_STATE.QUEST:
            draw_quest_menu();
            break;
            
        case MENU_STATE.CONFIG:
            draw_config_menu();
            break;
    }
}

// Menu drawing functions
function draw_pause_menu() {
    var center_x = display_get_gui_width() / 2;
    var start_y = menu_y + 100;
    var spacing = 40;
    
    draw_set_font(fnt_menu);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    
    draw_set_color(c_white);
    draw_text(center_x, start_y, "PAUSED");
    
    draw_set_color(c_ltgray);
    draw_text(center_x, start_y + spacing, "Resume (ESC)");
    draw_text(center_x, start_y + spacing * 2, "Settings");
    draw_text(center_x, start_y + spacing * 3, "Exit to Menu");
}

function draw_inventory_menu() {
    var ui_scale = 2.2;
    var gui_width = display_get_gui_width();
    var gui_height = display_get_gui_height();
    
    // Closed inventory positioning
    var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
    var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
    var closed_x = (gui_width / 2) - closed_width - 0;
    var closed_y = menu_y + (gui_height - closed_height) / 4;
    
    // Draw the closed inventory sprite
    draw_sprite_ext(spr_inventory_closed, 0, closed_x, closed_y, ui_scale, ui_scale, 0, c_white, 1);
    
    // Draw equipped items in clothing slots
    var clothing_slots = [
        [9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]
    ];
    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    
    for (var i = 0; i < array_length(slots); i++) {
        var slot_x = closed_x + clothing_slots[i][0] * ui_scale;
        var slot_y = closed_y + clothing_slots[i][1] * ui_scale;
        var item_index = global.equipped_items[? slots[i]];
        if (!is_undefined(item_index) && item_index != -1) {
            var sprite = ds_map_find_value(global.item_player_sprites, item_index);
            if (!is_undefined(sprite)) {
                draw_sprite_part_ext(sprite, 0, item_index * 18, 0, 18, 18, 
                    slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
            }
        }
    }
    
    // Character viewer positioning
    var viewer_x = closed_x + 29 * ui_scale;
    var viewer_y = closed_y + 40 * ui_scale;
    var char_scale = 7;
    
    // Draw character preview
    var frame_x = 0;
    var frame_width = 24;
    var frame_height = 24;
    var draw_x = viewer_x;
    var draw_y = viewer_y;
    
    // Draw character base
    draw_sprite_part_ext(spr_player_base, 0, frame_x, 0, frame_width, frame_height,
        draw_x, draw_y, char_scale, char_scale, c_white, 1);
        
    // Draw character color
    draw_sprite_part_ext(spr_player_colour, 0, frame_x, 0, frame_width, frame_height,
        draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
    
    // Draw equipped items
    for (var i = 0; i < array_length(slots); i++) {
        var item_index = global.equipped_items[? slots[i]];
        if (item_index != -1) {
            var item_sprite = ds_map_find_value(global.item_player_sprites, item_index);
            if (!is_undefined(item_sprite)) {
                var offset_x = (slots[i] == "head") ? 2 * char_scale : 0;
                draw_sprite_part_ext(item_sprite, 0, frame_x, 0, frame_width, frame_height,
                    draw_x + offset_x, draw_y, char_scale, char_scale, c_white, 1);
            }
        }
    }
    
    // Draw inventory grid if expanded
    if (global.inventory_open_state == "open") {
        var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
        var open_x = closed_x + closed_width - 35;
        var open_y = closed_y;
        
        draw_sprite_ext(spr_inventory_open, 0, open_x, open_y, ui_scale, ui_scale, 0, c_white, 1);
        
        var grid_start = [3, 6];
        var grid_size = [7, 6];
        for (var row = 0; row < grid_size[1]; row++) {
            for (var col = 0; col < grid_size[0]; col++) {
                var slot_index = row * grid_size[0] + col;
                if (slot_index < 42 && obj_inventory.inventory[slot_index] != -1) {
                    var item_index = obj_inventory.inventory[slot_index];
                    draw_sprite_part_ext(
                        spr_inventory_items, 0,
                        item_index * 18, 0, 18, 18,
                        open_x + (grid_start[0] + col * 20) * ui_scale,
                        open_y + (grid_start[1] + row * 20) * ui_scale,
                        ui_scale, ui_scale, c_white, 1
                    );
                }
            }
        }
    }
}

function draw_quest_menu() {
    var center_x = display_get_gui_width() / 2;
    var start_y = menu_y + 50;
    
    draw_set_font(fnt_menu);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    
    draw_set_color(c_white);
    draw_text(center_x, start_y, "QUEST LOG");
    
    // Draw quest list here
    // ... (your existing quest drawing code)
}

function draw_config_menu() {
    var center_x = display_get_gui_width() / 2;
    var start_y = menu_y + 50;
    
    draw_set_font(fnt_menu);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    
    draw_set_color(c_white);
    draw_text(center_x, start_y, "SETTINGS");
    
    // Draw settings options here
    // ... (your settings menu code)
}

// Clean up
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white);
draw_set_alpha(1); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_manager
File: Step_0.gml
/// @description Handle menu transitions and input

// Handle menu transitions
blur_amount = lerp(blur_amount, target_blur, blur_speed);
menu_alpha = lerp(menu_alpha, menu_target_alpha, transition_speed);
menu_y = lerp(menu_y, menu_target_y, transition_speed);

// Handle input for different menus
if (keyboard_check_pressed(vk_escape)) {
    if (current_menu == MENU_STATE.NONE) {
        open_menu(MENU_STATE.PAUSE);
    } else {
        close_menu();
    }
}

if (keyboard_check_pressed(ord("I"))) {
    if (current_menu == MENU_STATE.INVENTORY) {
        close_menu();
    } else {
        open_menu(MENU_STATE.INVENTORY);
    }
}

if (keyboard_check_pressed(ord("Q"))) {
    if (current_menu == MENU_STATE.QUEST) {
        close_menu();
    } else {
        open_menu(MENU_STATE.QUEST);
    }
}

// Update surface size if window is resized
if (surf_width != display_get_gui_width() || surf_height != display_get_gui_height()) {
    surf_width = display_get_gui_width();
    surf_height = display_get_gui_height();
    if (surface_exists(surf)) {
        surface_free(surf);
    }
    surf = -1;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_multiplayer_hud
File: Create_0.gml
/// @description Initialize multiplayer HUD

// Chat system
chat = {
    messages: ds_list_create(),
    max_messages: 50,
    display_time: room_speed * 10,
    fade_time: room_speed * 2,
    input_active: false,
    current_input: "",
    cursor_blink: 0,
    scroll_offset: 0,
    history: ds_list_create(),
    history_position: -1
};

// Network debug info
debug = {
    show_debug: false,
    fps_history: ds_list_create(),
    ping_history: ds_list_create(),
    history_length: 60,
    last_sync_time: current_time,
    packet_stats: {
        sent: 0,
        received: 0,
        lost: 0
    }
};

// Player list UI
player_list = {
    visible: false,
    scroll_offset: 0,
    hover_player: noone
};

// UI Configuration
ui_config = {
    chat_width: 400,
    chat_height: 200,
    chat_x: 10,
    chat_y: display_get_gui_height() - 220,
    chat_padding: 5,
    chat_font: fnt_chat,
    chat_colors: {
        background: make_color_rgb(0, 0, 0, 0.7),
        input: make_color_rgb(0, 0, 0, 0.9),
        text: c_white,
        system: c_yellow,
        error: c_red,
        timestamp: c_gray
    }
};

// Add chat message
function add_chat_message(text, sender = "", type = "normal") {
    var timestamp = current_time;
    var color = ui_config.chat_colors.text;
    
    switch(type) {
        case "system":
            color = ui_config.chat_colors.system;
            break;
        case "error":
            color = ui_config.chat_colors.error;
            break;
    }
    
    var message = {
        text: sender == "" ? text : sender + ": " + text,
        timestamp: timestamp,
        color: color,
        alpha: 1
    };
    
    ds_list_add(chat.messages, message);
    
    // Trim old messages
    while (ds_list_size(chat.messages) > chat.max_messages) {
        ds_list_delete(chat.messages, 0);
    }
    
    // Reset scroll to bottom
    chat.scroll_offset = 0;
}

// Send chat message
function send_chat_message(text) {
    if (text == "") return;
    
    // Add to history
    ds_list_add(chat.history, text);
    if (ds_list_size(chat.history) > 20) {
        ds_list_delete(chat.history, 0);
    }
    chat.history_position = -1;
    
    // Send via network
    global.network_manager.send_chat_message(text);
}

// Update debug stats
function update_debug_stats() {
    // Update FPS history
    ds_list_add(debug.fps_history, fps_real);
    if (ds_list_size(debug.fps_history) > debug.history_length) {
        ds_list_delete(debug.fps_history, 0);
    }
    
    // Update ping history
    ds_list_add(debug.ping_history, global.network_manager.ping);
    if (ds_list_size(debug.ping_history) > debug.history_length) {
        ds_list_delete(debug.ping_history, 0);
    }
}

// Clean up
function cleanup() {
    ds_list_destroy(chat.messages);
    ds_list_destroy(chat.history);
    ds_list_destroy(debug.fps_history);
    ds_list_destroy(debug.ping_history);
}

// Make persistent
persistent = true; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_multiplayer_hud
File: Draw_64.gml
/// @description Draw multiplayer HUD

// Set up drawing properties
draw_set_font(ui_config.chat_font);
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();

// Draw chat window
if (chat.input_active || ds_list_size(chat.messages) > 0) {
    // Draw chat background
    draw_set_alpha(0.7);
    draw_set_color(ui_config.chat_colors.background);
    draw_rectangle(
        ui_config.chat_x,
        ui_config.chat_y,
        ui_config.chat_x + ui_config.chat_width,
        ui_config.chat_y + ui_config.chat_height,
        false
    );
    
    // Draw messages
    draw_set_halign(fa_left);
    draw_set_valign(fa_bottom);
    var message_y = ui_config.chat_y + ui_config.chat_height - ui_config.chat_padding;
    var visible_messages = min(15, ds_list_size(chat.messages));
    
    for (var i = 0; i < visible_messages; i++) {
        var msg_idx = ds_list_size(chat.messages) - 1 - i - chat.scroll_offset;
        if (msg_idx < 0) break;
        
        var message = chat.messages[| msg_idx];
        draw_set_alpha(message.alpha);
        draw_set_color(message.color);
        draw_text_ext(
            ui_config.chat_x + ui_config.chat_padding,
            message_y - (i * 20),
            message.text,
            20,
            ui_config.chat_width - (ui_config.chat_padding * 2)
        );
    }
    
    // Draw input box if active
    if (chat.input_active) {
        draw_set_alpha(1);
        draw_set_color(ui_config.chat_colors.input);
        draw_rectangle(
            ui_config.chat_x,
            ui_config.chat_y + ui_config.chat_height,
            ui_config.chat_x + ui_config.chat_width,
            ui_config.chat_y + ui_config.chat_height + 25,
            false
        );
        
        draw_set_color(c_white);
        draw_text(
            ui_config.chat_x + ui_config.chat_padding,
            ui_config.chat_y + ui_config.chat_height + 12,
            chat.current_input + (chat.cursor_blink < room_speed/2 ? "|" : "")
        );
    }
}

// Draw player list if visible
if (player_list.visible) {
    var list_width = 200;
    var list_x = gui_width - list_width - 10;
    var list_y = 10;
    var entry_height = 25;
    
    // Draw background
    draw_set_alpha(0.8);
    draw_set_color(ui_config.chat_colors.background);
    draw_rectangle(list_x, list_y, list_x + list_width, list_y + 300, false);
    
    // Draw title
    draw_set_alpha(1);
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_text(list_x + list_width/2, list_y + 5, "Players Online");
    
    // Draw player entries
    draw_set_halign(fa_left);
    var y_offset = list_y + 30;
    
    var key = ds_map_find_first(global.network_manager.connected_players);
    while (key != undefined) {
        var player_data = global.network_manager.connected_players[? key];
        
        // Draw player entry background
        var entry_y = y_offset;
        if (point_in_rectangle(device_mouse_x_to_gui(0), device_mouse_y_to_gui(0),
            list_x, entry_y, list_x + list_width, entry_y + entry_height)) {
            draw_set_alpha(0.3);
            draw_set_color(c_white);
            draw_rectangle(list_x, entry_y, list_x + list_width, entry_y + entry_height, false);
            player_list.hover_player = player_data;
        }
        
        // Draw player name and status
        draw_set_alpha(1);
        draw_set_color(player_data.player_id == 1 ? c_yellow : c_white);
        draw_text(list_x + 5, entry_y + 5, player_data.name + (player_data.player_id == 1 ? " (Host)" : ""));
        
        y_offset += entry_height;
        key = ds_map_find_next(global.network_manager.connected_players, key);
    }
}

// Draw debug information if enabled
if (debug.show_debug) {
    var debug_x = 10;
    var debug_y = 10;
    var line_height = 20;
    
    draw_set_alpha(0.8);
    draw_set_color(c_black);
    draw_rectangle(debug_x, debug_y, debug_x + 300, debug_y + 200, false);
    
    draw_set_alpha(1);
    draw_set_color(c_white);
    draw_set_halign(fa_left);
    
    // Network status
    draw_text(debug_x + 5, debug_y + 5, "Network Status:");
    draw_text(debug_x + 5, debug_y + line_height, "State: " + string(global.network_manager.current_state));
    draw_text(debug_x + 5, debug_y + line_height * 2, "Ping: " + string(global.network_manager.ping) + "ms");
    draw_text(debug_x + 5, debug_y + line_height * 3, "Players: " + string(ds_map_size(global.network_manager.connected_players)));
    
    // Performance stats
    draw_text(debug_x + 5, debug_y + line_height * 4, "Performance:");
    draw_text(debug_x + 5, debug_y + line_height * 5, "FPS: " + string(fps_real));
    draw_text(debug_x + 5, debug_y + line_height * 6, "Instance Count: " + string(instance_count));
    
    // Packet stats
    draw_text(debug_x + 5, debug_y + line_height * 7, "Network Stats:");
    draw_text(debug_x + 5, debug_y + line_height * 8, "Sent: " + string(debug.packet_stats.sent));
    draw_text(debug_x + 5, debug_y + line_height * 9, "Received: " + string(debug.packet_stats.received));
    draw_text(debug_x + 5, debug_y + line_height * 10, "Lost: " + string(debug.packet_stats.lost));
    
    // Draw FPS graph
    var graph_x = debug_x + 5;
    var graph_y = debug_y + line_height * 11;
    var graph_width = 290;
    var graph_height = 50;
    
    draw_set_color(c_dkgray);
    draw_rectangle(graph_x, graph_y, graph_x + graph_width, graph_y + graph_height, true);
    
    if (ds_list_size(debug.fps_history) > 1) {
        draw_set_color(c_lime);
        for (var i = 1; i < ds_list_size(debug.fps_history); i++) {
            var x1 = graph_x + ((i-1) * graph_width / debug.history_length);
            var x2 = graph_x + (i * graph_width / debug.history_length);
            var y1 = graph_y + graph_height - (debug.fps_history[| i-1] * graph_height / room_speed);
            var y2 = graph_y + graph_height - (debug.fps_history[| i] * graph_height / room_speed);
            draw_line(x1, y1, x2, y2);
        }
    }
}

// Reset drawing properties
draw_set_alpha(1);
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_multiplayer_hud
File: Step_0.gml
/// @description Handle input and updates

// Update cursor blink
chat.cursor_blink = (chat.cursor_blink + 1) mod room_speed;

// Toggle debug display
if (keyboard_check_pressed(vk_f3)) {
    debug.show_debug = !debug.show_debug;
}

// Toggle player list
if (keyboard_check_pressed(vk_tab)) {
    player_list.visible = !player_list.visible;
}

// Handle chat input
if (keyboard_check_pressed(vk_enter)) {
    if (!chat.input_active) {
        chat.input_active = true;
        keyboard_string = "";
    } else {
        if (chat.current_input != "") {
            send_chat_message(chat.current_input);
            chat.current_input = "";
        }
        chat.input_active = false;
    }
}

// Handle chat history navigation
if (chat.input_active) {
    if (keyboard_check_pressed(vk_up) && ds_list_size(chat.history) > 0) {
        if (chat.history_position == -1) {
            chat.history_position = ds_list_size(chat.history) - 1;
        } else {
            chat.history_position = max(0, chat.history_position - 1);
        }
        chat.current_input = chat.history[| chat.history_position];
        keyboard_string = chat.current_input;
    }
    
    if (keyboard_check_pressed(vk_down) && chat.history_position != -1) {
        chat.history_position++;
        if (chat.history_position >= ds_list_size(chat.history)) {
            chat.history_position = -1;
            chat.current_input = "";
        } else {
            chat.current_input = chat.history[| chat.history_position];
        }
        keyboard_string = chat.current_input;
    }
    
    // Update current input
    if (keyboard_check_pressed(vk_escape)) {
        chat.input_active = false;
        chat.current_input = "";
    } else if (!keyboard_check_pressed(vk_up) && !keyboard_check_pressed(vk_down)) {
        chat.current_input = keyboard_string;
    }
}

// Update chat message fade
var current_time = current_time;
for (var i = 0; i < ds_list_size(chat.messages); i++) {
    var message = chat.messages[| i];
    var age = current_time - message.timestamp;
    
    if (age > chat.display_time) {
        if (age < chat.display_time + chat.fade_time) {
            message.alpha = 1 - (age - chat.display_time) / chat.fade_time;
        } else {
            message.alpha = 0;
        }
    }
}

// Update debug stats
if (debug.show_debug) {
    update_debug_stats();
    
    // Update sync status
    if (current_time - debug.last_sync_time > 1000) {
        debug.last_sync_time = current_time;
        with(global.network_manager) {
            send_sync_request();
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_multiplayer_menu
File: Create_0.gml
/// @description Initialize multiplayer menu

// Menu states
enum MULTIPLAYER_MENU_STATE {
    MAIN,
    HOST,
    JOIN,
    LOBBY,
    ERROR
}

// Menu configuration
menu_state = MULTIPLAYER_MENU_STATE.MAIN;
selected_option = 0;
error_message = "";
error_timer = 0;

// Input fields
input_ip = "127.0.0.1";
input_port = "7777";
input_name = "Player";
is_typing = false;
cursor_blink = 0;
active_input = "";

// Player list for lobby
player_list = ds_list_create();
refresh_timer = 0;
refresh_rate = 30; // Refresh player list every 30 frames

// Button dimensions
button_width = 200;
button_height = 40;
button_padding = 20;

// Colors
color_normal = c_white;
color_hover = c_yellow;
color_selected = c_lime;
color_error = c_red;

// Main menu options
main_options = ["Host Game", "Join Game", "Back"];

// Initialize network callbacks
network_success_callback = function() {
    menu_state = MULTIPLAYER_MENU_STATE.LOBBY;
    error_message = "";
}

network_error_callback = function(error) {
    menu_state = MULTIPLAYER_MENU_STATE.ERROR;
    error_message = error;
    error_timer = room_speed * 3; // Show error for 3 seconds
}

// Clean up
clean_up = function() {
    ds_list_destroy(player_list);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_multiplayer_menu
File: Draw_64.gml
/// @description Draw multiplayer menu GUI

// Set up drawing properties
draw_set_font(fnt_menu);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();
var start_y = gui_height * 0.3;

// Draw title
draw_set_color(c_white);
draw_text(gui_width/2, start_y - 60, "Penguin Isles Multiplayer");

// Draw menu based on state
switch(menu_state) {
    case MULTIPLAYER_MENU_STATE.MAIN:
        // Draw main options
        for (var i = 0; i < array_length(main_options); i++) {
            var y_pos = start_y + (i * (button_height + button_padding));
            var color = (i == selected_option) ? color_selected : color_normal;
            draw_set_color(color);
            draw_text(gui_width/2, y_pos, main_options[i]);
        }
        break;
        
    case MULTIPLAYER_MENU_STATE.HOST:
        // Draw host menu
        draw_set_color(c_white);
        draw_text(gui_width/2, start_y, "Host Game");
        
        // Port input
        draw_set_color(active_input == "port" ? color_selected : color_normal);
        var port_y = start_y + button_height + button_padding;
        draw_text(gui_width/2, port_y, "Port: " + input_port + (active_input == "port" && cursor_blink < room_speed/2 ? "|" : ""));
        
        // Instructions
        draw_set_color(c_gray);
        draw_text(gui_width/2, port_y + 60, "Press ENTER to host\nESC to go back");
        break;
        
    case MULTIPLAYER_MENU_STATE.JOIN:
        // Draw join menu
        draw_set_color(c_white);
        draw_text(gui_width/2, start_y, "Join Game");
        
        // IP input
        draw_set_color(active_input == "ip" ? color_selected : color_normal);
        var ip_y = start_y + button_height + button_padding;
        draw_text(gui_width/2, ip_y, "IP: " + input_ip + (active_input == "ip" && cursor_blink < room_speed/2 ? "|" : ""));
        
        // Port input
        draw_set_color(active_input == "port" ? color_selected : color_normal);
        var port_y = ip_y + button_height + button_padding;
        draw_text(gui_width/2, port_y, "Port: " + input_port + (active_input == "port" && cursor_blink < room_speed/2 ? "|" : ""));
        
        // Instructions
        draw_set_color(c_gray);
        draw_text(gui_width/2, port_y + 60, "TAB to switch fields\nENTER to join\nESC to go back");
        break;
        
    case MULTIPLAYER_MENU_STATE.LOBBY:
        // Draw lobby
        draw_set_color(c_white);
        draw_text(gui_width/2, start_y, "Game Lobby");
        
        // Draw player list
        var list_y = start_y + button_height + button_padding;
        for (var i = 0; i < ds_list_size(player_list); i++) {
            var player = player_list[| i];
            var player_y = list_y + (i * 30);
            draw_set_color(player.is_host ? c_yellow : c_white);
            draw_text(gui_width/2, player_y, player.name + (player.is_host ? " (Host)" : ""));
        }
        
        // Instructions
        draw_set_color(c_gray);
        var inst_y = list_y + max(ds_list_size(player_list) * 30 + 40, 100);
        if (global.network_manager.is_host) {
            draw_text(gui_width/2, inst_y, "Press ENTER to start game\nESC to cancel");
        } else {
            draw_text(gui_width/2, inst_y, "Waiting for host to start...\nESC to leave");
        }
        break;
        
    case MULTIPLAYER_MENU_STATE.ERROR:
        // Draw error message
        draw_set_color(color_error);
        draw_text(gui_width/2, gui_height/2, error_message);
        break;
}

// Reset drawing properties
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_multiplayer_menu
File: Step_0.gml
/// @description Handle menu interactions

// Handle error timer
if (error_timer > 0) {
    error_timer--;
    if (error_timer <= 0 && menu_state == MULTIPLAYER_MENU_STATE.ERROR) {
        menu_state = MULTIPLAYER_MENU_STATE.MAIN;
    }
}

// Update cursor blink
cursor_blink = (cursor_blink + 1) mod room_speed;

// Handle input based on menu state
switch(menu_state) {
    case MULTIPLAYER_MENU_STATE.MAIN:
        // Navigation
        if (!is_typing) {
            if (keyboard_check_pressed(vk_up)) {
                selected_option = max(0, selected_option - 1);
            }
            if (keyboard_check_pressed(vk_down)) {
                selected_option = min(array_length(main_options) - 1, selected_option + 1);
            }
            
            // Selection
            if (keyboard_check_pressed(vk_enter)) {
                switch(selected_option) {
                    case 0: // Host Game
                        menu_state = MULTIPLAYER_MENU_STATE.HOST;
                        selected_option = 0;
                        break;
                    case 1: // Join Game
                        menu_state = MULTIPLAYER_MENU_STATE.JOIN;
                        selected_option = 0;
                        break;
                    case 2: // Back
                        room_goto(rm_main_menu);
                        break;
                }
            }
        }
        break;
        
    case MULTIPLAYER_MENU_STATE.HOST:
        // Handle port input
        if (keyboard_check_pressed(vk_enter)) {
            var port = real(input_port);
            if (port >= 1024 && port <= 65535) {
                if (global.network_manager.host_game(port)) {
                    network_success_callback();
                } else {
                    network_error_callback(global.network_manager.error_message);
                }
            } else {
                network_error_callback("Invalid port number (1024-65535)");
            }
        }
        
        // Back
        if (keyboard_check_pressed(vk_escape)) {
            menu_state = MULTIPLAYER_MENU_STATE.MAIN;
            selected_option = 0;
        }
        break;
        
    case MULTIPLAYER_MENU_STATE.JOIN:
        // Handle IP/Port input
        if (keyboard_check_pressed(vk_tab)) {
            active_input = (active_input == "ip") ? "port" : "ip";
        }
        
        if (keyboard_check_pressed(vk_enter)) {
            var port = real(input_port);
            if (port >= 1024 && port <= 65535) {
                if (global.network_manager.join_game(input_ip, port)) {
                    network_success_callback();
                } else {
                    network_error_callback(global.network_manager.error_message);
                }
            } else {
                network_error_callback("Invalid port number (1024-65535)");
            }
        }
        
        // Back
        if (keyboard_check_pressed(vk_escape)) {
            menu_state = MULTIPLAYER_MENU_STATE.MAIN;
            selected_option = 0;
        }
        break;
        
    case MULTIPLAYER_MENU_STATE.LOBBY:
        // Refresh player list
        refresh_timer++;
        if (refresh_timer >= refresh_rate) {
            refresh_timer = 0;
            ds_list_clear(player_list);
            
            var key = ds_map_find_first(global.network_manager.connected_players);
            while (key != undefined) {
                var player_data = global.network_manager.connected_players[? key];
                ds_list_add(player_list, {
                    name: player_data.name,
                    id: player_data.player_id,
                    is_host: (player_data.player_id == 1)
                });
                key = ds_map_find_next(global.network_manager.connected_players, key);
            }
        }
        
        // Start game (host only)
        if (global.network_manager.is_host && keyboard_check_pressed(vk_enter)) {
            if (ds_list_size(player_list) > 0) {
                global.network_manager.start_game();
            }
        }
        
        // Leave lobby
        if (keyboard_check_pressed(vk_escape)) {
            global.network_manager.cleanup();
            menu_state = MULTIPLAYER_MENU_STATE.MAIN;
            selected_option = 0;
        }
        break;
}

// Handle text input
if (is_typing) {
    if (keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_escape)) {
        is_typing = false;
    } else {
        var input = keyboard_string;
        switch(active_input) {
            case "ip":
                input_ip = string_copy(input, 1, 15);
                break;
            case "port":
                input_port = string_copy(input, 1, 5);
                break;
            case "name":
                input_name = string_copy(input, 1, 20);
                break;
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Create_0.gml
//global volume control
global.masterVolume = 1;
global.musicVolume = 1;

//info for the song that we are currently playing / trying to play
songInstance = noone;
songAsset = noone;
targetSongAsset = noone;
endFadeOutTime = 0;//how many frames to fade out the song currently playing
startFadeInTime = 0;//how many frames to fade in the new song
fadeInInstVol = 1;//the volume of songInstance

//for fading music out and stopping songs that are no longer playing
fadeOutInstances = array_create(0);//audio instances to fade out
fadeOutInstVol = array_create(0);//the volume of each indiviual audio instance
fadeOutInstTime = array_create(0);//how fast the fadeout should happen
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Other_4.gml
// Play the correct music

if room == rm_welcome_room
|| room == rm_plaza
|| room == rm_shore
{
	set_song_ingame( bg_music, 60, 0 );
}

//For other rooms that require different music
//if room == rm_template
//{
//	set_song_ingame( bg_music, 3*60 );
//}

//if room == rm_template
//{
//	set_song_ingame( bg_music, 2*60, 2*60 );
//}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Step_0.gml
var _finalVol = global.musicVolume*global.masterVolume;

//Play the target song
if songAsset != targetSongAsset
{
	//Tell the old song to fade out
	if audio_is_playing( songInstance )
	{
		//add out songInstance to our array of songs to fade out
		array_push( fadeOutInstances, songInstance );
		//add the songInstance's starting volume (so theres no adrupt change in volume)
		array_push( fadeOutInstVol, fadeInInstVol );
		//add the fadeOutInstance's fade out frames
		array_push( fadeOutInstTime, endFadeOutTime );
		
		//reset the songInstance and songAsset variables
		songInstance = noone;
		songAsset = noone;
	}
	
	
	//Play the song if the old song has faded out
	if array_length( fadeOutInstances) == 0
	{
		if audio_exists( targetSongAsset)
		{
			//Play the song and store its instance in a variable
			songInstance = audio_play_sound( targetSongAsset, 4, true );
	
			//Start the song's volume at 0
			audio_sound_gain( songInstance, 0, 0 );
			fadeInInstVol = 0;
		}
	
	//Set the songAssest to match the targetSongAsset
	songAsset = targetSongAsset;
	}
}


//Volume Control
	//Main song volume
	if audio_is_playing( songInstance )
	{
		//Fade the song in
		if startFadeInTime > 0
		{
			if fadeInInstVol < 1 { fadeInInstVol += 1/startFadeInTime; } else fadeInInstVol = 1
		}
		//Immediately start the song if the fade in time is 0 framces
		else
		{
			fadeInInstVol = 1;
		}
	
		//Actually set the gain
		audio_sound_gain( songInstance, fadeInInstVol*_finalVol, 0 )
	}
	
	//Fading songs out
	for(var i = 0; i < array_length(fadeOutInstances); i++ )
	{
		//Fade the volume
		if fadeOutInstTime[i] > 0
		{
			if	fadeOutInstVol[i] > 0 {fadeOutInstVol[i] -= 1/fadeOutInstTime[i]; }
		}
		//Immediately cut volume to 0 otherwuse
		else
		{
			fadeOutInstVol[i] = 0;
		}
		
		//Actually set the gain
		audio_sound_gain( fadeOutInstances[i], fadeOutInstVol[i]*_finalVol, 0 );
		
		//Stop the song when it's volume is at 0 and remove it from ALL arrays
		if fadeOutInstVol[i] <= 0
		{
			//stop the song	
			if audio_is_playing( fadeOutInstances[i] ) { audio_stop_sound( fadeOutInstances[i] ); };
			//remove it from the arrays
			array_delete( fadeOutInstances, i, 1);
			array_delete( fadeOutInstVol, i, 1);
			array_delete( fadeOutInstTime, i, 1);
			//set the loop back 1 since we just deleted an entry
			i--;
		}
	}
	
	
	
	
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_network_player
File: Create_0.gml
/// @description Initialize network player
network_id = -1;
target_x = x;
target_y = y;
face = DOWN;
network_skin = "player";
lerp_speed = 0.2; // Interpolation speed
name = "";
is_active = true;

// Initialize sprite based on skin
sprite_index = spr_player_idle;
image_speed = 0;
image_index = 0;
image_blend = c_white;

// Last update timestamp
last_update = current_time;

// Animation state
is_moving = false;
anim_frame = 0;
anim_speed = 0.2; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_network_player
File: Draw_0.gml
/// @description Draw network player and UI elements

// Draw the player sprite
draw_self();

// Set up text drawing
draw_set_font(fnt_small);
draw_set_halign(fa_center);
draw_set_valign(fa_bottom);

// Draw player name with outline
var name_y = y - sprite_height - 5;
draw_set_color(c_black);
draw_text(x-1, name_y, name);
draw_text(x+1, name_y, name);
draw_text(x, name_y-1, name);
draw_text(x, name_y+1, name);
draw_set_color(c_white);
draw_text(x, name_y, name);

// Draw connection status indicator if inactive
if (!is_active) {
    draw_sprite_ext(spr_connection_status, 0, x, y - sprite_height - 20, 
                   0.5, 0.5, 0, c_red, 1);
}

// Reset drawing properties
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_network_player
File: Step_0.gml
/// @description Update network player

// Check timeout
if (current_time - last_update > global.network_manager.network_config.timeout) {
    is_active = false;
    image_alpha = 0.5; // Visual indicator that player is inactive
} else {
    is_active = true;
    image_alpha = 1;
}

// Interpolate position
if (point_distance(x, y, target_x, target_y) > 1) {
    x = lerp(x, target_x, lerp_speed);
    y = lerp(y, target_y, lerp_speed);
    is_moving = true;
} else {
    is_moving = false;
}

// Update sprite based on skin and state
var base_sprite;
switch(network_skin) {
    case "player":
        base_sprite = is_moving ? spr_player_walk : spr_player_idle;
        break;
    case "icetruck":
        base_sprite = is_moving ? spr_player_icetruck_move : spr_player_icetruck_idle;
        break;
    case "tube":
        base_sprite = is_moving ? spr_player_tube_move : spr_player_tube_idle;
        break;
    case "toboggan":
        base_sprite = is_moving ? spr_player_toboggan_move : spr_player_toboggan_idle;
        break;
    case "sled_player":
        base_sprite = is_moving ? spr_sled_player_move : spr_sled_player_idle;
        break;
    case "ninja":
        base_sprite = is_moving ? spr_player_ninja_move : spr_player_ninja_idle;
        break;
    default:
        base_sprite = is_moving ? spr_player_walk : spr_player_idle;
}

// Update sprite and animation
sprite_index = base_sprite;
if (is_moving) {
    anim_frame += anim_speed;
    if (anim_frame >= sprite_get_number(sprite_index)) {
        anim_frame = 0;
    }
    image_index = anim_frame;
} else {
    image_index = 0;
}

// Update facing direction
switch(face) {
    case UP:
        image_index = sprite_get_number(sprite_index) * 0.75;
        break;
    case RIGHT:
        image_index = sprite_get_number(sprite_index) * 0.25;
        break;
    case DOWN:
        image_index = 0;
        break;
    case LEFT:
        image_index = sprite_get_number(sprite_index) * 0.5;
        break;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_new_game_button
File: Create_0.gml
depth = -1000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_new_game_button
File: Mouse_4.gml
room_goto(rm_colour_picker);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_notification_manager
File: Create_0.gml
/// @description Initialize notification manager

// Make persistent
persistent = true;

// Register cleanup handler
array_push(global.game_state.cleanup_handlers, function() {
    global.notification_system.cleanup();
}); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_notification_manager
File: Draw_64.gml
/// @description Draw notifications

// Skip if game is paused
if (global.game_state.flags.is_paused) exit;

// Draw notifications
global.notification_system.draw(); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Alarm_0.gml
if (npc_portrait != "") {
    sprite_index = npc_portrait;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Create_0.gml
/// @description Initialize NPC
event_inherited();

// Basic NPC properties
npc_name = "Unknown";
npc_color = c_white;
npc_role = "none";
is_interactable = true;

// Quest system properties
quest_available = false;
quest_id = -1;
quest_state = "none"; // none, available, active, complete
quest_requirements = ds_map_create();

// Dialogue system
dialog_tree = ds_map_create();
current_dialog = "";
current_choices = [];
dialog_state = "idle";

// Initialize quest data
function init_quest_data() {
    switch(npc_role) {
        case "Tour Guide Assistant":
            setup_tour_guide_assistant();
            break;
        case "EPF Agent":
            setup_epf_agent();
            break;
        case "Gadget Guy":
            setup_gadget_guy();
            break;
        case "Signal Expert":
            setup_signal_expert();
            break;
        case "EPF Director":
            setup_epf_director();
            break;
    }
}

// NPC-specific setup functions
function setup_tour_guide_assistant() {
    npc_name = "Rookie";
    quest_id = "QUEST_MISSING_GUIDE";
    quest_available = true;
    quest_state = "available";
    
    ds_map_add(dialog_tree, "start", {
        text: "Have you seen the Tour Guide? They've been missing since those strange bots started appearing...",
        choices: ["I'll help look", "Not now"],
        next_states: ["accept_quest", "reject_quest"]
    });
    
    ds_map_add(dialog_tree, "accept_quest", {
        text: "Thank goodness! Please check the Ski Village first. That's where they were last seen.",
        choices: ["Will do"],
        next_states: ["quest_active"],
        actions: ["activate_quest"]
    });
    
    ds_map_add(dialog_tree, "quest_complete", {
        text: "You found the EPF Phone! This must mean... the Tour Guide was investigating the bots! You should talk to the EPF Agent in the Ski Village.",
        choices: ["I'm on it"],
        next_states: ["end"],
        actions: ["complete_quest"]
    });
}

function setup_epf_agent() {
    npc_name = "Agent D";
    quest_id = "QUEST_INVESTIGATE_BOTS";
    
    ds_map_add(dialog_tree, "start", {
        text: "I see you found an EPF Phone. The Tour Guide was one of our agents investigating suspicious bot activity.",
        choices: ["Tell me more", "Not interested"],
        next_states: ["explain_mission", "reject_quest"]
    });
    
    ds_map_add(dialog_tree, "explain_mission", {
        text: "These bots are unlike anything we've seen. We need your help investigating them. Are you in?",
        choices: ["I'll help", "Maybe later"],
        next_states: ["accept_quest", "reject_quest"]
    });
    
    ds_map_add(dialog_tree, "accept_quest", {
        text: "Excellent! Take this EPF Badge. Check the Plaza for suspicious bot activity.",
        choices: ["On my way"],
        next_states: ["quest_active"],
        actions: ["activate_quest"]
    });
}

function setup_gadget_guy() {
    npc_name = "Gary the Gadget Guy";
    quest_id = "QUEST_REPAIR_PHONE";
    
    ds_map_add(dialog_tree, "start", {
        text: "Ah, an EPF agent in training! That broken Spy Phone you found might hold crucial information.",
        choices: ["Can you fix it?", "Not now"],
        next_states: ["explain_repair", "reject_quest"]
    });
    
    ds_map_add(dialog_tree, "explain_repair", {
        text: "I need specific parts to repair it. A new battery, circuit board, and antenna. Find these in the Snow Forts.",
        choices: ["I'll find them"],
        next_states: ["quest_active"],
        actions: ["activate_quest"]
    });
}

function setup_signal_expert() {
    npc_name = "Agent PH";
    quest_id = "QUEST_TRACK_SIGNAL";
    
    ds_map_add(dialog_tree, "start", {
        text: "The repaired Spy Phone is picking up strange signals. We need to track their source.",
        choices: ["How can I help?", "Not now"],
        next_states: ["explain_tracking", "reject_quest"]
    });
    
    ds_map_add(dialog_tree, "explain_tracking", {
        text: "Use this Signal Tracker around the island. The strongest signals are coming from the mountains.",
        choices: ["I'll investigate"],
        next_states: ["quest_active"],
        actions: ["activate_quest"]
    });
}

function setup_epf_director() {
    npc_name = "The Director";
    quest_id = "QUEST_HERBERT_LAIR";
    
    ds_map_add(dialog_tree, "start", {
        text: "Agent, the signal patterns match Herbert's technology. We must find his lair before he can activate more bots.",
        choices: ["I'm ready", "Need time"],
        next_states: ["accept_quest", "reject_quest"]
    });
    
    ds_map_add(dialog_tree, "accept_quest", {
        text: "The signal is strongest near the mountain peak. Be careful, Herbert's bots will try to stop you.",
        choices: ["Understood"],
        next_states: ["quest_active"],
        actions: ["activate_quest"]
    });
}

// Quest management functions
function activate_quest() {
    if (quest_id != -1 && check_quest_requirements(quest_id)) {
        ds_list_add(global.active_quests, quest_id);
        quest_state = "active";
        show_debug_message("Quest activated: " + string(quest_id));
    }
}

function complete_quest() {
    if (quest_id != -1) {
        var quest_index = ds_list_find_index(global.active_quests, quest_id);
        if (quest_index != -1) {
            ds_list_delete(global.active_quests, quest_index);
            ds_list_add(global.completed_quests, quest_id);
            quest_state = "complete";
            
            // Give rewards
            give_quest_rewards(quest_id);
            
            // Check for next quest availability
            var quest_data = global.quest_data[? quest_id];
            if (variable_struct_exists(quest_data, "next_quest")) {
                show_debug_message("Next quest available: " + quest_data.next_quest);
            }
            
            show_debug_message("Quest completed: " + string(quest_id));
        }
    }
}

// Initialize based on role
init_quest_data();

// Movement settings
xspd = 0;
yspd = 0;
move_spd = 0;
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0;
stuck_timer = 0;
wait_timer = 3;
last_x = x;
last_y = y;
face = DOWN;

// NPC Settings
if (variable_global_exists("player_colors") && array_length(global.player_colors) > 0) {
    npc_color = global.player_colors[irandom(array_length(global.player_colors) - 1)];
} else {
    npc_color = c_white; // Fallback to white if colors are not defined
}
is_static = true;  // If true, NPC doesn't move

// Dialogue and quest-related variables
quest_active = false;
quest_complete = false;
current_dialogue_index = -1;
dialogue = ["Hello there!", "I have nothing to say."];
player_interacting = false;

// Quest System
is_quest_giver = false;
quest_given = false;
quest_item = "";
quest_quantity = 0;  // Default to 0, set in creation code if needed
quest_stage = 0;  // 0 = not started, 1 = completed
reward_item = "";

// Sprite setup (mirroring obj_player)
sprite_body = spr_player_body;
sprite_color = spr_player_colour;
mask_index = spr_player_down;
image_speed = 0;
image_index = 0;

// Frame data for walking (same as obj_player)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Depth sorting
set_depth();

/// @function init_npc(config)
function init_npc(config) {
    npc_name = config.name;
    npc_color = config.color;
    npc_type = config.type;
    dialogue_tree = config.dialogue;
    quest_giver = config.quest_giver ?? false;
    available_quests = config.quests ?? [];
    
    // Register with game state if quest giver
    if (quest_giver) {
        ds_map_add(global.game_state.npc_states, npc_name, {
            talked_to: false,
            quests_given: [],
            quests_completed: []
        });
    }
    
    return self;
}

/// @function start_dialogue()
function start_dialogue() {
    if (!can_interact) return;
    
    is_talking = true;
    global.game_state.flags.dialogue_active = true;
    
    // Create dialogue window
    if (!instance_exists(obj_chat_window)) {
        var chat = instance_create_layer(0, 0, "UI", obj_chat_window);
        chat.npc_name = npc_name;
        chat.npc_color = npc_color;
    }
    
    // Start with initial dialogue
    if (quest_giver) {
        check_available_quests();
    }
    
    show_dialogue("greeting");
}

/// @function show_dialogue(dialogue_id)
function show_dialogue(dialogue_id) {
    if (!variable_struct_exists(dialogue_tree, dialogue_id)) {
        end_dialogue();
        return;
    }
    
    current_dialogue = dialogue_tree[$ dialogue_id];
    dialogue_options = [];
    
    // Process dialogue conditions
    if (variable_struct_exists(current_dialogue, "conditions")) {
        for (var i = 0; i < array_length(current_dialogue.conditions); i++) {
            var condition = current_dialogue.conditions[i];
            if (!check_condition(condition)) {
                show_dialogue(current_dialogue.fallback ?? "greeting");
                return;
            }
        }
    }
    
    // Build dialogue options
    if (variable_struct_exists(current_dialogue, "options")) {
        for (var i = 0; i < array_length(current_dialogue.options); i++) {
            var option = current_dialogue.options[i];
            if (!variable_struct_exists(option, "conditions") || check_condition(option.conditions)) {
                array_push(dialogue_options, option);
            }
        }
    }
    
    // Update chat window
    with(obj_chat_window) {
        dialog_data = other.current_dialogue.text;
        choices = other.dialogue_options;
    }
    
    // Process dialogue actions
    if (variable_struct_exists(current_dialogue, "actions")) {
        process_actions(current_dialogue.actions);
    }
}

/// @function check_condition(condition)
function check_condition(condition) {
    switch(condition.type) {
        case "quest_active":
            return global.quest_system.is_quest_active(condition.quest_id);
        
        case "quest_completed":
            return global.quest_system.get_quest_status(condition.quest_id) == QuestStatus.COMPLETED;
        
        case "has_item":
            return has_item(condition.item_id);
        
        case "level_requirement":
            return global.game_state.player.level >= condition.level;
            
        default:
            return true;
    }
}

/// @function process_actions(actions)
function process_actions(actions) {
    for (var i = 0; i < array_length(actions); i++) {
        var action = actions[i];
        switch(action.type) {
            case "start_quest":
                global.quest_system.start_quest(action.quest_id);
                break;
                
            case "complete_objective":
                global.quest_system.update_quest_progress(action.quest_id, action.objective_index, action.progress);
                break;
                
            case "give_item":
                // Add item to inventory
                var inventory_slot = -1;
                for (var j = 0; j < array_length(global.inventory); j++) {
                    if (global.inventory[j] == -1) {
                        inventory_slot = j;
                        break;
                    }
                }
                if (inventory_slot != -1) {
                    global.inventory[inventory_slot] = action.item_id;
                }
                break;
        }
    }
}

/// @function check_available_quests()
function check_available_quests() {
    for (var i = 0; i < array_length(available_quests); i++) {
        var quest_id = available_quests[i];
        var quest_status = global.quest_system.get_quest_status(quest_id);
        
        if (quest_status == QuestStatus.NOT_STARTED) {
            // Add quest dialogue option
            var quest_data = global.quest_system.quest_definitions[? quest_id];
            array_push(dialogue_options, {
                text: "Tell me about " + quest_data.title,
                next: "quest_" + quest_id,
                actions: [{
                    type: "start_quest",
                    quest_id: quest_id
                }]
            });
        }
    }
}

/// @function end_dialogue()
function end_dialogue() {
    is_talking = false;
    global.game_state.flags.dialogue_active = false;
    
    with(obj_chat_window) {
        instance_destroy();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Draw_0.gml
// Calculate drawing position
var draw_x = x - 12;  // Center 24x24 sprite
var draw_y = y - 12;
var frame_index = floor(image_index) mod 3;  // 3 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Draw body and colored overlay
draw_sprite_part_ext(sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, c_white, 1);
draw_sprite_part_ext(sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, npc_color, 1);

// Depth sorting
depth = -y;  // Consistent with set_depth()

// Draw the dialogue box if active
if (current_dialogue_index >= 0) {
    // Text and box parameters
    var margin = 8; // Padding around the text
    var max_width = 200; // Maximum width for the dialogue box
    var text_scale = 0.50; // Scale the text smaller

    // Calculate text dimensions
	draw_set_font(fnt_acme_secretagent_bold);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(dialogue[current_dialogue_index]) * text_scale;
    var text_height = string_height(dialogue[current_dialogue_index]) * text_scale;

    // Calculate box dimensions (add padding around the text)
    var box_width = min(max_width, text_width + margin * 2);
    var box_height = text_height + margin * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 0.5;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_chat,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, dialogue[current_dialogue_index], text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Step_0.gml
/// @description Handle NPC behavior and interactions

// Handle basic movement and animation
event_inherited();

// Check for player interaction
if (is_interactable && distance_to_object(global.player_instance) < 32) {
    // Show interaction prompt
    if (!instance_exists(obj_chat_window)) {
        draw_set_font(fnt_bonkfatty);
        draw_set_color(c_white);
        draw_text(x, y - sprite_height - 10, "Press E to talk");
        
        // Show quest availability indicator
        if (quest_available && quest_state == "available") {
            draw_sprite(spr_quest_available, 0, x, y - sprite_height - 20);
        } else if (quest_state == "active" && check_quest_completion()) {
            draw_sprite(spr_quest_complete, 0, x, y - sprite_height - 20);
        }
    }
    
    // Handle interaction
    if (keyboard_check_pressed(ord("E"))) {
        if (!instance_exists(obj_chat_window)) {
            // Start dialogue
            var chat = instance_create_layer(x, y, "Instances", obj_chat_window);
            with (chat) {
                global.chat_active = true;
                global.chat_npc = other;
                
                // Set initial dialogue based on quest state
                switch(other.quest_state) {
                    case "available":
                        if (check_quest_requirements(other.quest_id)) {
                            dialog_data = [other.dialog_tree[? "start"]];
                        } else {
                            // Show requirements not met dialogue
                            var quest_data = global.quest_data[? other.quest_id];
                            var req_text = "You need to complete other tasks first. ";
                            if (variable_struct_exists(quest_data, "requirements")) {
                                if (variable_struct_exists(quest_data.requirements, "prev_quest")) {
                                    req_text += "Complete the previous quest first.";
                                }
                                if (variable_struct_exists(quest_data.requirements, "items")) {
                                    req_text += "Required items: " + string(quest_data.requirements.items);
                                }
                            }
                            dialog_data = [{
                                text: req_text,
                                choices: ["I understand"],
                                next_states: ["end"]
                            }];
                        }
                        break;
                    case "active":
                        if (check_quest_completion()) {
                            dialog_data = [other.dialog_tree[? "quest_complete"]];
                        } else {
                            dialog_data = [other.dialog_tree[? "quest_active"]];
                        }
                        break;
                    case "complete":
                        // Check if there's a next quest available
                        var quest_data = global.quest_data[? other.quest_id];
                        if (variable_struct_exists(quest_data, "next_quest") && 
                            ds_list_find_index(global.completed_quests, quest_data.next_quest) == -1) {
                            dialog_data = [{
                                text: "You should talk to the other agents about what we discovered.",
                                choices: ["Will do"],
                                next_states: ["end"]
                            }];
                        } else {
                            dialog_data = [{
                                text: "Thanks for all your help!",
                                choices: ["You're welcome"],
                                next_states: ["end"]
                            }];
                        }
                        break;
                    default:
                        dialog_data = [{
                            text: "Hello there!",
                            choices: ["Hi"],
                            next_states: ["end"]
                        }];
                        break;
                }
            }
        }
    }
}

// Update quest state if conditions are met
if (quest_state == "active") {
    switch(quest_id) {
        case "QUEST_MISSING_GUIDE":
            if (room == rm_ski_village && variable_global_exists("found_guide_clue") && global.found_guide_clue) {
                complete_quest();
            }
            break;
            
        case "QUEST_INVESTIGATE_BOTS":
            if (room == rm_plaza && variable_global_exists("investigated_bots") && global.investigated_bots) {
                complete_quest();
            }
            break;
            
        case "QUEST_REPAIR_PHONE":
            if (has_item("Battery") && has_item("Circuit Board") && has_item("Antenna")) {
                complete_quest();
            }
            break;
            
        case "QUEST_TRACK_SIGNAL":
            if (variable_global_exists("tracked_all_signals") && global.tracked_all_signals) {
                complete_quest();
            }
            break;
            
        case "QUEST_HERBERT_LAIR":
            if (room == rm_mountain_peak && variable_global_exists("found_herbert_lair") && global.found_herbert_lair) {
                complete_quest();
            }
            break;
    }
}

// Helper function to check quest completion conditions
function check_quest_completion() {
    switch(quest_id) {
        case "QUEST_MISSING_GUIDE":
            return variable_global_exists("found_guide_clue") && global.found_guide_clue;
            
        case "QUEST_INVESTIGATE_BOTS":
            return variable_global_exists("investigated_bots") && global.investigated_bots;
            
        case "QUEST_REPAIR_PHONE":
            return has_item("Battery") && has_item("Circuit Board") && has_item("Antenna");
            
        case "QUEST_TRACK_SIGNAL":
            return variable_global_exists("tracked_all_signals") && global.tracked_all_signals;
            
        case "QUEST_HERBERT_LAIR":
            return variable_global_exists("found_herbert_lair") && global.found_herbert_lair;
    }
    return false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Alarm_0.gml
// Alarm[0] Event
// Reset moving state to allow the NPC to pick a new target
is_moving = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Create_0.gml
xspd = 0;
yspd = 0;

move_spd = 0.5; // Lower speed for smoother movement
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0; // Timer for delaying after a collision
stuck_timer = 0; // Timer to handle stuck state
wait_timer = 3; //Timer to handle how long to pause before walking
last_x = x;      // Tracks previous position for stuck detection
last_y = y;      // Tracks previous position for stuck detection

// Initialize movement variables
target_x = x; // Default to current position
target_y = y; // Default to current position
is_moving = false;
move_speed = 1; // Default movement speed

sprite[RIGHT] = spr_player_right;
sprite[UP] = spr_player_up;
sprite[LEFT] = spr_player_left;
sprite[DOWN] = spr_player_down;
sprite[UP_RIGHT] = spr_player_up_right;
sprite[UP_LEFT] = spr_player_up_left;
sprite[DOWN_RIGHT] = spr_player_down_right;
sprite[DOWN_LEFT] = spr_player_down_left;

face = DOWN;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Random initial direction
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
change_direction_timer = fps * 2; // Change direction every 2 seconds

phrases = ["Hello there!", "Nice to meet you!", "What brings you here?", "Have a great day!", "Stay safe!"];
current_phrase = ""; // Will hold the currently displayed phrase
talk_timer = 0; // Timer for how long the phrase is displayed
interact_pause = 0; // Timer to pause movement after interaction


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Draw_0.gml
// Draw NPC as usual
draw_self();

// Ensure chat box is drawn above everything
if (talk_timer > 0) {
    // Text setup
    var text = current_phrase;
    var text_scale = 0.5; // Scale factor for text
    var text_padding = 10; // Padding around the text

    // Calculate text dimensions
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(text) * text_scale; // Scaled width of the text
    var text_height = string_height(text) * text_scale; // Scaled height of the text

    // Calculate box dimensions (add padding around the text)
    var box_width = max(64, text_width + text_padding * 2); // Minimum width for aesthetics
    var box_height = text_height + text_padding * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 10;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_menu,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, text, text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Step_0.gml
// Step Event for obj_npc
if (!sliding) {
    // Normal movement logic
    var move_x = lengthdir_x(move_spd, direction);
    var move_y = lengthdir_y(move_spd, direction);

    // Handle collisions with walls
    if (place_meeting(x + move_x, y, obj_wall)) {
        direction = 360 - direction; // Reverse direction on x-axis
    }
    if (place_meeting(x, y + move_y, obj_wall)) {
        direction = 180 - direction; // Reverse direction on y-axis
    }

    // Check for collision with obj_slippery to start sliding
    if (place_meeting(x + move_x, y, obj_slippery) || place_meeting(x, y + move_y, obj_slippery)) {
        sliding = true;
        slide_dir_x = sign(move_x);
        slide_dir_y = sign(move_y);
        slide_speed = move_spd * 1.5; // Initial slide speed, adjust as necessary
    } else {
        // Move the NPC normally
        x += move_x;
        y += move_y;
    }

    // Decrease the timer for changing direction
    change_direction_timer--;
    if (change_direction_timer <= 0) {
        direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
        change_direction_timer = fps * 2; // Reset the timer
    }
} else {
    // Sliding logic
    var slide_move_x = slide_dir_x * slide_speed;
    var slide_move_y = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        slide_move_x = 0;
        slide_move_y = 0;
    }

    // Move the NPC while sliding
    x += slide_move_x;
    y += slide_move_y;
}

// Update the sprite based on direction
if (slide_speed > 0) {
    if (slide_dir_y < 0) {
        if (slide_dir_x < 0) { face = UP_LEFT; }
        if (slide_dir_x > 0) { face = UP_RIGHT; }
        if (slide_dir_x == 0) { face = UP; }
    }
    if (slide_dir_y > 0) {
        if (slide_dir_x < 0) { face = DOWN_LEFT; }
        if (slide_dir_x > 0) { face = DOWN_RIGHT; }
        if (slide_dir_x == 0) { face = DOWN; }
    }
    if (slide_dir_y == 0) {
        if (slide_dir_x > 0) { face = RIGHT; }
        if (slide_dir_x < 0) { face = LEFT; }
    }
} else {
    if (direction == 0) face = RIGHT;
    else if (direction == 45) face = UP_RIGHT;
    else if (direction == 90) face = UP;
    else if (direction == 135) face = UP_LEFT;
    else if (direction == 180) face = LEFT;
    else if (direction == 225) face = DOWN_LEFT;
    else if (direction == 270) face = DOWN;
    else if (direction == 315) face = DOWN_RIGHT;
}
sprite_index = sprite[face];

// Depth
depth = -bbox_bottom;

// Debugging logs

show_debug_message("NPC Direction: " + string(direction));
show_debug_message("NPC Face: " + string(face));
show_debug_message("NPC Position: " + string(x) + ", " + string(y));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_tour_guide
File: Create_0.gml
/// @description Initialize Tour Guide NPC

event_inherited();

// Initialize NPC with specific configuration
init_npc({
    name: "Tour Guide",
    color: c_blue,
    type: "quest_giver",
    quest_giver: true,
    quests: ["QUEST_MISSING_GUIDE", "QUEST_INVESTIGATE_BOTS", "QUEST_REPAIR_PHONE"],
    dialogue: {
        greeting: {
            text: "Welcome to the Ski Village! I'm here to help guide penguins around the island.",
            options: [
                {
                    text: "Tell me about the island",
                    next: "about_island"
                },
                {
                    text: "Any interesting news?",
                    next: "daily_news"
                },
                {
                    text: "I heard someone went missing?",
                    next: "missing_guide_intro",
                    conditions: [{
                        type: "quest_active",
                        quest_id: "QUEST_MISSING_GUIDE"
                    }]
                },
                {
                    text: "About those bots...",
                    next: "bot_investigation",
                    conditions: [{
                        type: "quest_completed",
                        quest_id: "QUEST_MISSING_GUIDE"
                    }]
                },
                {
                    text: "Goodbye",
                    next: "farewell"
                }
            ]
        },
        about_island: {
            text: "The island is full of wonderful places to explore! From the cozy Ski Lodge to the exciting Plaza, there's something for everyone.",
            options: [
                {
                    text: "Tell me about the Ski Lodge",
                    next: "about_ski_lodge"
                },
                {
                    text: "What's at the Plaza?",
                    next: "about_plaza"
                },
                {
                    text: "Back",
                    next: "greeting"
                }
            ]
        },
        about_ski_lodge: {
            text: "The Ski Lodge is a warm, cozy place where penguins gather. The owner there is quite knowledgeable about the area's history... and recent strange occurrences.",
            options: [
                {
                    text: "Strange occurrences?",
                    next: "missing_guide_intro",
                    conditions: [{
                        type: "quest_not_started",
                        quest_id: "QUEST_MISSING_GUIDE"
                    }]
                },
                {
                    text: "Tell me more locations",
                    next: "about_island"
                },
                {
                    text: "Back",
                    next: "greeting"
                }
            ]
        },
        about_plaza: {
            text: "The Plaza is our entertainment hub! Though lately, some penguins have reported seeing unusual mechanical objects there...",
            options: [
                {
                    text: "Mechanical objects?",
                    next: "bot_hint"
                },
                {
                    text: "Tell me more locations",
                    next: "about_island"
                },
                {
                    text: "Back",
                    next: "greeting"
                }
            ]
        },
        daily_news: {
            text: "Let's see... [randomized_news]",
            options: [
                {
                    text: "Interesting",
                    next: "greeting"
                }
            ]
        },
        missing_guide_intro: {
            text: "Yes, it's quite concerning. One of our fellow tour guides disappeared recently. We found some strange notes and footprints... and an unusual mechanical part.",
            options: [
                {
                    text: "I'll help look for them",
                    next: "start_search",
                    actions: [{
                        type: "start_quest",
                        quest_id: "QUEST_MISSING_GUIDE"
                    }]
                },
                {
                    text: "Tell me more about the mechanical part",
                    next: "mechanical_part_info"
                },
                {
                    text: "Maybe later",
                    next: "greeting"
                }
            ]
        },
        mechanical_part_info: {
            text: "It looks like part of a robot, but more advanced than anything I've seen. The Ski Lodge owner mentioned seeing similar parts near the lodge recently.",
            options: [
                {
                    text: "I'll investigate",
                    next: "start_search",
                    actions: [{
                        type: "start_quest",
                        quest_id: "QUEST_MISSING_GUIDE"
                    }]
                },
                {
                    text: "Back",
                    next: "greeting"
                }
            ]
        },
        start_search: {
            text: "Thank you! Start by checking the Ski Lodge - the owner there might have seen something suspicious. And keep an eye out for more mechanical parts!",
            options: [
                {
                    text: "I'll head there now",
                    next: "search_tips"
                }
            ]
        },
        search_tips: {
            text: "Look for anything unusual - footprints in the snow, dropped items, or those strange mechanical parts. And be careful, something doesn't feel right about this...",
            options: [
                {
                    text: "I'll be careful",
                    next: "farewell"
                }
            ]
        },
        bot_investigation: {
            text: "Those mechanical parts you found... they're definitely connected to the missing guide. We need to investigate the Plaza - there have been more bot sightings there.",
            options: [
                {
                    text: "I'll check it out",
                    next: "start_bot_quest",
                    actions: [{
                        type: "start_quest",
                        quest_id: "QUEST_INVESTIGATE_BOTS"
                    }]
                },
                {
                    text: "Not right now",
                    next: "greeting"
                }
            ]
        },
        bot_hint: {
            text: "Yes... they appear to be some kind of automated robots. No one knows where they came from, but they started appearing around the same time as... well, other strange events.",
            options: [
                {
                    text: "What events?",
                    next: "missing_guide_intro",
                    conditions: [{
                        type: "quest_not_started",
                        quest_id: "QUEST_MISSING_GUIDE"
                    }]
                },
                {
                    text: "Back",
                    next: "greeting"
                }
            ]
        },
        farewell: {
            text: "[random_farewell]",
            options: []
        }
    }
});

// Random news messages
random_news = [
    "The Pizza Parlor is testing new recipes! Though some penguins reported their pizzas making unusual mechanical sounds...",
    "The Ski Hill has been extra busy lately! Although, there have been reports of strange tracks in the snow...",
    "The Coffee Shop just got a new shipment of hot chocolate! Perfect for warming up after investigating mysterious occurrences...",
    "The Gift Shop has new items in stock! Including some peculiar mechanical parts that no one seems to recognize..."
];

// Random farewell messages
random_farewells = [
    "Stay safe out there! And remember, if you need directions, just look for a Tour Guide!",
    "Keep your eyes open for anything unusual. We Tour Guides notice everything!",
    "Don't forget to check the map if you get lost. Though some locations seem to have... changed recently.",
    "Be careful in your explorations. Some areas of the island aren't quite as they seem..."
];

// Override show_dialogue to handle random text
show_dialogue = function(dialogue_id) {
    var dialogue = dialogue_tree[$ dialogue_id];
    if (dialogue == undefined) {
        end_dialogue();
        return;
    }
    
    // Handle random text replacements
    if (string_pos("[randomized_news]", dialogue.text) != 0) {
        dialogue.text = string_replace(dialogue.text, "[randomized_news]", 
            random_news[irandom(array_length(random_news) - 1)]);
    }
    
    if (string_pos("[random_farewell]", dialogue.text) != 0) {
        dialogue.text = string_replace(dialogue.text, "[random_farewell]", 
            random_farewells[irandom(array_length(random_farewells) - 1)]);
    }
    
    // Continue with normal dialogue processing
    event_inherited();
}

// Set sprite based on direction
sprite[RIGHT] = spr_tour_guide_right;
sprite[UP] = spr_tour_guide_up;
sprite[LEFT] = spr_tour_guide_left;
sprite[DOWN] = spr_tour_guide_down;
sprite[UP_RIGHT] = spr_tour_guide_up_right;
sprite[UP_LEFT] = spr_tour_guide_up_left;
sprite[DOWN_RIGHT] = spr_tour_guide_down_right;
sprite[DOWN_LEFT] = spr_tour_guide_down_left;

// Initialize facing direction
direction_facing = DOWN; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Create_0.gml
// Create Event for obj_obstacle
move_speed = 5; // Speed at which obstacles move upwards

// Step Event for obj_obstacle
y += move_speed;

// Destroy the obstacle if it goes off the top of the screen
if (y < -sprite_height) {
    instance_destroy();
}

//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Step_0.gml
if (global.game_started) {
    y -= move_speed; // Move upwards

    // Reset position if off-screen
    if (y < -sprite_height) {
        y = room_height + sprite_height; // Reset to below the room
        x = irandom_range(0, room_width - sprite_width); // Randomize horizontal position
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Alarm_0.gml
instance_create_layer(irandom_range(0, room_width - sprite_get_width(spr_long_bush)), room_height, "Instances", obj_obstacle);
alarm[0] = 30; // Reset alarm
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Create_0.gml
alarm[0] = 30; // Spawn obstacle every 30 steps (adjust for difficulty)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Create_0.gml
depth = 10000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Draw_0.gml
var _camx = camera_get_view_x(global.camera);  // Use global.camera explicitly
var _camy = camera_get_view_y(global.camera);

var _p = 0.5;  // Parallax factor (adjust as needed)

if (sprite_exists(bg_sky)) {
    draw_sprite(bg_sky, 0, _camx * _p, _camy * _p);
} else {
    show_debug_message("ERROR: bg_sky sprite does not exist!");
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_party_hat
File: Create_0.gml
event_inherited();
item_name = "Party Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Create_0.gml
// Create Event in obj_pause_menu
depth = -99990; // Ensure pause menu is drawn on top
global.is_pause_menu_active = false;
global.inventory_visible = false; 

image_speed = 0.5; // Menu animation speed

op_border = 8;
op_space = 16;
pos = 0;

// Pause menu options
option[0, 0] = "Back to Game";
option[0, 1] = "Settings";
option[0, 2] = "Quit Game";
option[0, 3] = "Save Game"; // Added "Save Game" option

// Settings menu options
option[1, 0] = "Window Size";
option[1, 1] = "Brightness";
option[1, 2] = "Controls";
option[1, 3] = "Back";

menu_level = 0; 
op_length = array_length(option[menu_level]); // Set initial length dynamically
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Draw_0.gml
// Only draw when the pause menu is active
if (!global.is_pause_menu_active) {
    exit;
}

draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) return;

// Dynamically calculate menu width
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        _new_w = max(_new_w, string_width(option[menu_level][i]));
    }
}
width = _new_w + op_border * 2;
height = op_border * 4 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    floor(image_index), // Use image_index for animation
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw menu options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        var color = (pos == i) ? c_yellow : c_white; // Highlight selection
        draw_text_color(x + width / 2, y + op_border + op_space * i, option[menu_level][i], color, color, color, color, 1);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_0.gml

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_2.gml
// End Step Event in obj_pause_menu
// Only process inputs when the pause menu is active
if (!global.is_pause_menu_active) {
    exit;
}

// Skip if click was already handled by another UI element
if (global.click_handled) {
    exit;
}

// Skip input processing if inventory or expanded HUD is visible
if (global.inventory_visible || global.is_expanded) {
    exit;
}

// Update menu options dynamically
op_length = array_length(option[menu_level]);

// Mouse Position Adjusted to GUI Coordinates
var menu_width = 300;
var menu_height = op_length * 40 + 20;
var menu_top = y - menu_height / 2 + 20;
var menu_left = x - menu_width / 2;

if (mouse_x > menu_left && mouse_x < menu_left + menu_width) {
    pos = floor((mouse_y - menu_top) / 40);
} else {
    pos = -1;
}

// Ensure pos is within valid bounds
if (pos < 0 || pos >= op_length) pos = -1;

// Handle menu selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main Pause Menu
            switch (pos) {
                case 0: // Resume Game
                    global.is_pause_menu_active = false;
                    global.player_controls_enabled = true;
                    show_debug_message("Game Resumed");
                    break;
                case 1: // Go to Settings
                    menu_level = 1;
                    break;
                case 2: // Quit Game
                    show_debug_message("Calling game_end from obj_pause_menu Quit Game button");
                    game_end();
                    break;
                case 3: // Save Game
                    save_game(); // Call the save function
                    break;
            }
            break;
        case 1: // Settings Menu
            switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
                case 3: // Back to Pause Menu
                    menu_level = 0;
                    break;
            }
            break;
    }
}

show_debug_message("Pause menu active: " + string(global.is_pause_menu_active) + ", Click handled: " + string(global.click_handled));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Create_0.gml
// obj_pickup_item Create Event
is_savable = true;
item_name = ""; // Set in creation code or instance variables

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Step_0.gml
// obj_pickup_item Step Event
if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 16) {
    if (instance_exists(obj_inventory)) {
        var added = obj_inventory.add_to_inventory(item_name);
        if (added) {
            show_debug_message(item_name + " added to inventory.");
            instance_destroy();
        } else {
            show_debug_message("Inventory full.");
        }
    }
}
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pizzaslice_item
File: Create_0.gml
event_inherited();
item_name = "Pizza Slice";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Create_0.gml
// Core variables - Initialize from game state if available
if (variable_global_exists("game_state")) {
    with(global.game_state) {
        other.xspd = 0;
        other.yspd = 0;
        other.move_spd = player.move_spd;
        other.face = player.face;
        other.image_blend = player.color;
        player.instance = other.id;
    }
} else {
    // Fallback initialization
    xspd = 0;
    yspd = 0;
    move_spd = 1;
    face = DOWN;
}

// Set state
state = "walking";

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
original_sprite = sprite_index;

// Set sprites
sprite_body = spr_player_body;
sprite_color = spr_player_colour;
mask_index = spr_player_down;
throw_anim_base = "";
throw_flip = false;

// Frame data for walking (192x72 sprite sheet: 3 frames per direction)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Special actions system
action_state = "none";
action_timer = 0;
action_duration = 0;
sit_delay = 0;
image_index = 0;
image_speed = 0;

// Initialize action data structures
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();

show_debug_message("Player initialized with new state system");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Draw_0.gml
if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
    show_debug_message("WARNING: global.equipped_items is missing or not a ds_map. Reinitializing.");
    global.equipped_items = ds_map_create();
    ds_map_add(global.equipped_items, "head", -1);
    ds_map_add(global.equipped_items, "face", -1);
    ds_map_add(global.equipped_items, "neck", -1);
    ds_map_add(global.equipped_items, "body", -1);
    ds_map_add(global.equipped_items, "hand", -1);
    ds_map_add(global.equipped_items, "feet", -1);
}

var draw_x = x;
var draw_y = y;
var frame_x, frame_y, frame_width, frame_height;
var xscale = 1; // For flipping based on direction

if (action_state == "none") {
    // Walking animation
    var frame_index = floor(image_index) mod 3;
    frame_x = frame_data[face][frame_index * 4];
    frame_y = frame_data[face][frame_index * 4 + 1];
    frame_width = frame_data[face][frame_index * 4 + 2];
    frame_height = frame_data[face][frame_index * 4 + 3];
    draw_x = x - frame_width / 2;
    draw_y = y - frame_height / 2;
	
	// Draw the walking sprite (body and colored overlay)
    draw_sprite_part_ext(sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
    draw_sprite_part_ext(sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
} else {
    // Special actions (including throw)
    var frames = ds_map_find_value(action_frame_data, action_state);
    var frame_count = array_length(frames);
    var frame_index = floor(image_index) mod frame_count;
    var frame_data_array = frames[frame_index];
    if (action_state == "sit") {
        // Static sitting frame based on direction
        var sit_frame_map = [6, 4, 2, 0, 7, 5, 1, 3]; // RIGHT=0 maps to RIGHT=6, etc.
        frame_index = clamp(sit_frame_map[face], 0, frame_count - 1);
        show_debug_message("Face: " + string(face) + ", Sitting Frame: " + string(frame_index));
    } else {
        // Animated actions (dance, wave, jackhammer, snowshovel, throw)
        frame_index = floor(image_index) mod frame_count;
    }
    // Access the sub-array for the current frame
    frame_x = frame_data_array[0];
    frame_y = frame_data_array[1];
    frame_width = frame_data_array[2];
    frame_height = frame_data_array[3];
    
    // Get sprites for current action
    var current_sprite_body = ds_map_find_value(action_sprite_body, action_state);
    var current_sprite_color = ds_map_find_value(action_sprite_color, action_state);
    
    // Calculate drawing position
    var draw_x = x - (frame_width / 2 * xscale);
    var draw_y = y - frame_height / 2;
    
    // Flip sprite for left-facing directions
    if (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) {
        xscale = -1;
    } else {
        xscale = 1;
    }
    
    // Draw body and color overlay
    draw_sprite_part_ext(current_sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
    draw_sprite_part_ext(current_sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
}

// Draw equipped head item
if (ds_exists(global.equipped_items, ds_type_map)) {
    var head_item = global.equipped_items[? "head"];
    if (!is_undefined(head_item) && head_item != -1) {
        var sprite = ds_map_find_value(global.item_player_sprites, head_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, 0, x, y - 12); // Adjust as needed
        }
    }
} else {
    show_debug_message("global.equipped_items is not a ds_map");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Step_0.gml
if (global.is_game_paused) {
    exit;
}

if (global.is_game_paused && instance_exists(obj_inventory_expanded)) {
    if (action_state != "none") {
        var frames = ds_map_find_value(action_frame_data, action_state);
        if (!is_undefined(frames)) {
            image_speed = ds_map_find_value(action_anim_speed, action_state);
            image_index += image_speed;
            var frame_count = array_length(frames);
            if (image_index >= frame_count) image_index = 0;
        } else {
            show_debug_message("Error: No frame data for action_state " + action_state);
            action_state = "none";
        }
    } else {
        image_index += 0.15;  // Walking animation
        if (image_index >= 3) image_index = 0;
    }
} else if (global.is_game_paused) {
    exit;
}

if (instance_exists(obj_inventory)) { if (has_item("Wrench")) {} }

if (global.is_pause_menu_active) { exit; }

// Handle special actions (only when not driving)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) {  // H for Dance
        action_state = "dance";
        action_timer = 0;
        action_duration = 224;  // 56 frames * 4 steps per frame (at 0.25 speed)
        image_index = 0;
        show_debug_message("Starting dance");
    }
    else if (keyboard_check_pressed(ord("J"))) {  // J for Wave
        action_state = "wave";
        action_timer = 0;
        action_duration = 80;  // 16 frames * 5 steps per frame (at 0.2 speed)
        image_index = 0;
        show_debug_message("Starting wave");
    }
    else if (keyboard_check_pressed(ord("K"))) {  // K for Sit
        action_state = "sit";
        action_timer = 0;
        action_duration = -1;  // Infinite until toggled off
        image_index = 0;
        image_speed = 0;       // Static sitting pose
        sit_delay = 5;         // 5-frame delay before toggle-off is allowed
        show_debug_message("Starting sit");
	    }
	}
    else if (keyboard_check_pressed(ord("B"))) {  // B for Jackhammer
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Jackhammer")) {
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150;  // 50 frames * 3 steps per frame (at 0.3 speed)
            image_index = 0;
            show_debug_message("Starting jackhammer");
        } else {
            show_debug_message("Cannot start jackhammer: Jackhammer not in inventory.");
        }
    }
    else if (keyboard_check_pressed(ord("N"))) {  // N for Snow Shovel
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Snow Shovel")) {
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80;  // 16 frames * 5 steps per frame (at 0.2 speed)
            image_index = 0;
            show_debug_message("Starting snow shovel");
        } else {
            show_debug_message("Cannot start snow shovel: Snow Shovel not in inventory.");
        }
    }
    else if (keyboard_check_pressed(ord("O"))) {
	    action_state = "throw";
	    action_timer = 0;
	    action_duration = 24; // Total number of frames in throw animation
	    image_index = 0;
	    image_speed = ds_map_find_value(action_anim_speed, "throw");
	    show_debug_message("Starting throw");

        // Set xscale based on facing direction (your logic)
        xscale = (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) ? -1 : 1;

        // Create snowball projectile
        var snowball = instance_create_layer(x, y, "Instances", obj_snowball);
        switch (face) {
            case RIGHT: snowball.direction = 0; break;
            case LEFT: snowball.direction = 180; break;
            case UP: snowball.direction = 90; break;
            case DOWN: snowball.direction = 270; break;
            case UP_RIGHT: snowball.direction = 45; break;
            case UP_LEFT: snowball.direction = 135; break;
            case DOWN_RIGHT: snowball.direction = 315; break;
            case DOWN_LEFT: snowball.direction = 225; break;
        }
    }


// Manage all special actions
// Handle special actions like throw
if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state); // Speed for this action
    image_index += image_speed;
    var frames = ds_map_find_value(action_frame_data, action_state);  // Frame data for the action
    var frame_count = array_length(frames);                          // Total frames in the action
    
    if (image_index >= frame_count) {
        action_state = "none";  // Reset to idle
        image_index = 0;        // Reset animation
        image_speed = 0;        // Stop animation
        show_debug_message("Action completed");
    }
    xspd = 0;  // Prevent movement during action
    yspd = 0;
}


// Handle existing interactions (only when not in an action)
if (action_state == "none") {
    if (keyboard_check_pressed(ord("R"))) { // Repair Ice Truck
        if (place_meeting(x, y, obj_icetruck_broken) && 
            (obj_inventory.has_item("Wrench") || obj_inventory.has_item("Battery"))) {
            show_debug_message("Repairing ice truck...");
            if (obj_inventory.has_item("Battery")) {
                show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
                obj_inventory.remove_item("Battery");
            }
            show_debug_message("Battery removed after repair.");
            with (instance_place(x, y, obj_icetruck_broken)) instance_destroy();
            instance_create_layer(x, y, "Instances", obj_icetruck);
            show_debug_message("Ice truck repaired!");
        }
    }

    if (keyboard_check_pressed(ord("T"))) { // Enter/Exit Tube
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Tube")) {
                obj_controller.switch_skin("tube");
                show_debug_message("Entered tube mode.");
            } else if (global.current_skin == "tube") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
    
    if (keyboard_check_pressed(ord("T"))) { // Enter/Exit Toboggan
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Toboggan")) {
                obj_controller.switch_skin("toboggan");
                show_debug_message("Entered toboggan mode.");
            } else if (global.current_skin == "toboggan") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited toboggan mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for Toboggan switch.");
        }
    }

    if (keyboard_check_pressed(ord("E"))) { // Enter/Exit Ice Truck
        var truck_nearby = instance_exists(obj_icetruck) && distance_to_object(obj_icetruck) < 16;
        if (instance_exists(obj_controller)) {
            if (truck_nearby && global.current_skin == "player") {
                obj_controller.switch_skin("icetruck");
            } else if (global.current_skin == "icetruck") {
                obj_controller.switch_skin("player");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for ice truck switch.");
        }
    }

    if (instance_exists(obj_inventory)) { if (obj_inventory.has_item("Fishing Rod")) {} }
}

// Player interaction (Press "E" near puffle)
if (distance_to_object(global.player_instance) < 24 && keyboard_check_pressed(ord("E"))) {
    if (state == PuffleState.IDLE) {
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            state = PuffleState.EATING;
            idle_timer = 0;
            persistent = true;
            if (obj_inventory.has_item("Puffle O")) {
                obj_inventory.remove_item("Puffle O");
            } else {
                obj_inventory.remove_item("Box Puffle O");
            }
            show_debug_message("Puffle is eating.");
        } else {
            show_debug_message("Player needs a Puffle O or Box Puffle O's to befriend the puffle.");
        }
    } else if (state == PuffleState.EATING) {
        show_debug_message("Puffle is currently eating. Try again later.");
    } else if (state != PuffleState.FOLLOWING) {
        state = PuffleState.FOLLOWING;
        show_debug_message("Puffle befriended and now following player.");
    } else {
        show_debug_message("Puffle is already following you.");
    }
}

// Only process input if controls are enabled and not in a special state
if (global.game_state.player.controls_enabled && action_state == "none" && !global.game_state.flags.dialogue_active) {
    // Get input
    var hinput = keyboard_check(vk_right) - keyboard_check(vk_left);
    var vinput = keyboard_check(vk_down) - keyboard_check(vk_up);
    
    // Calculate movement
    if (!sliding) {
        xspd = hinput * move_spd;
        yspd = vinput * move_spd;
        
        // Normalize diagonal movement
        if (xspd != 0 && yspd != 0) {
            xspd *= 0.7071; // 1/sqrt(2)
            yspd *= 0.7071;
        }
    }
    
    // Update face direction based on movement
    if (xspd != 0 || yspd != 0) {
        var angle = point_direction(0, 0, xspd, yspd);
        face = round(((angle + 22.5) mod 360) / 45);
    }
}

// Handle collisions using the new collision system
if (sliding) {
    var movement = global.collision_system.handle_sliding_collision(id, xspd, yspd);
    xspd = movement.xspd;
    yspd = movement.yspd;
    
    // Update sliding properties
    if (xspd == 0 && yspd == 0) {
        sliding = false;
    }
} else {
    xspd = global.collision_system.handle_collision(id, "x", xspd);
    yspd = global.collision_system.handle_collision(id, "y", yspd);
}

// Apply movement
x += xspd;
y += yspd;

// Update game state
with(global.game_state) {
    player.x = other.x;
    player.y = other.y;
    player.face = other.face;
}

// Handle special actions
if (action_state != "none") {
    action_timer++;
    
    // Check if action is complete
    if (action_timer >= action_duration) {
        action_state = "none";
        action_timer = 0;
        sprite_body = spr_player_body;
        sprite_color = spr_player_colour;
    }
}

// Update animation frame based on movement or action
if (action_state == "none") {
    if (xspd == 0 && yspd == 0) {
        image_index = 0;
    } else {
        image_index = ((current_time / 250) mod 3);
    }
} else {
    var anim_speed = ds_map_find_value(action_anim_speed, action_state);
    if (anim_speed > 0) {
        image_index = (action_timer * anim_speed) mod array_length(ds_map_find_value(action_frame_data, action_state));
    }
}

// Debug mode
if (global.game_state.flags.debug_mode) {
    if (keyboard_check_pressed(vk_f5)) {
        show_debug_message("Player position: " + string(x) + ", " + string(y));
        show_debug_message("Player face: " + string(face));
        show_debug_message("Player state: " + string(action_state));
    }
}

var is_sled_room = (room == rm_sled_racing);
if (is_sled_room) {
    if (instance_exists(obj_player)) {
        with (obj_player) {
            visible = false; // Hide the inventory
        }
        show_debug_message("DEBUG: Player hidden in Sled Racing room.");
    }
} else {
    if (instance_exists(obj_player)) {
        with (obj_player) {
            visible = true; // Show the inventory
        }
    }
}

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Alarm_1.gml
/// @description Reset throw cooldown
can_throw = true; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Create_0.gml
// Throwing mechanics
can_throw = true;
throw_cooldown = room_speed * 0.5; // Half second cooldown
throw_strength = 1.0;
throw_alarm = -1; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Destroy_0.gml
global.player_x = x;
global.player_y = y;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Step_0.gml
// obj_player_base Step
global.player_x = x;
global.player_y = y;

xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);
x += xspd;
y += yspd;
set_depth();

// Handle throwing
var should_throw = (can_throw && (
    keyboard_check_pressed(ord("O")) || 
    (global.expanded_hud_open && global.selected_action == "snowball")
));

if (should_throw) {
    var throw_dir;
    
    if (mouse_check_button_pressed(mb_right)) {
        // Use mouse direction if right-clicking
        throw_dir = point_direction(x, y, mouse_x, mouse_y);
    } else {
        // Use player's facing direction
        switch(face) {
            case RIGHT: throw_dir = 0; break;
            case UP_RIGHT: throw_dir = 45; break;
            case UP: throw_dir = 90; break;
            case UP_LEFT: throw_dir = 135; break;
            case LEFT: throw_dir = 180; break;
            case DOWN_LEFT: throw_dir = 225; break;
            case DOWN: throw_dir = 270; break;
            case DOWN_RIGHT: throw_dir = 315; break;
            default: throw_dir = 0; break;
        }
    }
    
    // Create snowball
    var snowball = instance_create_layer(x, y, "Instances", obj_snowball);
    with (snowball) {
        throw_object(throw_dir, other.throw_strength);
        // Set initial sprite direction based on throw direction
        image_xscale = (throw_dir > 90 && throw_dir < 270) ? -1 : 1;
    }
    
    // Start cooldown
    can_throw = false;
    alarm[1] = throw_cooldown;
    
    // Reset selected action if from inventory
    if (global.expanded_hud_open && global.selected_action == "snowball") {
        global.selected_action = "";
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_base
File: Step_2.gml
global.player_x = x;
global.player_y = y;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Create_0.gml
// Create Event
scale = 2; // General scale factor
panel_width = sprite_get_width(spr_colourpicker_panel) * scale;
panel_height = sprite_get_height(spr_colourpicker_panel) * scale;
x = (display_get_gui_width() - panel_width) / 2; // Center horizontally
y = (display_get_gui_height() - panel_height) / 2; // Center vertically
start_x = 100;   // Starting x position (overridden later)
depth = -10000;  // Ensure its drawn on top
is_destroying = false; // Flag to prevent drawing after destruction



// Define colors (unchanged)
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid positioning for color icons
icon_size = 20 * scale;  // Intended size of icons in pixels (e.g., 30 with scale 1.5)
spacing = 5 * scale;     // Spacing between icons
var cols = 5;
var rows = 3;
var grid_width = (cols * icon_size) + ((cols - 1) * spacing);
var grid_height = (rows * icon_size) + ((rows - 1) * spacing);
start_x = x + 108 * scale + (135 * scale - grid_width) / 2;
start_y = y + 35 * scale + (115 * scale - grid_height) / 2;

// Calculate icon_scale for proper sizing
var original_icon_width = sprite_get_width(sprites[0]); // Assuming all icons have the same size
icon_scale = icon_size / original_icon_width; // Scale to fit icon_size
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Draw_64.gml
// Draw GUI Event
if (is_destroying) return;

draw_sprite_ext(spr_colourpicker_panel, 0, x, y, scale, scale, 0, c_white, 1);

// Define and visualize the viewer area
var viewer_x = x + 9 * scale;
var viewer_y = y + 35 * scale;
var viewer_width = (83 - 9) * scale;
var viewer_height = (150 - 35) * scale;
draw_rectangle(viewer_x, viewer_y, viewer_x + viewer_width, viewer_y + viewer_height, true); // Outline the viewer area

// Draw player sprite with debugging
if (instance_exists(global.player_instance)) {
    var player_sprite = global.player_instance.sprite_index;
    show_debug_message("Player instance exists, sprite_index: " + string(player_sprite));
    if (player_sprite != -1) {
        var sprite_scale = min(viewer_width / sprite_get_width(player_sprite), viewer_height / sprite_get_height(player_sprite));
        var x_pos = viewer_x + viewer_width / 2 - sprite_get_xoffset(player_sprite) * sprite_scale;
        var y_pos = viewer_y + viewer_height / 2 - sprite_get_yoffset(player_sprite) * sprite_scale;
        
        // Debug output
        show_debug_message("viewer_x: " + string(viewer_x) + ", viewer_y: " + string(viewer_y));
        show_debug_message("viewer_width: " + string(viewer_width) + ", viewer_height: " + string(viewer_height));
        show_debug_message("sprite_scale: " + string(sprite_scale));
        show_debug_message("x_pos: " + string(x_pos) + ", y_pos: " + string(y_pos));
        show_debug_message("sprite origin: (" + string(sprite_get_xoffset(player_sprite)) + ", " + string(sprite_get_yoffset(player_sprite)) + ")");
        
        // Draw with test parameters
        draw_sprite_ext(player_sprite, 0, x_pos, y_pos, sprite_scale, sprite_scale, 0, c_white, 1);
    } else {
        show_debug_message("Player has no sprite assigned.");
    }
} else {
    show_debug_message("Player instance does not exist.");
}

// Draw color icons with adjusted scale
for (var i = 0; i < 15; i++) {
    var col = i mod 5;
    var row = i div 5;
    var icon_x = start_x + col * (icon_size + spacing);
    var icon_y = start_y + row * (icon_size + spacing);
    draw_sprite_ext(sprites[i], 0, icon_x, icon_y, icon_scale, icon_scale, 0, c_white, 1);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_colourpicker
File: Step_0.gml
// Step Event
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);
    
    // Close area
    if (point_in_rectangle(mx, my, x + 98 * scale, y + 1 * scale, x + 156 * scale, y + 11 * scale)) {
        is_destroying = true;
        instance_destroy();
        show_debug_message("Player color picker closed.");
        global.ui_manager.close_ui();
        global.click_handled = true;
        return;
    }
    
    // Color selection
    for (var i = 0; i < 15; i++) {
        var col = i mod 5;
        var row = i div 5;
        var icon_x = start_x + col * (icon_size + spacing);
        var icon_y = start_y + row * (icon_size + spacing);
        if (point_in_rectangle(mx, my, icon_x, icon_y, icon_x + icon_size, icon_y + icon_size)) {
            global.player_color = colors[i];
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            is_destroying = true;
            instance_destroy();
            show_debug_message("Player color set to: " + string(colors[i]));
            global.ui_manager.close_ui();
            global.click_handled = true;
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 3; // Adjust as needed for ice truck speed
state = "driving"; // Since this is the ice truck, assume driving state
if (!variable_global_exists("player_color")) { global.player_color = c_white; }

// Ice truck-specific tint
icetruck_tint = c_yellow; // Default tint for spr_icetruck_colour

// Direction
face = DOWN;

// Sprite definitions
sprite_base = spr_icetruck_base;
sprite_colour = spr_icetruck_colour;
sprite_penguin = spr_icetruck_penguin_colour;
sprite_window_tint = spr_icetruck_window
mask_index = spr_icetruck_down; // Use base sprite for collisions
sprite_index = spr_icetruck_base;

// Animation variables
image_index = 0; // Current frame
image_speed = 0.1; // Animation speed (adjust as needed)

// Frame data for driving (96x240 sprite sheet: 2 frames per direction)
frame_data = array_create(8); // Array for 8 directions
// [frame1_x, frame1_y, width, height, frame2_x, frame2_y, width, height]
frame_data[DOWN] = [0, 0, 48, 48, 48, 0, 48, 48];           // Row 1
frame_data[DOWN_RIGHT] = [0, 48, 48, 48, 48, 48, 48, 48];  // Row 2
frame_data[RIGHT] = [0, 96, 48, 48, 48, 96, 48, 48];       // Row 3
frame_data[UP_RIGHT] = [0, 144, 48, 48, 48, 144, 48, 48];  // Row 4
frame_data[UP] = [0, 192, 48, 48, 48, 192, 48, 48];        // Row 5
// Left-facing directions will use right-facing frames with flipping
frame_data[DOWN_LEFT] = frame_data[DOWN_RIGHT];
frame_data[LEFT] = frame_data[RIGHT];
frame_data[UP_LEFT] = frame_data[UP_RIGHT];

// Debugging
if (place_meeting(x, y, obj_wall)) {
    show_debug_message("Icetruck colliding with wall at position (" + string(x) + ", " + string(y) + ")");
}

show_debug_message("obj_player_icetruck: Initialized.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Draw_0.gml
var draw_x = x;
var draw_y = y;
var frame_index = floor(image_index) mod 2; // 2 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Determine if flipping is needed
var xscale = 1;
if (face == LEFT || face == DOWN_LEFT || face == UP_LEFT) {
    xscale = -1;
}

// Center the sprite
draw_x -= (frame_width / 2) * xscale;
draw_y -= frame_height / 2;

// Draw all three layers
draw_sprite_part_ext(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, icetruck_tint, 1);
draw_sprite_part_ext(sprite_penguin, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
draw_sprite_part_ext(sprite_window_tint, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Step_0.gml
// Step Event for obj_player_icetruck
// Prevent movement when paused or colour picker is open
if (global.is_pause_menu_active || instance_exists(obj_icetruck_colourpicker) || instance_exists(obj_inventory_expanded)) {
    show_debug_message("Paused or Colour Picker Open: " + string(instance_exists(obj_icetruck_colourpicker) + instance_exists(obj_inventory_expanded)));
    exit;
}

// Handle exiting the truck
if (keyboard_check_pressed(ord("E"))) {
    if (!place_meeting(x, y, obj_icetruck)) {
        var exit_x = x;
        var exit_y = y + 16;
        instance_destroy(id);
        global.player_instance = instance_create_layer(exit_x, exit_y, "Instances", obj_player);
        instance_create_layer(x, y, "Instances", obj_icetruck);
        global.current_skin = "player";
        show_debug_message("Exited ice truck. Current skin: " + global.current_skin);
    } else {
        show_debug_message("No space to exit!");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Update direction and animation
if (xspd != 0 || yspd != 0) {
    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; }
        else if (xspd > 0) { face = UP_RIGHT; }
        else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; }
        else if (xspd > 0) { face = DOWN_RIGHT; }
        else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; }
        else if (xspd < 0) { face = LEFT; }
    }
    image_speed = 0.1;
    image_index += image_speed;
    if (image_index >= 2) image_index = 0;
} else {
    image_speed = 0;
    image_index = 0;
}

// Apply collision handling
// Apply collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;
x += handle_collision("x", xspd);
y += handle_collision("y", yspd);

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Create_0.gml
// Create Event for obj_player_ninja

// Core variables
xspd = 0;
yspd = 0;
move_spd = 3;

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
ice_truck_sprite = spr_icetruck_facedown;
original_sprite = sprite_index;

// Set direction and sprites
face = DOWN;
init_sprites(spr_ninja_right, spr_ninja_up, spr_ninja_left, spr_ninja_down, spr_ninja_up_right, spr_ninja_up_left, spr_ninja_down_right, spr_ninja_down_left);

// Debugging
show_debug_message("obj_player_ninja: Initialized. Driving state: " + string(driving));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Step_0.gml
// Step Event for obj_player
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Handle interaction with NPC
if (keyboard_check_pressed(ord("E"))) {
    var target_npc = instance_nearest(x, y, obj_npc_old); // Find the nearest NPC
    if (target_npc != noone && distance_to_object(target_npc) < 48) { // Check proximity
        target_npc.current_phrase = target_npc.phrases[irandom_range(0, array_length(target_npc.phrases) - 1)]; // Pick a random phrase
        target_npc.talk_timer = fps * 3; // Show the phrase for 3 seconds
        target_npc.interact_pause = fps * 3; // Pause NPC movement for 3 seconds
        show_debug_message("Player interacted with NPC. NPC says: " + target_npc.current_phrase);
    }
}

// Handle skin switching
if (keyboard_check_pressed(ord("E"))) {
    if (distance_to_object(obj_icetruck) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "icetruck" : "player");
    } else if (distance_to_object(obj_tube) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "tube" : "player");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Get xspd & yspd
if (!sliding) {
    xspd = (right_key - left_key) * move_spd;
    yspd = (down_key - up_key) * move_spd;
} else {
    // Continue sliding
    xspd = slide_dir_x * slide_speed;
    yspd = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        xspd = 0;
        yspd = 0;
    }
}

// Pause
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Set sprite
mask_index = sprite[DOWN];
if (yspd < 0) {
    if (xspd < 0) { face = UP_LEFT; }
    else if (xspd > 0) { face = UP_RIGHT; }
    else { face = UP; }
} else if (yspd > 0) {
    if (xspd < 0) { face = DOWN_LEFT; }
    else if (xspd > 0) { face = DOWN_RIGHT; }
    else { face = DOWN; }
} else {
    if (xspd > 0) { face = RIGHT; }
    else if (xspd < 0) { face = LEFT; }
}

sprite_index = sprite[face];

// Collisions
xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);

// Move the player
x += xspd;
y += yspd;

// Animate
if (xspd == 0 && yspd == 0) {
    image_index = 0;
}

// Depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Create_0.gml
xspd = 0;
yspd = 0;
move_spd = 1.5; // Same as tube, adjust if desired
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];
toboggan_sprites[UP] = [24, 0];
toboggan_sprites[DOWN_RIGHT] = [48, 0];
toboggan_sprites[UP_LEFT] = [72, 0];
toboggan_sprites[LEFT] = [96, 0];
toboggan_sprites[RIGHT] = [120, 0];
toboggan_sprites[UP_RIGHT] = [144, 0];
toboggan_sprites[DOWN_LEFT] = [168, 0];

mask_index = spr_tube_down; // Create this sprite if not already present
sprite_index = spr_toboggan_sheet;
global.player_instance = id;
global.current_skin = "Toboggan";
show_debug_message("obj_player_toboggan: Initialized. Player instance ID: " + string(id));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Draw_0.gml
// Draw toboggan
var toboggan_x = toboggan_sprites[face][0];
var toboggan_y = toboggan_sprites[face][1];
draw_sprite_part(spr_toboggan_sheet, 0, toboggan_x, toboggan_y, 24, 24, x - 12, y - 12);

// Draw player sitting (reusing tube positions)
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];
var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, global.player_color, 1);

// Draw equipped head item with debug logging
if (ds_exists(global.equipped_items, ds_type_map)) {
    var head_item = global.equipped_items[? "head"];
    if (!is_undefined(head_item) && head_item != -1) {
        // Code to draw head item, e.g., using global.item_player_sprites
        var sprite = ds_map_find_value(global.item_player_sprites, head_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, 0, x, y - 12); // Adjust as needed
        }
    }
} else {
    show_debug_message("global.equipped_items is not a ds_map");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Step_0.gml
if (global.is_pause_menu_active) exit;

// Exit toboggan
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "toboggan" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Toboggan");
        show_debug_message("Exiting toboggan, switching back to player...");
        var old_instance = id;
        obj_controller.switch_skin("player");
        if (instance_exists(old_instance)) instance_destroy(old_instance);
    }
}

// Movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);
xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Pause check
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update direction
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Depth sorting
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Create_0.gml
// Create Event for obj_player_tube

// Core variables
xspd = 0;
yspd = 0;
move_spd = 1.5;
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;

// Set direction
face = DOWN;

// Define sprite positions for the tube
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        
tube_sprites[LEFT] = [0, 0];      
tube_sprites[DOWN] = [24, 0];     
tube_sprites[RIGHT] = [24, 0];    
tube_sprites[UP_LEFT] = [48, 0];  
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; 
tube_sprites[UP_RIGHT] = [72, 0];

// Ensure a valid face direction
if (!array_length(tube_sprites[face])) {
    face = DOWN; // Default if invalid
}

mask_index = spr_tube_down; // Ensure collision works

// Set global player instance
global.player_instance = id;
global.current_skin = "tube";
sprite_index = spr_tube_sheet;
is_savable = true;

// Debugging
show_debug_message("obj_player_tube: Initialized. Player instance ID: " + string(id));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];

// Draw player sitting
draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x, y, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x, y, 1, 1, global.player_color, 1);

// Draw equipped head item with debug logging
if (ds_exists(global.equipped_items, ds_type_map)) {
    var head_item = global.equipped_items[? "head"];
    if (!is_undefined(head_item) && head_item != -1) {
        // Code to draw head item, e.g., using global.item_player_sprites
        var sprite = ds_map_find_value(global.item_player_sprites, head_item);
        if (!is_undefined(sprite)) {
            draw_sprite(sprite, 0, x, y - 12); // Adjust as needed
        }
    }
} else {
    show_debug_message("global.equipped_items is not a ds_map");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Step_0.gml
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Exit the tube
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "tube" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Tube");
        show_debug_message("Exiting tube, switching back to player...");
        var old_instance = id; // Store old instance ID
        obj_controller.switch_skin("player");
        // Destroy old instance only after switching
        if (instance_exists(old_instance)) {
            instance_destroy(old_instance);
        }
    }
}


// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Disable movement if the game is paused
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update tube direction and sprite only if moving
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Ensure proper depth sorting
set_depth();

var is_sled_room = (room == rm_sled_racing);
if (is_sled_room) {
    if (instance_exists(obj_player_tube)) {
        with (obj_player_tube) {
            visible = false; // Hide the inventory
        }
        show_debug_message("DEBUG: Player Tube hidden in Sled Racing room.");
    }
} else {
    if (instance_exists(obj_player_tube)) {
        with (obj_player_tube) {
            visible = true; // Show the inventory
        }
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_plaza_complete
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Create_0.gml
/// @description Initialize puffle

// Initialize from game state if available
if (variable_global_exists("game_state")) {
    with(global.game_state) {
        var puffle_data = get_puffle_data(other.id);
        if (puffle_data != undefined) {
            other.state = puffle_data.state;
            other.color = puffle_data.color;
            other.happiness = puffle_data.happiness;
            other.energy = puffle_data.energy;
            other.hunger = puffle_data.hunger;
            other.following_player = puffle_data.following_player;
            other.tricks_known = puffle_data.tricks_known;
        } else {
            // New puffle initialization
            other.initialize_new_puffle();
        }
    }
} else {
    // Fallback initialization
    initialize_new_puffle();
}

// Core variables
xspd = 0;
yspd = 0;
move_spd = 1;
face = DOWN;

// Define puffle states
enum PuffleState {
    IDLE,
    FOLLOWING,
    EATING,
    SLEEPING,
    PLAYING,
    PERFORMING_TRICK
}

// Initialize state if not set
if (!variable_instance_exists(id, "state")) {
    state = PuffleState.IDLE;
}

// Movement and behavior variables
target_x = x;
target_y = y;
idle_timer = 0;
idle_duration = irandom_range(180, 300);
path_update_timer = 0;
path_update_frequency = 30;

// Stats (if not already set by game state)
if (!variable_instance_exists(id, "happiness")) happiness = 100;
if (!variable_instance_exists(id, "energy")) energy = 100;
if (!variable_instance_exists(id, "hunger")) hunger = 0;

// Animation variables
sprite_index = spr_puffle;
image_speed = 0;
bounce_offset = 0;
bounce_speed = 0.1;
bounce_height = 4;

// Trick system
if (!variable_instance_exists(id, "tricks_known")) tricks_known = ds_list_create();
current_trick = "";
trick_timer = 0;

// Function to initialize a new puffle
function initialize_new_puffle() {
    state = PuffleState.IDLE;
    color = choose(c_blue, c_red, c_pink, c_black, c_green, c_yellow);
    happiness = 100;
    energy = 100;
    hunger = 0;
    following_player = false;
    tricks_known = ds_list_create();
    
    // Register with resource manager
    with(global.resource_manager) {
        var following_puffles = get_structure("following_puffles");
        if (following_puffles != undefined) {
            ds_list_add(following_puffles, other.id);
        }
    }
}

// Function to learn a new trick
function learn_trick(trick_name) {
    if (ds_list_find_index(tricks_known, trick_name) == -1) {
        ds_list_add(tricks_known, trick_name);
        show_debug_message("Puffle learned new trick: " + trick_name);
        return true;
    }
    return false;
}

// Function to perform a trick
function perform_trick(trick_name) {
    if (ds_list_find_index(tricks_known, trick_name) != -1) {
        current_trick = trick_name;
        state = PuffleState.PERFORMING_TRICK;
        trick_timer = 0;
        show_debug_message("Puffle performing trick: " + trick_name);
        return true;
    }
    return false;
}

// Register with game state
with(global.game_state) {
    register_puffle(other.id, {
        state: other.state,
        color: other.color,
        happiness: other.happiness,
        energy: other.energy,
        hunger: other.hunger,
        following_player: other.following_player,
        tricks_known: ds_list_to_array(other.tricks_known)
    });
}

show_debug_message("Puffle initialized with new state system");

// Movement variables
xspd = 0;
yspd = 0;
move_spd = 2;
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
direction_timer = 120; // Change direction every 2 seconds at 60 FPS

// Animation variables
face = DOWN;
image_index = 0;
image_speed = 0.1;

// AI State System
enum PuffleState {
    IDLE,
    FOLLOWING,
    PLAYING,
    EATING,
    SLEEPING,    // New state
    DANCING,     // New state
    EXPLORING,   // New state
    INTERACTING  // New state
}
state = PuffleState.IDLE; // Start in IDLE for testing
idle_timer = 0;
follow_distance = 32;
is_savable = true;
persistent = false;
color = "white";
following_player = false;
player_idle_timer = 0; // Timer for player inactivity

// Eating timer
eating_timer = 0;

// Ensure collision mask
sprite_index = spr_puffle; // Set sprite for collision detection

/// Set Random Puffle Color
var color_variations = [
    make_color_rgb(255, 0, 0),    // Red
    make_color_rgb(0, 0, 255),    // Blue
    make_color_rgb(0, 255, 0),    // Green
    make_color_rgb(255, 255, 0),  // Yellow
    make_color_rgb(128, 0, 128),  // Purple
    make_color_rgb(255, 192, 203),// Pink
    make_color_rgb(255, 165, 0),  // Orange
    make_color_rgb(255, 255, 255) // White
];

// Correct way to select a random color
image_blend = color_variations[irandom(array_length(color_variations) - 1)];

prev_face = face; // Add this line

// Puffle Stats
happiness = 100;
energy = 100;
hunger = 100;
health = 100;
affection = 0;
experience = 0;
level = 1;

// Personality Traits (affects behavior)
personality = {
    playfulness: random_range(0.5, 1.0),
    independence: random_range(0.3, 1.0),
    sociability: random_range(0.4, 1.0),
    energy_level: random_range(0.6, 1.0)
}

// Behavior Timers
sleep_timer = 0;
play_timer = 0;
dance_timer = 0;
interaction_cooldown = 0;

// Behavior Thresholds
hunger_threshold = 30;
energy_threshold = 20;
happiness_threshold = 40;

// Unique Traits based on color
switch(irandom(array_length(color_variations) - 1)) {
    case 0: // Red
        personality.playfulness += 0.2;
        break;
    case 1: // Blue
        personality.independence += 0.2;
        break;
    case 2: // Green
        health += 20;
        break;
    case 3: // Yellow
        happiness += 20;
        break;
    case 4: // Purple
        experience += 50;
        break;
    case 5: // Pink
        affection += 10;
        break;
    case 6: // Orange
        energy += 20;
        break;
    case 7: // White
        personality.sociability += 0.2;
        break;
}

// Initialize behavior flags
can_dance = true;
is_tired = false;
is_hungry = false;
wants_to_play = false;

// Special abilities (unlocked at certain levels)
abilities = {
    can_swim: false,
    can_fly: false,
    can_dig: false,
    special_dance: false
}

// Achievement tracking
achievements = {
    times_fed: 0,
    play_sessions: 0,
    distance_traveled: 0,
    tricks_performed: 0
}

// Path finding variables
path = path_add();
path_found = false;
path_timer = 0;

// Initialize emote system
emote_sprite = -1;
emote_timer = 0;
emote_duration = 60;

// Initialize tricks list
known_tricks = ds_list_create();
trick_cooldown = 0;

// Add basic tricks based on color
switch(irandom(array_length(color_variations) - 1)) {
    case 0: ds_list_add(known_tricks, "backflip"); break;
    case 1: ds_list_add(known_tricks, "spin"); break;
    case 2: ds_list_add(known_tricks, "roll"); break;
    case 3: ds_list_add(known_tricks, "jump"); break;
    case 4: ds_list_add(known_tricks, "wave"); break;
    case 5: ds_list_add(known_tricks, "dance"); break;
    case 6: ds_list_add(known_tricks, "bounce"); break;
    case 7: ds_list_add(known_tricks, "twirl"); break;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Draw_0.gml
// Get sprite data for current face direction
var sprite_data = get_puffle_sprite_data(face);
var base_subimage = sprite_data[0];
var xscale = sprite_data[1];
var anim_frame = floor(image_index) % 8;
var final_subimage = base_subimage + anim_frame;

var col = final_subimage % 8;
var row = floor(final_subimage / 8);
var left = col * 24;
var top = row * 24;

// Adjust draw_x based on xscale to center the sprite
var draw_x = x - (12 * xscale);
var draw_y = y - 12;

// Apply state-specific visual effects
switch(state) {
    case PuffleState.SLEEPING:
        // Draw "Z" particles above sleeping puffle
        if (current_time % 60 < 30) {
            draw_sprite(spr_sleep_z, 0, x + 8, y - 16);
        }
        break;
        
    case PuffleState.DANCING:
        // Add subtle bounce effect
        draw_y -= abs(sin(current_time / 200)) * 4;
        // Add color cycling for special dance
        if (abilities.special_dance) {
            draw_set_color(make_color_hsv((current_time / 10) % 255, 255, 255));
            draw_circle(x, y, 16 + sin(current_time / 100) * 4, false);
        }
        break;
        
    case PuffleState.PLAYING:
        // Add playful bounce
        draw_y -= abs(sin(current_time / 150)) * 2;
        break;
}

// Draw puffle with any active effects
if (state == PuffleState.EATING) {
    // Add eating animation effect
    draw_sprite_part_ext(spr_puffle_walk, 0, left, top, 24, 24, 
                        draw_x + random_range(-1, 1),
                        draw_y + random_range(-1, 1),
                        xscale, 1, image_blend, 1);
} else {
    draw_sprite_part_ext(spr_puffle_walk, 0, left, top, 24, 24,
                        draw_x, draw_y, xscale, 1, image_blend, 1);
}

// Draw emote if active
if (emote_sprite != -1 && emote_timer > 0) {
    var emote_y_offset = -20 + sin(current_time / 500) * 2; // Floating effect
    draw_sprite(emote_sprite, 0, x, y + emote_y_offset);
}

// Draw level-up effect if applicable
if (emote_sprite == spr_levelup && emote_timer > 0) {
    draw_set_color(c_yellow);
    draw_set_alpha(emote_timer / emote_duration);
    draw_circle(x, y, 20 + (emote_duration - emote_timer) / 2, true);
    draw_set_alpha(1);
}

// Draw status indicators when close to player
if (distance_to_object(global.player_instance) < 48) {
    var bar_width = 24;
    var bar_height = 3;
    var bar_y = y - 24;
    var bar_spacing = 4;
    
    // Draw hunger bar
    draw_healthbar(x - bar_width/2, bar_y,
                  x + bar_width/2, bar_y + bar_height,
                  hunger, c_black, c_red, c_lime,
                  0, true, true);
    
    // Draw energy bar
    draw_healthbar(x - bar_width/2, bar_y + bar_spacing,
                  x + bar_width/2, bar_y + bar_spacing + bar_height,
                  energy, c_black, c_blue, c_aqua,
                  0, true, true);
    
    // Draw happiness bar
    draw_healthbar(x - bar_width/2, bar_y + bar_spacing * 2,
                  x + bar_width/2, bar_y + bar_spacing * 2 + bar_height,
                  happiness, c_black, c_purple, c_yellow,
                  0, true, true);
}

// Draw debug info if debug mode is active
if (global.debug_mode) {
    draw_set_color(c_white);
    draw_set_alpha(0.7);
    draw_text(x - 30, y + 20, "State: " + string(state));
    draw_text(x - 30, y + 30, "Level: " + string(level));
    draw_set_alpha(1);
}

// Reset draw properties
draw_set_color(c_white);
draw_set_alpha(1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Other_4.gml
// Room Start Event for obj_puffle
if (following_player && variable_global_exists("player_instance") && instance_exists(global.player_instance)) {
    // Position puffle 16 pixels offset from player based on player's facing direction
    var offset_dist = 16;
    var offset_dir;
    switch (global.player_instance.face) {
        case RIGHT: offset_dir = 0; break;
        case LEFT: offset_dir = 180; break;
        case UP: offset_dir = 90; break;
        case DOWN: offset_dir = 270; break;
        default: offset_dir = 270; // Default to below player
    }
    x = global.player_instance.x + lengthdir_x(offset_dist, offset_dir);
    y = global.player_instance.y + lengthdir_y(offset_dist, offset_dir);

    // Prevent overlap with walls
    if (place_meeting(x, y, obj_wall)) {
        x = global.player_instance.x;
        y = global.player_instance.y;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Step_0.gml
/// @description Handle puffle behavior

// Exit if paused
if (global.is_pause_menu_active) exit;

// Ensure player_instance is valid
if (!instance_exists(global.player_instance)) {
    global.player_instance = instance_find(obj_player, 0);
    if (!instance_exists(global.player_instance)) {
        show_debug_message("Warning: No player instance found!");
        exit;
    }
}

// Update stats over time
if (state != PuffleState.SLEEPING) {
    hunger -= 0.02;
    energy -= 0.03 * personality.energy_level;
    happiness -= 0.01 * (2 - personality.playfulness);
}

// Clamp stats
hunger = clamp(hunger, 0, 100);
energy = clamp(energy, 0, 100);
happiness = clamp(happiness, 0, 100);
health = clamp(health, 0, 100);

// Update status flags
is_hungry = (hunger <= hunger_threshold);
is_tired = (energy <= energy_threshold);
wants_to_play = (happiness <= happiness_threshold);

// Experience and leveling system
if (experience >= 100 * level) {
    level++;
    experience -= 100 * (level - 1);
    // Unlock abilities based on level
    switch(level) {
        case 3: abilities.can_swim = true; break;
        case 5: abilities.can_dig = true; break;
        case 7: abilities.can_fly = true; break;
        case 10: abilities.special_dance = true; break;
    }
    // Show level up effect
    emote_sprite = spr_levelup;
    emote_timer = emote_duration;
}

// Handle interaction cooldown
if (interaction_cooldown > 0) interaction_cooldown--;

// Player interaction: Feeding the puffle
if (distance_to_object(global.player_instance) < 24 && keyboard_check_pressed(ord("E"))) {
    if (!following_player) {
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            state = PuffleState.EATING;
            var dir_to_player = point_direction(x, y, global.player_instance.x, global.player_instance.y);
            var angle = round(dir_to_player / 45) % 8;
            var face_map = [RIGHT, UP_RIGHT, UP, UP_LEFT, LEFT, DOWN_LEFT, DOWN, DOWN_RIGHT];
            face = face_map[angle];
            eating_timer = 60;
            if (obj_inventory.has_item("Puffle O")) {
                obj_inventory.remove_item("Puffle O");
                hunger += 30;
            } else {
                obj_inventory.remove_item("Box Puffle O");
                hunger += 50;
            }
            achievements.times_fed++;
            affection += 5;
            show_debug_message("Puffle is eating.");
        }
    }
}

// Trick system
if (keyboard_check_pressed(ord("T")) && following_player && trick_cooldown <= 0) {
    if (ds_list_size(known_tricks) > 0) {
        var trick = known_tricks[| irandom(ds_list_size(known_tricks) - 1)];
        perform_trick(trick);
        trick_cooldown = 180;
        happiness += 10;
        experience += 5;
        achievements.tricks_performed++;
    }
}

// Handle state-specific behavior
switch(state) {
    case PuffleState.IDLE:
        xspd = 0;
        yspd = 0;
        idle_timer += 1;
        
        // Check for state transitions
        if (is_hungry && following_player) {
            show_emote("hungry");
        }
        if (is_tired) {
            state = PuffleState.SLEEPING;
            show_emote("sleepy");
            break;
        }
        if (wants_to_play && random(1) < personality.playfulness) {
            state = PuffleState.PLAYING;
            show_emote("happy");
            break;
        }
        
        // Idle behaviors
        if (idle_timer >= 120) {
            var idle_behavior = choose("bounce", "roll", "look_around", "dance");
            switch(idle_behavior) {
                case "bounce":
                    y -= 2;
                    alarm[0] = 5;
                    break;
                case "roll":
                    image_angle += choose(-5, 5);
                    break;
                case "look_around":
                    face = choose(RIGHT, LEFT, UP, DOWN);
                    break;
                case "dance":
                    if (can_dance) {
                        state = PuffleState.DANCING;
                        dance_timer = 120;
                    }
                    break;
            }
            idle_timer = 0;
        }
        break;

    case PuffleState.PLAYING:
        if (energy < 20) {
            state = PuffleState.SLEEPING;
            show_emote("sleepy");
            break;
        }
        
        if (direction_timer <= 0 || place_meeting(x + xspd, y, obj_wall) || place_meeting(x, y + yspd, obj_wall)) {
            direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
            direction_timer = 120;
        }
        xspd = lengthdir_x(move_spd * personality.energy_level, direction);
        yspd = lengthdir_y(move_spd * personality.energy_level, direction);
        direction_timer -= 1;
        
        // Random tricks while playing
        if (random(1) < 0.01) {
            perform_trick(known_tricks[| irandom(ds_list_size(known_tricks) - 1)]);
        }
        
        happiness += 0.05;
        energy -= 0.05;
        break;

    case PuffleState.FOLLOWING:
        if (instance_exists(global.player_instance)) {
            // Target position calculation with personality influence
            var base_dist = 24 * (2 - personality.independence);
            var offset_dir = (global.player_instance.face + 180) % 360;
            var random_offset = irandom_range(-8, 8) * personality.playfulness;
            var target_x = global.player_instance.x + lengthdir_x(base_dist, offset_dir) + random_offset;
            var target_y = global.player_instance.y + lengthdir_y(base_dist, offset_dir) + random_offset;
            var dist = point_distance(x, y, target_x, target_y);

            if (dist > 12) {
                var dir = point_direction(x, y, target_x, target_y);
                var move_x = lengthdir_x(move_spd, dir);
                var move_y = lengthdir_y(move_spd, dir);
                xspd = lerp(xspd, move_x, 0.15);
                yspd = lerp(yspd, move_y, 0.15);
                
                // Update distance traveled
                achievements.distance_traveled += point_distance(0, 0, xspd, yspd) / room_speed;
            } else {
                xspd = lerp(xspd, 0, 0.3);
                yspd = lerp(yspd, 0, 0.3);
            }

            // State transitions
            if (is_tired) {
                state = PuffleState.SLEEPING;
                show_emote("sleepy");
            } else if (is_hungry) {
                show_emote("hungry");
            }

            // Check if player is stationary
            if (point_distance(0, 0, global.player_instance.xspd, global.player_instance.yspd) < 0.1) {
                player_idle_timer += 1;
                if (player_idle_timer >= 180) {
                    if (random(1) < personality.independence) {
                        state = PuffleState.EXPLORING;
                    } else {
                        state = PuffleState.IDLE;
                    }
                    player_idle_timer = 0;
                }
            } else {
                player_idle_timer = 0;
            }
        }
        break;

    case PuffleState.EATING:
        xspd = 0;
        yspd = 0;
        if (eating_timer > 0) {
            eating_timer -= 1;
        } else {
            state = PuffleState.FOLLOWING;
            following_player = true;
            persistent = true;
            ds_list_add(global.following_puffles, id);
            show_emote("happy");
        }
        break;

    case PuffleState.SLEEPING:
        xspd = 0;
        yspd = 0;
        sleep_timer++;
        energy += 0.1;
        if (energy >= 100 || sleep_timer >= 300) {
            state = following_player ? PuffleState.FOLLOWING : PuffleState.IDLE;
            sleep_timer = 0;
            show_emote("wake");
        }
        break;

    case PuffleState.DANCING:
        xspd = 0;
        yspd = 0;
        dance_timer--;
        happiness += 0.1;
        if (dance_timer <= 0 || energy < 20) {
            state = following_player ? PuffleState.FOLLOWING : PuffleState.IDLE;
        }
        break;

    case PuffleState.EXPLORING:
        if (path_timer <= 0 || place_meeting(x + xspd, y, obj_wall) || place_meeting(x, y + yspd, obj_wall)) {
            var target_x = x + irandom_range(-100, 100);
            var target_y = y + irandom_range(-100, 100);
            
            // Keep within reasonable distance of player
            var max_dist = 200;
            var dist_to_player = point_distance(target_x, target_y, global.player_instance.x, global.player_instance.y);
            if (dist_to_player > max_dist) {
                var angle = point_direction(global.player_instance.x, global.player_instance.y, target_x, target_y);
                target_x = global.player_instance.x + lengthdir_x(max_dist, angle);
                target_y = global.player_instance.y + lengthdir_y(max_dist, angle);
            }
            
            path_timer = 180;
            if (mp_grid_path(global.navigation_grid, path, x, y, target_x, target_y, true)) {
                path_start(path, move_spd * personality.energy_level, path_action_stop, false);
                path_found = true;
            }
        }
        path_timer--;
        
        // Return to following if player moves too far
        if (distance_to_object(global.player_instance) > 250) {
            state = PuffleState.FOLLOWING;
            path_end();
        }
        break;

    case PuffleState.INTERACTING:
        // Handle interactions with other puffles or objects
        break;
}

// Collision Handling with Obstacle Avoidance
var old_x = x;
var old_y = y;
x += xspd;
if (place_meeting(x, y, obj_wall)) {
    x = old_x;
    y += yspd;
    if (place_meeting(x, y, obj_wall)) {
        y = old_y;
        var slide_dir = point_direction(x, y, global.player_instance.x, global.player_instance.y) + choose(-90, 90);
        xspd = lengthdir_x(move_spd * 0.5, slide_dir);
        yspd = lengthdir_y(move_spd * 0.5, slide_dir);
    } else {
        xspd = lerp(xspd, 0, 0.2);
    }
} else {
    y += yspd;
    if (place_meeting(x, y, obj_wall)) {
        y = old_y;
        xspd = lerp(xspd, 0, 0.2);
    }
}

// Update emote timer
if (emote_timer > 0) {
    emote_timer--;
    if (emote_timer <= 0) {
        emote_sprite = -1;
    }
}

// Animation Handling
if (xspd != 0 || yspd != 0) {
    var angle = point_direction(0, 0, xspd, yspd);
    var dir_index = round(angle / 45) % 8;
    var face_map = [RIGHT, UP_RIGHT, UP, UP_LEFT, LEFT, DOWN_LEFT, DOWN, DOWN_RIGHT];
    var new_face = face_map[dir_index];
    if (new_face != prev_face) {
        image_index = 0;
        prev_face = new_face;
    }
    face = new_face;
    image_speed = 0.15;
} else {
    image_speed = 0;
}
image_index += image_speed;

// Update trick cooldown
if (trick_cooldown > 0) trick_cooldown--;

// Update game state
with(global.game_state) {
    update_puffle_data(other.id, {
        state: other.state,
        color: other.color,
        happiness: other.happiness,
        energy: other.energy,
        hunger: other.hunger,
        following_player: other.following_player,
        tricks_known: ds_list_to_array(other.tricks_known)
    });
}

// Debug mode
if (global.game_state.flags.debug_mode && keyboard_check_pressed(vk_f6)) {
    show_debug_message("Puffle state: " + string(state));
    show_debug_message("Happiness: " + string(happiness));
    show_debug_message("Energy: " + string(energy));
    show_debug_message("Hunger: " + string(hunger));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffleo_item
File: Create_0.gml
event_inherited();
item_name = "Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pufflewhistle_item
File: Create_0.gml
event_inherited();
item_name = "Puffle Whistle";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_quest_journal
File: Create_0.gml
/// @description Initialize quest journal

// Journal state
visible = false;
selected_quest = -1;
scroll_offset = 0;
max_scroll = 0;

// UI settings
margin = 40;
padding = 20;
quest_item_height = 60;
quest_item_spacing = 10;
scroll_speed = 20;
scroll_bar_width = 8;

// Tab settings
tabs = ["Active", "Completed", "Failed"];
selected_tab = 0;
tab_height = 40;
tab_padding = 10;

// Filter settings
show_main_quests = true;
show_side_quests = true;
sort_by_level = false;

// Animation settings
animation_state = 0; // 0 = closed, 1 = open
animation_speed = 0.1;
animation_progress = 0;

/// @function toggle_journal()
toggle_journal = function() {
    visible = !visible;
    if (visible) {
        animation_state = 0;
        animation_progress = 0;
        update_quest_list();
    }
}

/// @function update_quest_list()
update_quest_list = function() {
    var all_quests = [];
    var quest_source;
    
    // Get quests based on selected tab
    switch(tabs[selected_tab]) {
        case "Active":
            quest_source = global.quest_system.get_active_quests();
            break;
        case "Completed":
            quest_source = global.quest_system.get_completed_quests();
            break;
        case "Failed":
            quest_source = global.quest_system.get_failed_quests();
            break;
    }
    
    // Filter and sort quests
    for (var i = 0; i < array_length(quest_source); i++) {
        var quest = quest_source[i];
        
        // Apply filters
        if (!show_main_quests && quest.is_main_quest) continue;
        if (!show_side_quests && !quest.is_main_quest) continue;
        
        array_push(all_quests, quest);
    }
    
    // Sort quests
    if (sort_by_level) {
        array_sort(all_quests, function(a, b) {
            return a.min_level - b.min_level;
        });
    } else {
        array_sort(all_quests, function(a, b) {
            return a.is_main_quest == b.is_main_quest ? 0 : (a.is_main_quest ? -1 : 1);
        });
    }
    
    // Update quest list and scroll limits
    quest_list = all_quests;
    max_scroll = max(0, array_length(quest_list) * (quest_item_height + quest_item_spacing) - 
        (window_get_height() - margin * 2 - tab_height - padding * 2));
    scroll_offset = min(scroll_offset, max_scroll);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_quest_journal
File: Draw_64.gml
/// @description Draw quest journal UI

if (!visible) exit;

// Calculate dimensions with animation
var window_width = window_get_width();
var window_height = window_get_height();
var journal_width = window_width - margin * 2;
var journal_height = window_height - margin * 2;
var animated_width = journal_width * animation_progress;
var animated_height = journal_height * animation_progress;

// Draw background
draw_set_alpha(0.95 * animation_progress);
draw_set_color(c_black);
draw_rectangle(
    margin, margin,
    margin + animated_width,
    margin + animated_height,
    false
);

if (animation_state == 0) {
    draw_set_alpha(1);
    return;
}

// Draw border
draw_set_alpha(animation_progress);
draw_set_color(c_white);
draw_rectangle(
    margin, margin,
    margin + journal_width,
    margin + journal_height,
    true
);

// Draw tabs
var tab_width = (journal_width - padding * 2) / array_length(tabs);
for (var i = 0; i < array_length(tabs); i++) {
    var tab_x = margin + padding + (tab_width * i);
    var is_selected = (i == selected_tab);
    
    // Draw tab background
    draw_set_color(is_selected ? c_dkgray : c_black);
    draw_rectangle(
        tab_x, margin,
        tab_x + tab_width - 1, margin + tab_height,
        false
    );
    
    // Draw tab border
    draw_set_color(c_white);
    draw_rectangle(
        tab_x, margin,
        tab_x + tab_width - 1, margin + tab_height,
        true
    );
    
    // Draw tab text
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_font(fnt_quest);
    draw_text(
        tab_x + tab_width/2,
        margin + tab_height/2,
        tabs[i] + " (" + string(array_length(quest_list)) + ")"
    );
}

// Draw content area
var content_y = margin + tab_height;
var content_height = journal_height - tab_height;
draw_set_color(c_dkgray);
draw_rectangle(
    margin, content_y,
    margin + journal_width,
    margin + journal_height,
    false
);

// Set up clipping region for quest list
draw_set_color(c_white);
draw_set_font(fnt_quest);
draw_set_halign(fa_left);
draw_set_valign(fa_top);

// Draw quests
for (var i = 0; i < array_length(quest_list); i++) {
    var quest = quest_list[i];
    var quest_y = content_y + (i * (quest_item_height + quest_item_spacing)) - scroll_offset;
    
    // Skip if outside visible area
    if (quest_y + quest_item_height < content_y || quest_y > content_y + content_height) continue;
    
    // Draw quest item background
    var is_selected = (i == selected_quest);
    draw_set_color(is_selected ? c_navy : (quest.is_main_quest ? c_maroon : c_dkgray));
    draw_rectangle(
        margin + padding, quest_y,
        margin + journal_width - padding - scroll_bar_width,
        quest_y + quest_item_height,
        false
    );
    
    // Draw quest item border
    draw_set_color(c_white);
    draw_rectangle(
        margin + padding, quest_y,
        margin + journal_width - padding - scroll_bar_width,
        quest_y + quest_item_height,
        true
    );
    
    // Draw quest title
    draw_set_color(quest.is_main_quest ? c_yellow : c_white);
    draw_text(
        margin + padding * 2,
        quest_y + padding,
        quest.title + (quest.min_level > 1 ? " (Level " + string(quest.min_level) + ")" : "")
    );
    
    // Draw quest description or objectives based on selection
    if (is_selected) {
        // Draw objectives
        var obj_y = quest_y + padding + string_height(quest.title) + 5;
        for (var j = 0; j < array_length(quest.objectives); j++) {
            var objective = quest.objectives[j];
            var progress = quest.progress[j];
            var is_complete = progress >= objective.required_amount;
            
            draw_set_color(is_complete ? c_lime : c_white);
            draw_text(
                margin + padding * 3,
                obj_y,
                " " + objective.description + 
                (objective.required_amount > 1 ? 
                    " (" + string(progress) + "/" + string(objective.required_amount) + ")" : 
                    "")
            );
            
            obj_y += string_height(objective.description) + 5;
        }
    } else {
        // Draw description
        draw_set_color(c_gray);
        draw_text_ext(
            margin + padding * 2,
            quest_y + padding + string_height(quest.title) + 5,
            quest.description,
            -1,
            journal_width - padding * 4 - scroll_bar_width
        );
    }
}

// Draw scroll bar if needed
if (max_scroll > 0) {
    var scroll_height = journal_height - tab_height;
    var scroll_thumb_height = (scroll_height / (array_length(quest_list) * (quest_item_height + quest_item_spacing))) * scroll_height;
    var scroll_thumb_y = content_y + (scroll_offset / max_scroll) * (scroll_height - scroll_thumb_height);
    
    // Draw scroll bar background
    draw_set_color(c_black);
    draw_rectangle(
        margin + journal_width - scroll_bar_width,
        content_y,
        margin + journal_width,
        margin + journal_height,
        false
    );
    
    // Draw scroll thumb
    draw_set_color(c_white);
    draw_rectangle(
        margin + journal_width - scroll_bar_width,
        scroll_thumb_y,
        margin + journal_width,
        scroll_thumb_y + scroll_thumb_height,
        false
    );
}

// Draw filter indicators
var filter_x = margin + padding;
var filter_y = margin + journal_height - 25;
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_bottom);
draw_text(filter_x, filter_y, 
    "[M] Main Quests: " + (show_main_quests ? "ON" : "OFF") + 
    " | [S] Side Quests: " + (show_side_quests ? "ON" : "OFF") + 
    " | [L] Sort by Level: " + (sort_by_level ? "ON" : "OFF")
);

// Reset drawing properties
draw_set_alpha(1);
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_quest_journal
File: Step_0.gml
/// @description Handle input and animations

// Toggle journal visibility
if (keyboard_check_pressed(ord("J"))) {
    toggle_journal();
}

if (!visible) exit;

// Handle animation
if (animation_state == 0) {
    animation_progress = min(1, animation_progress + animation_speed);
    if (animation_progress >= 1) {
        animation_state = 1;
    }
} else if (!visible) {
    animation_progress = max(0, animation_progress - animation_speed);
    if (animation_progress <= 0) {
        animation_state = 0;
    }
}

// Get mouse position
var mouse_x_gui = device_mouse_x_to_gui(0);
var mouse_y_gui = device_mouse_y_to_gui(0);

// Calculate UI areas
var window_width = window_get_width();
var window_height = window_get_height();
var journal_width = window_width - margin * 2;
var journal_height = window_height - margin * 2;
var content_y = margin + tab_height;
var content_height = journal_height - tab_height;

// Handle tab selection
if (mouse_y_gui >= margin && mouse_y_gui <= margin + tab_height) {
    var tab_width = (journal_width - padding * 2) / array_length(tabs);
    for (var i = 0; i < array_length(tabs); i++) {
        var tab_x = margin + padding + (tab_width * i);
        if (mouse_x_gui >= tab_x && mouse_x_gui < tab_x + tab_width) {
            if (mouse_check_button_pressed(mb_left)) {
                selected_tab = i;
                update_quest_list();
                selected_quest = -1;
            }
            break;
        }
    }
}

// Handle scrolling
if (point_in_rectangle(mouse_x_gui, mouse_y_gui, 
    margin, content_y, 
    margin + journal_width - scroll_bar_width, margin + journal_height)) {
    
    // Mouse wheel scrolling
    var wheel = mouse_wheel_down() - mouse_wheel_up();
    if (wheel != 0) {
        scroll_offset = clamp(scroll_offset + wheel * scroll_speed, 0, max_scroll);
    }
    
    // Quest selection
    if (mouse_check_button_pressed(mb_left)) {
        var local_y = mouse_y_gui - content_y + scroll_offset;
        var quest_index = floor(local_y / (quest_item_height + quest_item_spacing));
        
        if (quest_index >= 0 && quest_index < array_length(quest_list)) {
            selected_quest = (selected_quest == quest_index) ? -1 : quest_index;
        } else {
            selected_quest = -1;
        }
    }
}

// Handle scroll bar dragging
if (point_in_rectangle(mouse_x_gui, mouse_y_gui,
    margin + journal_width - scroll_bar_width, content_y,
    margin + journal_width, margin + journal_height)) {
    
    if (mouse_check_button(mb_left)) {
        var scroll_height = journal_height - tab_height;
        var scroll_percent = (mouse_y_gui - content_y) / scroll_height;
        scroll_offset = scroll_percent * max_scroll;
        scroll_offset = clamp(scroll_offset, 0, max_scroll);
    }
}

// Handle filter toggles
if (keyboard_check_pressed(ord("M"))) {
    show_main_quests = !show_main_quests;
    update_quest_list();
}

if (keyboard_check_pressed(ord("S"))) {
    show_side_quests = !show_side_quests;
    update_quest_list();
}

if (keyboard_check_pressed(ord("L"))) {
    sort_by_level = !sort_by_level;
    update_quest_list();
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_quest_manager
File: Create_0.gml
/// @description Initialize quest and notification systems

// Initialize systems
global.quest_system = new QuestSystem().init();
global.notification_system = new NotificationSystem().init();

// Make persistent
persistent = true;

// Register cleanup handler
array_push(global.game_state.cleanup_handlers, function() {
    global.quest_system.cleanup();
    global.notification_system.cleanup();
});

// Define main story quests
global.quest_system.define_quest("QUEST_MISSING_GUIDE", {
    title: "The Missing Guide",
    chapter: 1,
    description: "A tour guide has mysteriously disappeared. Investigate the strange occurrences around the Ski Lodge.",
    objectives: [
        {
            id: "investigate_lodge",
            description: "Search the Ski Lodge for clues",
            required_items: [],
            completion_trigger: "area_searched"
        },
        {
            id: "collect_notes",
            description: "Find the scattered mysterious notes",
            required_items: ["note_fragment"],
            required_count: 3,
            completion_trigger: "items_collected"
        },
        {
            id: "find_mechanical_part",
            description: "Locate the unusual mechanical part",
            required_items: ["mechanical_part_1"],
            completion_trigger: "item_collected"
        }
    ],
    stages: {
        start: {
            dialogue: "A tour guide has gone missing under mysterious circumstances...",
            next_stage: "search_lodge"
        },
        search_lodge: {
            dialogue: "The Ski Lodge might hold important clues about their disappearance.",
            next_stage: "found_notes"
        },
        found_notes: {
            dialogue: "These notes mention something about automated systems and island renovations...",
            next_stage: "mechanical_discovery"
        },
        mechanical_discovery: {
            dialogue: "This mechanical part... it's unlike anything seen on the island before.",
            next_stage: "complete"
        }
    },
    rewards: {
        coins: 500,
        items: ["detective_hat"],
        unlock_quest: "QUEST_INVESTIGATE_BOTS"
    }
});

global.quest_system.define_quest("QUEST_SUSPICIOUS_BOTS", {
    title: "Suspicious Bots",
    description: "Gary needs help investigating some strange robot parts found around the island.",
    objectives: [
        {
            type: QuestObjectiveType.COLLECT,
            item: "bot_parts",
            description: "Collect suspicious bot parts",
            required_amount: 5
        },
        {
            type: QuestObjectiveType.TALK_TO,
            npc: "gary",
            description: "Show the parts to Gary",
            required_amount: 1
        }
    ],
    rewards: {
        experience: 150,
        coins: 750,
        items: ["epf_badge"]
    }
});

global.quest_system.define_quest("QUEST_REPAIR_PHONE", {
    title: "Repair the Spy Phone",
    description: "The EPF Spy Phone needs repairs. Find the necessary parts and fix it.",
    objectives: [
        {
            type: QuestObjectiveType.COLLECT,
            item: "circuit_board",
            description: "Find a circuit board",
            required_amount: 1
        },
        {
            type: QuestObjectiveType.COLLECT,
            item: "battery",
            description: "Find a battery",
            required_amount: 1
        },
        {
            type: QuestObjectiveType.PERFORM_ACTION,
            action: "repair_phone",
            description: "Repair the Spy Phone",
            required_amount: 1
        }
    ],
    rewards: {
        experience: 200,
        coins: 1000,
        items: ["spy_phone"]
    }
});

global.quest_system.define_quest("QUEST_TRACK_SIGNAL", {
    title: "Track the Signal",
    description: "Use your Spy Phone to track a mysterious signal across the island.",
    objectives: [
        {
            type: QuestObjectiveType.VISIT_LOCATION,
            location: "rm_snow_forts",
            description: "Check signal at Snow Forts",
            required_amount: 1
        },
        {
            type: QuestObjectiveType.VISIT_LOCATION,
            location: "rm_plaza",
            description: "Follow signal to Plaza",
            required_amount: 1
        },
        {
            type: QuestObjectiveType.COLLECT,
            item: "signal_data",
            description: "Collect signal data",
            required_amount: 3
        }
    ],
    rewards: {
        experience: 250,
        coins: 1250,
        items: ["signal_tracker"]
    }
});

global.quest_system.define_quest("QUEST_HERBERTS_LAIR", {
    title: "Herbert's Secret Lair",
    description: "The signal leads to Herbert's secret lair! Infiltrate it and discover his plans.",
    objectives: [
        {
            type: QuestObjectiveType.VISIT_LOCATION,
            location: "rm_tallest_mountain",
            description: "Reach the Tallest Mountain",
            required_amount: 1
        },
        {
            type: QuestObjectiveType.MINI_GAME,
            game: "infiltration",
            description: "Complete the infiltration challenge",
            required_amount: 1
        },
        {
            type: QuestObjectiveType.COLLECT,
            item: "herbert_plans",
            description: "Collect Herbert's plans",
            required_amount: 1
        }
    ],
    rewards: {
        experience: 500,
        coins: 2500,
        items: ["elite_epf_badge", "special_spy_gadget"]
    }
});

// Start initial quest if no quests are active or completed
if (array_length(global.quest_system.get_active_quests()) == 0 && 
    array_length(global.quest_system.get_completed_quests()) == 0) {
    global.quest_system.start_quest("QUEST_MISSING_GUIDE");
    global.notification_system.add_notification("New Quest: The Missing Guide", "quest");
}

// Debug message
show_debug_message("Quest and notification systems initialized");

/// @description Initialize Quest Manager

// Initialize quest collections
active_quests = ds_map_create();
completed_quests = ds_map_create();
available_quests = ds_map_create();

// Quest tracking
current_tracked_quest = noone;
show_quest_tracker = true;
tracker_x = 20;
tracker_y = 100;
tracker_width = 250;
tracker_height = 150;
tracker_alpha = 0.8;

/// @function add_quest(quest_data)
function add_quest(quest_data) {
    var quest = new Quest().init(quest_data);
    available_quests[? quest.id] = quest;
    return quest;
}

/// @function start_quest(quest_id)
function start_quest(quest_id) {
    var quest = available_quests[? quest_id];
    if (quest != undefined && quest.start_quest()) {
        ds_map_delete(available_quests, quest_id);
        active_quests[? quest_id] = quest;
        if (current_tracked_quest == noone) {
            track_quest(quest_id);
        }
        return true;
    }
    return false;
}

/// @function complete_quest(quest_id)
function complete_quest(quest_id) {
    var quest = active_quests[? quest_id];
    if (quest != undefined && quest.complete_quest()) {
        ds_map_delete(active_quests, quest_id);
        completed_quests[? quest_id] = quest;
        if (current_tracked_quest == quest) {
            current_tracked_quest = noone;
            // Auto-track next quest if it exists
            if (quest.next_quest != "") {
                track_quest(quest.next_quest);
            }
        }
        return true;
    }
    return false;
}

/// @function track_quest(quest_id)
function track_quest(quest_id) {
    var quest = active_quests[? quest_id];
    if (quest != undefined) {
        current_tracked_quest = quest;
        return true;
    }
    return false;
}

/// @function get_quest(quest_id)
function get_quest(quest_id) {
    // Check active quests first
    var quest = active_quests[? quest_id];
    if (quest != undefined) return quest;
    
    // Check available quests
    quest = available_quests[? quest_id];
    if (quest != undefined) return quest;
    
    // Check completed quests
    quest = completed_quests[? quest_id];
    if (quest != undefined) return quest;
    
    return undefined;
}

/// @function update_quest_objective(quest_id, objective_index, value)
function update_quest_objective(quest_id, objective_index, value) {
    var quest = active_quests[? quest_id];
    if (quest != undefined) {
        return quest.update_objective(objective_index, value);
    }
    return false;
}

/// @function is_quest_completed(quest_id)
function is_quest_completed(quest_id) {
    return ds_map_exists(completed_quests, quest_id);
}

/// @function is_quest_active(quest_id)
function is_quest_active(quest_id) {
    return ds_map_exists(active_quests, quest_id);
}

/// @function get_active_quests()
function get_active_quests() {
    return ds_map_keys_to_array(active_quests);
}

/// @function get_available_quests()
function get_available_quests() {
    return ds_map_keys_to_array(available_quests);
}

/// @function cleanup_quests()
function cleanup_quests() {
    ds_map_destroy(active_quests);
    ds_map_destroy(completed_quests);
    ds_map_destroy(available_quests);
}

// Initialize the Tour Guide disappearance quest line
var tour_guide_quest = create_quest_data(
    "MAIN_TOUR_GUIDE_1",
    "The Missing Guide",
    "The Guide has mysteriously disappeared. Find clues about their whereabouts.",
    QUEST_TYPE.MAIN_STORY,
    [
        create_objective("Talk to the Ski Lodge Owner", 1, "talk"),
        create_objective("Search for clues in the Ski Village", 3, "collect"),
        create_objective("Investigate suspicious footprints", 1, "investigate")
    ],
    create_quest_reward(200, ["map_piece"], 100)
);

// Add the quest to available quests
add_quest(tour_guide_quest);

// Chapter 2: Bot Investigation
quest_data[$ "QUEST_INVESTIGATE_BOTS"] = {
    title: "Automated Mysteries",
    chapter: 2,
    description: "Strange robots have been spotted around the island. Investigate their connection to the missing guide.",
    objectives: [
        {
            id: "observe_bots",
            description: "Observe bot behavior in the Plaza",
            required_items: [],
            completion_trigger: "area_observed"
        },
        {
            id: "collect_parts",
            description: "Collect suspicious mechanical parts",
            required_items: ["mechanical_part"],
            required_count: 5,
            completion_trigger: "items_collected"
        },
        {
            id: "analyze_parts",
            description: "Have G analyze the collected parts",
            required_items: ["analyzed_data"],
            completion_trigger: "item_collected"
        }
    ],
    stages: {
        start: {
            dialogue: "These robots seem to be following a pattern...",
            next_stage: "parts_collection"
        },
        parts_collection: {
            dialogue: "Each part tells us more about their purpose.",
            next_stage: "analysis"
        },
        analysis: {
            dialogue: "The analysis reveals a hidden facility beneath the island!",
            next_stage: "complete"
        }
    },
    rewards: {
        coins: 750,
        items: ["bot_scanner"],
        unlock_quest: "QUEST_REPAIR_PHONE"
    }
};

// Chapter 3: The Hidden Facility
quest_data[$ "QUEST_REPAIR_PHONE"] = {
    title: "Underground Secrets",
    chapter: 3,
    description: "A hidden facility has been discovered beneath the island. Find a way to access it and uncover its secrets.",
    objectives: [
        {
            id: "repair_device",
            description: "Repair the mysterious communication device",
            required_items: ["spare_parts"],
            required_count: 3,
            completion_trigger: "items_collected"
        },
        {
            id: "locate_entrance",
            description: "Find the hidden facility entrance",
            required_items: [],
            completion_trigger: "area_discovered"
        },
        {
            id: "rescue_guide",
            description: "Save the missing tour guide",
            required_items: ["access_card"],
            completion_trigger: "npc_rescued"
        }
    ],
    stages: {
        start: {
            dialogue: "This device might help us access the underground facility...",
            next_stage: "device_repair"
        },
        device_repair: {
            dialogue: "The repaired device is picking up strange signals...",
            next_stage: "entrance_discovery"
        },
        entrance_discovery: {
            dialogue: "The entrance to the facility has been found!",
            next_stage: "rescue_operation"
        },
        rescue_operation: {
            dialogue: "The truth about the island's automation project is revealed...",
            next_stage: "complete"
        }
    },
    rewards: {
        coins: 1000,
        items: ["facility_badge", "automated_puffle"],
        unlock_quest: ""  // End of current story arc
    }
};

// Initialize story progression tracking
global.story_progress = {
    current_chapter: 1,
    chapters_completed: 0,
    major_revelations: ds_map_create(),
    discovered_locations: ds_list_create()
}; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_quest_manager
File: Draw_64.gml
/// @description Draw quest tracker and rewards

if (!show_quest_tracker || current_tracked_quest == noone) exit;

// Draw tracker background
draw_set_alpha(tracker_alpha);
draw_set_color(c_black);
draw_rectangle(tracker_x, tracker_y, 
              tracker_x + tracker_width, 
              tracker_y + tracker_height, false);
draw_set_alpha(1);

// Draw border
draw_set_color(c_white);
draw_rectangle(tracker_x, tracker_y, 
              tracker_x + tracker_width, 
              tracker_y + tracker_height, true);

// Draw quest title with type indicator
draw_set_font(fnt_title);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
var title_y = tracker_y + 10;

// Draw quest type indicator
var type_color;
switch(current_tracked_quest.type) {
    case QUEST_TYPE.MAIN_STORY:
        type_color = c_yellow;
        break;
    case QUEST_TYPE.SIDE:
        type_color = c_aqua;
        break;
    case QUEST_TYPE.DAILY:
        type_color = c_lime;
        break;
    case QUEST_TYPE.SPECIAL_EVENT:
        type_color = c_fuchsia;
        break;
    default:
        type_color = c_white;
}

draw_set_color(type_color);
draw_circle(tracker_x + 10, title_y + 8, 4, false);
draw_set_color(c_white);
draw_text_ext(tracker_x + 20, title_y, 
              current_tracked_quest.title,
              20, tracker_width - 30);

// Draw quest description
draw_set_font(fnt_normal);
var desc_y = title_y + 30;
draw_text_ext(tracker_x + 10, desc_y,
              current_tracked_quest.description,
              15, tracker_width - 20);

// Draw objectives
var obj_y = desc_y + string_height_ext(current_tracked_quest.description, 15, tracker_width - 20) + 10;
draw_set_font(fnt_normal);

var all_completed = true;
for (var i = 0; i < array_length(current_tracked_quest.objectives); i++) {
    var obj = current_tracked_quest.objectives[i];
    var obj_text = " " + obj.description;
    
    // Add progress for counter-type objectives
    if (obj.type == "counter") {
        obj_text += " (" + string(obj.progress) + "/" + string(obj.required) + ")";
    }
    
    // Set color based on completion
    draw_set_color(obj.completed ? c_lime : c_white);
    if (!obj.completed) all_completed = false;
    
    draw_text_ext(tracker_x + 10, obj_y,
                  obj_text,
                  15, tracker_width - 20);
    
    obj_y += string_height_ext(obj_text, 15, tracker_width - 20) + 5;
}

// Draw rewards section if quest is not completed
if (!all_completed) {
    draw_set_color(c_yellow);
    draw_text(tracker_x + 10, obj_y + 10, "Rewards:");
    draw_set_color(c_white);
    obj_y += 30;
    
    // Draw coin reward
    if (current_tracked_quest.rewards.coins > 0) {
        draw_sprite_ext(spr_coin, 0, tracker_x + 15, obj_y, 0.5, 0.5, 0, c_white, 1);
        draw_text(tracker_x + 35, obj_y, string(current_tracked_quest.rewards.coins));
        obj_y += 20;
    }
    
    // Draw experience reward
    if (current_tracked_quest.rewards.experience > 0) {
        draw_sprite_ext(spr_experience, 0, tracker_x + 15, obj_y, 0.5, 0.5, 0, c_white, 1);
        draw_text(tracker_x + 35, obj_y, string(current_tracked_quest.rewards.experience) + " XP");
        obj_y += 20;
    }
    
    // Draw item rewards
    if (array_length(current_tracked_quest.rewards.items) > 0) {
        for (var i = 0; i < array_length(current_tracked_quest.rewards.items); i++) {
            var item = current_tracked_quest.rewards.items[i];
            draw_sprite_ext(spr_inventory_items, global.item_index_map[? item], 
                          tracker_x + 15, obj_y, 0.5, 0.5, 0, c_white, 1);
            draw_text(tracker_x + 35, obj_y, item);
            obj_y += 20;
        }
    }
}

// Draw completion message if all objectives are done
if (all_completed) {
    draw_set_color(c_lime);
    draw_text_ext(tracker_x + 10, obj_y + 10,
                  "Quest Complete! Return to quest giver for rewards.",
                  15, tracker_width - 20);
}

// Reset drawing properties
draw_set_color(c_white);
draw_set_alpha(1);
draw_set_font(-1); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_quest_manager
File: Step_0.gml
/// @description Update quests and check objectives

// Skip if game is paused
if (global.game_state.flags.is_paused) exit;

// Update notification system
global.notification_system.update();

// Update quest timers
global.quest_system.update();

// Get active quests
var active_quests = global.quest_system.get_active_quests();

// Check objectives for each active quest
for (var i = 0; i < array_length(active_quests); i++) {
    var quest = active_quests[i];
    var all_objectives_complete = true;
    
    // Check each objective
    for (var j = 0; j < array_length(quest.objectives); j++) {
        var objective = quest.objectives[j];
        var current_progress = quest.progress[j];
        var new_progress = current_progress;
        
        // Skip if objective is already completed
        if (current_progress >= objective.required_amount) continue;
        
        // Check objective based on type
        switch(objective.type) {
            case QuestObjectiveType.COLLECT:
                // Check inventory for required items
                var item_count = global.game_state.inventory.get_item_count(objective.item);
                new_progress = min(item_count, objective.required_amount);
                break;
                
            case QuestObjectiveType.VISIT_LOCATION:
                // Check if player is in required location
                if (room_get_name(room) == objective.location) {
                    new_progress = objective.required_amount;
                }
                break;
                
            case QuestObjectiveType.TALK_TO:
                // Check if player is talking to required NPC
                if (global.game_state.flags.dialogue_active && 
                    global.game_state.flags.current_npc == objective.npc) {
                    new_progress = objective.required_amount;
                }
                break;
                
            case QuestObjectiveType.PERFORM_ACTION:
                // Check if required action was performed
                switch(objective.action) {
                    case "repair_phone":
                        if (global.game_state.flags.repair_complete) {
                            new_progress = objective.required_amount;
                        }
                        break;
                    // Add more action checks here
                }
                break;
                
            case QuestObjectiveType.MINI_GAME:
                // Check if mini-game was completed
                if (global.game_state.flags.mini_game_complete == objective.game) {
                    new_progress = objective.required_amount;
                    global.game_state.flags.mini_game_complete = "";
                }
                break;
        }
        
        // Update progress if changed
        if (new_progress != current_progress) {
            global.quest_system.update_quest_progress(quest.id, j, new_progress);
            
            // Show progress notification
            if (new_progress >= objective.required_amount) {
                global.notification_system.add_notification(
                    "Objective Complete: " + objective.description, 
                    "quest"
                );
            } else if (new_progress > current_progress) {
                global.notification_system.add_notification(
                    objective.description + " (" + string(new_progress) + "/" + 
                    string(objective.required_amount) + ")",
                    "quest"
                );
            }
        }
        
        // Check if this objective is incomplete
        if (new_progress < objective.required_amount) {
            all_objectives_complete = false;
        }
    }
    
    // Complete quest if all objectives are done
    if (all_objectives_complete && !quest.completed) {
        // Complete the quest
        global.quest_system.complete_quest(quest.id);
        
        // Show completion notification
        global.notification_system.add_notification(
            "Quest Complete: " + quest.title, 
            "quest"
        );
        
        // Show rewards notification
        var reward_text = "Rewards: ";
        if (quest.rewards.experience > 0) {
            reward_text += string(quest.rewards.experience) + " XP";
        }
        if (quest.rewards.coins > 0) {
            if (quest.rewards.experience > 0) reward_text += ", ";
            reward_text += string(quest.rewards.coins) + " coins";
        }
        if (array_length(quest.rewards.items) > 0) {
            if (quest.rewards.experience > 0 || quest.rewards.coins > 0) {
                reward_text += ", ";
            }
            reward_text += string(array_length(quest.rewards.items)) + " items";
        }
        global.notification_system.add_notification(reward_text, "quest");
    }
}

// Debug controls
if (global.game_state.flags.debug_mode && keyboard_check_pressed(vk_f8)) {
    var active_quests = global.quest_system.get_active_quests();
    show_debug_message("Active Quests:");
    for (var i = 0; i < array_length(active_quests); i++) {
        var quest = active_quests[i];
        show_debug_message("- " + quest.title);
        for (var j = 0; j < array_length(quest.objectives); j++) {
            show_debug_message("  * " + quest.objectives[j].description + 
                " (" + string(quest.progress[j]) + "/" + 
                string(quest.objectives[j].required_amount) + ")");
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Create_0.gml
// Create Event for obj_repair_ui
visible = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Draw_64.gml
// Draw GUI Event for obj_repair_ui
if (visible) {
    var ui_x = camera_get_view_x(view_camera[0]) + 20;
    var ui_y = camera_get_view_y(view_camera[0]) + 20;

    draw_set_color(c_white);
    draw_rectangle(ui_x, ui_y, ui_x + 150, ui_y + 50, false);
    draw_set_color(c_black);
    draw_text(ui_x + 10, ui_y + 10, "Press 'E' to Repair");

    // Draw required materials
    for (var i = 0; i < 3; i++) {
        draw_sprite(spr_inventory_items, 7 + i, ui_x + 10 + (i * 20), ui_y + 30);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Step_0.gml
// Step Event for obj_repair_ui
var b = instance_nearest(global.player_instance.x, global.player_instance.y, obj_building);

if (b != noone && distance_to_object(b) < 32 && b.repair_stage == 0) {
    visible = true;
} else {
    visible = false;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_rocks
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_saveload_manager
File: CleanUp_0.gml
/// @description Clean up surfaces

// Free all preview surfaces
for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
    if (surface_exists(preview_surfaces[i])) {
        surface_free(preview_surfaces[i]);
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_saveload_manager
File: Create_0.gml
/// @description Initialize save/load manager

// Constants
#macro MAX_SAVE_SLOTS 3
#macro SAVE_FILE_PREFIX "save_profile_"

// Initialize save slots array
save_slots = array_create(MAX_SAVE_SLOTS, noone);

// UI properties
slot_width = 300;
slot_height = 200;
slot_spacing = 20;
button_height = 40;

// Calculate positions
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();

// Center the slots horizontally
total_width = (slot_width * MAX_SAVE_SLOTS) + (slot_spacing * (MAX_SAVE_SLOTS - 1));
start_x = (gui_width - total_width) / 2;
start_y = gui_height * 0.3;

// New game button position
new_game_x = gui_width / 2 - 100;
new_game_y = start_y + slot_height + 40;
new_game_width = 200;
new_game_height = 50;

// Load existing save data
for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
    var filename = SAVE_FILE_PREFIX + string(i) + ".json";
    if (file_exists(filename)) {
        var file = file_text_open_read(filename);
        var json = file_text_read_string(file);
        file_text_close(file);
        
        save_slots[i] = json_parse(json);
    }
}

// Create character preview surfaces
preview_surfaces = array_create(MAX_SAVE_SLOTS, -1);
for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
    preview_surfaces[i] = surface_create(sprite_get_width(spr_player) * 2, sprite_get_height(spr_player) * 2);
}

/// @function save_game_to_slot(slot)
function save_game_to_slot(slot) {
    if (slot < 0 || slot >= MAX_SAVE_SLOTS) return false;
    
    var save_data = {
        // Player data
        player: {
            x: global.player_instance.x,
            y: global.player_instance.y,
            color: global.player_instance.image_blend,
            sprite_index: global.player_instance.sprite_index,
            equipped_items: array_create(0)
        },
        
        // Inventory data
        inventory: array_create(0),
        
        // Quest data
        quests: {
            active: ds_list_to_array(global.active_quests),
            completed: ds_list_to_array(global.completed_quests)
        },
        
        // Room data
        current_room: room_get_name(room),
        
        // World state
        objects: array_create(0),
        
        // Timestamp
        timestamp: date_current_datetime()
    };
    
    // Save equipped items
    with(global.player_instance) {
        for (var i = 0; i < array_length(equipped_items); i++) {
            array_push(save_data.player.equipped_items, equipped_items[i]);
        }
    }
    
    // Save inventory items
    with(obj_inventory) {
        for (var i = 0; i < ds_list_size(items); i++) {
            array_push(save_data.inventory, items[| i]);
        }
    }
    
    // Save persistent object states
    with(all) {
        if (persistent) {
            var obj_data = {
                object_index: object_index,
                x: x,
                y: y,
                layer: layer,
                variables: {}
            };
            
            // Save object-specific variables
            var names = variable_instance_get_names(id);
            for (var i = 0; i < array_length(names); i++) {
                var name = names[i];
                if (name != "id" && name != "object_index") {
                    obj_data.variables[$ name] = variable_instance_get(id, name);
                }
            }
            
            array_push(save_data.objects, obj_data);
        }
    }
    
    // Save to file
    var filename = SAVE_FILE_PREFIX + string(slot) + ".json";
    var file = file_text_open_write(filename);
    file_text_write_string(file, json_stringify(save_data));
    file_text_close(file);
    
    // Update slot data
    save_slots[slot] = save_data;
    
    return true;
}

/// @function load_game_from_slot(slot)
function load_game_from_slot(slot) {
    if (slot < 0 || slot >= MAX_SAVE_SLOTS) return false;
    if (save_slots[slot] == noone) return false;
    
    var save_data = save_slots[slot];
    
    // Clear current game state
    game_restart_state();
    
    // Load room first
    var room_index = asset_get_index(save_data.current_room);
    if (room_index != -1) {
        room_goto(room_index);
    }
    
    // Load player data
    with(global.player_instance) {
        x = save_data.player.x;
        y = save_data.player.y;
        image_blend = save_data.player.color;
        sprite_index = save_data.player.sprite_index;
        equipped_items = array_create(0);
        
        // Load equipped items
        for (var i = 0; i < array_length(save_data.player.equipped_items); i++) {
            array_push(equipped_items, save_data.player.equipped_items[i]);
        }
    }
    
    // Load inventory
    with(obj_inventory) {
        ds_list_clear(items);
        for (var i = 0; i < array_length(save_data.inventory); i++) {
            ds_list_add(items, save_data.inventory[i]);
        }
    }
    
    // Load quests
    ds_list_clear(global.active_quests);
    ds_list_clear(global.completed_quests);
    
    for (var i = 0; i < array_length(save_data.quests.active); i++) {
        ds_list_add(global.active_quests, save_data.quests.active[i]);
    }
    
    for (var i = 0; i < array_length(save_data.quests.completed); i++) {
        ds_list_add(global.completed_quests, save_data.quests.completed[i]);
    }
    
    // Load objects
    for (var i = 0; i < array_length(save_data.objects); i++) {
        var obj_data = save_data.objects[i];
        var inst = instance_create_layer(obj_data.x, obj_data.y, obj_data.layer, obj_data.object_index);
        
        var var_names = variable_struct_get_names(obj_data.variables);
        for (var j = 0; j < array_length(var_names); j++) {
            var name = var_names[j];
            variable_instance_set(inst, name, obj_data.variables[$ name]);
        }
    }
    
    return true;
}

/// @function game_restart_state()
function game_restart_state() {
    // Clear all non-essential instances
    with(all) {
        if (object_index != obj_game_manager && 
            object_index != obj_saveload_manager) {
            instance_destroy();
        }
    }
    
    // Clear global lists
    ds_list_clear(global.active_quests);
    ds_list_clear(global.completed_quests);
}

/// @function ds_list_to_array(list)
function ds_list_to_array(list) {
    var arr = array_create(ds_list_size(list));
    for (var i = 0; i < ds_list_size(list); i++) {
        arr[i] = list[| i];
    }
    return arr;
}

/// @function update_preview_surfaces()
function update_preview_surfaces() {
    for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
        if (save_slots[i] != noone) {
            if (!surface_exists(preview_surfaces[i])) {
                preview_surfaces[i] = surface_create(sprite_get_width(spr_player) * 2, sprite_get_height(spr_player) * 2);
            }
            
            surface_set_target(preview_surfaces[i]);
            draw_clear_alpha(c_black, 0);
            
            // Draw player sprite with equipped items
            var player_data = save_slots[i].player;
            draw_sprite_ext(
                player_data.sprite_index,
                0,
                surface_get_width(preview_surfaces[i]) / 2,
                surface_get_height(preview_surfaces[i]) / 2,
                2,
                2,
                0,
                player_data.color,
                1
            );
            
            // Draw equipped items
            for (var j = 0; j < array_length(player_data.equipped_items); j++) {
                var item = player_data.equipped_items[j];
                if (item != noone) {
                    var item_sprite = get_item_sprite(item);
                    if (sprite_exists(item_sprite)) {
                        draw_sprite_ext(
                            item_sprite,
                            0,
                            surface_get_width(preview_surfaces[i]) / 2,
                            surface_get_height(preview_surfaces[i]) / 2,
                            2,
                            2,
                            0,
                            c_white,
                            1
                        );
                    }
                }
            }
            
            surface_reset_target();
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_saveload_manager
File: Draw_64.gml
/// @description Draw save/load UI

// Update preview surfaces
update_preview_surfaces();

// Draw save slots
for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
    var slot_x = start_x + (i * (slot_width + slot_spacing));
    var slot_y = start_y;
    
    // Draw slot background
    draw_set_color(c_dkgray);
    draw_rectangle(slot_x, slot_y, slot_x + slot_width, slot_y + slot_height, false);
    draw_set_color(c_white);
    draw_rectangle(slot_x, slot_y, slot_x + slot_width, slot_y + slot_height, true);
    
    if (save_slots[i] != noone) {
        // Draw character preview
        if (surface_exists(preview_surfaces[i])) {
            var preview_x = slot_x + (slot_width - surface_get_width(preview_surfaces[i])) / 2;
            var preview_y = slot_y + 20;
            draw_surface(preview_surfaces[i], preview_x, preview_y);
        }
        
        // Draw save info
        draw_set_font(fnt_normal);
        draw_set_halign(fa_center);
        
        var text_y = slot_y + slot_height - 60;
        var save_time = date_datetime_string(save_slots[i].timestamp);
        var current_room = save_slots[i].current_room;
        
        draw_text(slot_x + slot_width/2, text_y, "Save " + string(i + 1));
        draw_text(slot_x + slot_width/2, text_y + 20, save_time);
        draw_text(slot_x + slot_width/2, text_y + 40, current_room);
        
        // Draw load button
        var button_y = slot_y + slot_height - button_height - 10;
        draw_set_color(c_green);
        draw_rectangle(slot_x + 10, button_y, slot_x + slot_width - 10, button_y + button_height, false);
        draw_set_color(c_white);
        draw_text(slot_x + slot_width/2, button_y + button_height/2, "Load Game");
    } else {
        // Draw empty slot text
        draw_set_font(fnt_normal);
        draw_set_halign(fa_center);
        draw_text(slot_x + slot_width/2, slot_y + slot_height/2, "Empty Slot");
        
        // Draw new save button
        var button_y = slot_y + slot_height - button_height - 10;
        draw_set_color(c_blue);
        draw_rectangle(slot_x + 10, button_y, slot_x + slot_width - 10, button_y + button_height, false);
        draw_set_color(c_white);
        draw_text(slot_x + slot_width/2, button_y + button_height/2, "New Save");
    }
}

// Draw new game button
draw_set_color(c_green);
draw_rectangle(new_game_x, new_game_y, new_game_x + new_game_width, new_game_y + new_game_height, false);
draw_set_color(c_white);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
draw_text(new_game_x + new_game_width/2, new_game_y + new_game_height/2, "New Game");

// Reset draw properties
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_font(-1); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_saveload_manager
File: Step_0.gml
/// @description Handle save/load interactions

if (mouse_check_button_pressed(mb_left)) {
    var gui_x = device_mouse_x_to_gui(0);
    var gui_y = device_mouse_y_to_gui(0);
    
    // Check new game button
    if (point_in_rectangle(gui_x, gui_y, 
        new_game_x, new_game_y, 
        new_game_x + new_game_width, new_game_y + new_game_height)) {
        // Start new game
        game_restart_state();
        room_goto(rm_game); // Replace with your starting room
        instance_destroy();
        exit;
    }
    
    // Check save slots
    for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
        var slot_x = start_x + (i * (slot_width + slot_spacing));
        var slot_y = start_y;
        var button_y = slot_y + slot_height - button_height - 10;
        
        // Check if clicked on slot button
        if (point_in_rectangle(gui_x, gui_y,
            slot_x + 10, button_y,
            slot_x + slot_width - 10, button_y + button_height)) {
            
            if (save_slots[i] != noone) {
                // Load game
                if (load_game_from_slot(i)) {
                    instance_destroy();
                    exit;
                }
            } else {
                // Create new save in empty slot
                if (save_game_to_slot(i)) {
                    room_goto(rm_game); // Replace with your starting room
                    instance_destroy();
                    exit;
                }
            }
        }
    }
}

// Clean up invalid surfaces
for (var i = 0; i < MAX_SAVE_SLOTS; i++) {
    if (!surface_exists(preview_surfaces[i])) {
        preview_surfaces[i] = surface_create(sprite_get_width(spr_player) * 2, sprite_get_height(spr_player) * 2);
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: CleanUp_0.gml
//font_delete(global.font_main);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: Create_0.gml
global.font_main = fnt_bumbastika_sml;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_shopkeeper
File: Create_0.gml
/// @description Initialize shopkeeper

event_inherited(); // Inherit from obj_npc

// Basic NPC properties
npc_name = "Shopkeeper";
npc_color = c_white;
npc_role = "merchant";
is_interactable = true;

// Shop properties
shop_type = ShopType.CLOTHING; // Default shop type
shop_name = "Clothing Shop";
is_shop_open = true;
shop_hours = {
    open: 6,  // 6 AM
    close: 22 // 10 PM
};

// Initialize dialog
dialog_tree = ds_map_create();
dialog_tree[? "greeting"] = [
    "Welcome to " + shop_name + "!",
    "Take a look at our latest items.",
    "We have some great deals today!"
];

dialog_tree[? "farewell"] = [
    "Thanks for shopping!",
    "Come back soon!",
    "Have a great day!"
];

dialog_tree[? "closed"] = [
    "Sorry, we're closed right now.",
    "Come back between " + string(shop_hours.open) + "AM and " + string(shop_hours.close) + "PM!"
];

// Quest-related properties
quest_available = true;
quest_id = "shop_tutorial";
quest_state = "available";

// Shop tutorial quest
var quest_data = {
    id: "shop_tutorial",
    title: "Shopping 101",
    description: "Learn how to use the shop system",
    requirements: ds_map_create(),
    rewards: {
        coins: 100,
        items: ["Party Hat"],
        experience: 50
    },
    steps: [
        "Talk to the shopkeeper",
        "Browse the shop inventory",
        "Make your first purchase"
    ],
    progress: 0,
    target: 3
};

// Register quest with quest manager
with(obj_quest_manager) {
    register_quest(quest_data);
}

// Custom shopkeeper functions
function check_shop_hours() {
    var current_hour = current_datetime_get_hour();
    return current_hour >= shop_hours.open && current_hour < shop_hours.close;
}

function update_shop_status() {
    is_shop_open = check_shop_hours();
    if (!is_shop_open) {
        current_dialog = dialog_tree[? "closed"][irandom(array_length(dialog_tree[? "closed"]) - 1)];
    }
}

function get_random_greeting() {
    var greetings = dialog_tree[? "greeting"];
    return greetings[irandom(array_length(greetings) - 1)];
}

function get_random_farewell() {
    var farewells = dialog_tree[? "farewell"];
    return farewells[irandom(array_length(farewells) - 1)];
}

// Initialize shop inventory
function init_shop_inventory() {
    var shop = get_shop_items(shop_type);
    if (shop == noone) {
        show_debug_message("Failed to initialize shop inventory for type: " + string(shop_type));
        return;
    }
    
    // Add any shopkeeper-specific items or discounts
    switch(shop_type) {
        case ShopType.CLOTHING:
            apply_discount(shop_type, "Beta Hat", 20); // 20% off Beta Hat
            break;
            
        case ShopType.SPECIAL:
            set_item_stock(shop_type, "EPF Phone", 1); // Limited stock
            break;
    }
}

// Call initialization
init_shop_inventory(); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_shop_ui
File: Create_0.gml
/// @description Initialize shop UI

depth = -10000; // Ensure UI is drawn on top

// UI Properties
ui_width = 800;
ui_height = 600;
ui_x = (display_get_gui_width() - ui_width) / 2;
ui_y = (display_get_gui_height() - ui_height) / 2;

// Shop state
current_shop = noone;
current_category = ShopType.CLOTHING;
selected_item = noone;
scroll_offset = 0;
max_items_per_page = 8;

// UI Elements
category_buttons = [];
var button_width = 150;
var button_spacing = 10;
var start_x = ui_x + 20;
var button_y = ui_y + 20;

// Create category buttons
category_buttons[ShopType.CLOTHING] = {
    x: start_x,
    y: button_y,
    width: button_width,
    height: 30,
    text: "Clothing",
    hover: false
};

category_buttons[ShopType.FURNITURE] = {
    x: start_x + button_width + button_spacing,
    y: button_y,
    width: button_width,
    height: 30,
    text: "Furniture",
    hover: false
};

category_buttons[ShopType.SPECIAL] = {
    x: start_x + (button_width + button_spacing) * 2,
    y: button_y,
    width: button_width,
    height: 30,
    text: "Special",
    hover: false
};

category_buttons[ShopType.SEASONAL] = {
    x: start_x + (button_width + button_spacing) * 3,
    y: button_y,
    width: button_width,
    height: 30,
    text: "Seasonal",
    hover: false
};

// Item grid properties
grid_start_x = ui_x + 20;
grid_start_y = ui_y + 70;
item_width = 180;
item_height = 220;
grid_columns = 4;
grid_spacing = 10;

// Scrolling
can_scroll = false;
scroll_speed = 20;
scroll_bar_width = 20;
scroll_position = 0;
total_height = 0;

// Purchase button
purchase_button = {
    x: ui_x + ui_width - 150,
    y: ui_y + ui_height - 50,
    width: 120,
    height: 40,
    text: "Purchase",
    enabled: false,
    hover: false
};

// Close button
close_button = {
    x: ui_x + ui_width - 30,
    y: ui_y + 10,
    width: 20,
    height: 20,
    hover: false
};

/// @function set_shop(shop_keeper)
function set_shop(shop_keeper) {
    current_shop = shop_keeper;
    current_category = shop_keeper.shop_type;
    selected_item = noone;
    scroll_offset = 0;
    update_shop_items();
}

/// @function update_shop_items()
function update_shop_items() {
    if (current_shop == noone) return;
    
    var items = get_shop_items(current_category);
    if (items == noone) return;
    
    // Calculate total height for scrolling
    var item_count = ds_map_size(items);
    var rows = ceil(item_count / grid_columns);
    total_height = rows * (item_height + grid_spacing);
    can_scroll = total_height > (ui_height - grid_start_y - 60);
}

/// @function draw_item_card(item, x, y)
function draw_item_card(item, x, y) {
    // Draw background
    draw_set_color(c_dkgray);
    draw_rectangle(x, y, x + item_width, y + item_height, false);
    draw_set_color(c_white);
    draw_rectangle(x, y, x + item_width, y + item_height, true);
    
    // Draw item sprite
    var sprite_x = x + item_width/2;
    var sprite_y = y + 60;
    draw_sprite_ext(item.sprite, 0, sprite_x, sprite_y, 2, 2, 0, c_white, 1);
    
    // Draw item info
    draw_set_halign(fa_center);
    draw_text(x + item_width/2, y + 120, item.name);
    
    // Draw price
    var price_text = string(item.price);
    if (item.discount > 0) {
        var final_price = item.price * (1 - item.discount);
        price_text = string(final_price) + " (" + string(item.discount * 100) + "% off)";
        draw_set_color(c_lime);
    }
    draw_text(x + item_width/2, y + 140, price_text + " coins");
    draw_set_color(c_white);
    
    // Draw description
    draw_set_font(fnt_normal);
    draw_text_ext(x + item_width/2, y + 160, item.description, 15, item_width - 20);
    
    // Draw stock info if limited
    if (item.stock >= 0) {
        draw_text(x + item_width/2, y + item_height - 20, "Stock: " + string(item.stock));
    }
}

/// @function can_purchase_selected()
function can_purchase_selected() {
    if (selected_item == noone) return false;
    
    var shop = get_shop_items(current_category);
    if (!ds_map_exists(shop, selected_item)) return false;
    
    var item = shop[? selected_item];
    var final_price = item.price * (1 - item.discount);
    
    return global.player_coins >= final_price && (item.stock == -1 || item.stock > 0);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_shop_ui
File: Draw_64.gml
/// @description Draw shop UI

// Draw background
draw_set_alpha(0.9);
draw_set_color(c_black);
draw_rectangle(ui_x, ui_y, ui_x + ui_width, ui_y + ui_height, false);
draw_set_alpha(1);

// Draw border
draw_set_color(c_white);
draw_rectangle(ui_x, ui_y, ui_x + ui_width, ui_y + ui_height, true);

// Draw title and coin balance
draw_set_font(fnt_title);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_text(ui_x + 20, ui_y + 20, "Shop");

// Draw coin balance with icon
draw_set_font(fnt_normal);
var coin_text = string(get_player_coins()) + " coins";
var coin_width = string_width(coin_text);
draw_sprite_ext(spr_coin, 0, ui_x + ui_width - 40 - coin_width, ui_y + 25, 0.5, 0.5, 0, c_white, 1);
draw_text(ui_x + ui_width - 30 - coin_width, ui_y + 20, coin_text);

// Draw category buttons
for (var i = 0; i < array_length(category_buttons); i++) {
    var btn = category_buttons[i];
    var color = (i == current_category) ? c_yellow : (btn.hover ? c_gray : c_white);
    draw_set_color(color);
    draw_rectangle(btn.x, btn.y, btn.x + btn.width, btn.y + btn.height, true);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(btn.x + btn.width/2, btn.y + btn.height/2, btn.text);
}

// Draw items grid
var shop = get_shop_items(current_category);
if (shop != noone) {
    var items = ds_map_keys_to_array(shop);
    var visible_area_height = ui_height - grid_start_y - 60;
    var y_offset = grid_start_y - scroll_offset;
    
    for (var i = 0; i < array_length(items); i++) {
        var item = shop[? items[i]];
        var grid_x = i mod grid_columns;
        var grid_y = i div grid_columns;
        
        var item_x = grid_start_x + grid_x * (item_width + grid_spacing);
        var item_y = y_offset + grid_y * (item_height + grid_spacing);
        
        // Only draw if visible
        if (item_y + item_height > ui_y && item_y < ui_y + ui_height) {
            var is_selected = (selected_item == items[i]);
            var can_buy = can_afford_item(item.price);
            
            // Draw selection highlight
            if (is_selected) {
                draw_set_color(c_yellow);
                draw_set_alpha(0.3);
                draw_rectangle(item_x - 2, item_y - 2, 
                             item_x + item_width + 2, item_y + item_height + 2, 
                             false);
                draw_set_alpha(1);
            }
            
            // Draw item card
            draw_item_card(item, item_x, item_y);
            
            // Draw affordability indicator
            if (!can_buy) {
                draw_set_color(c_red);
                draw_set_alpha(0.5);
                draw_rectangle(item_x, item_y, item_x + item_width, item_y + item_height, false);
                draw_set_alpha(1);
            }
        }
    }
    
    // Draw scrollbar if needed
    if (can_scroll) {
        var scroll_height = ui_height - grid_start_y - 20;
        var scroll_x = ui_x + ui_width - scroll_bar_width - 10;
        var scroll_y = grid_start_y;
        
        // Background
        draw_set_color(c_dkgray);
        draw_rectangle(scroll_x, scroll_y, scroll_x + scroll_bar_width, scroll_y + scroll_height, false);
        
        // Handle
        var handle_height = (scroll_height / total_height) * scroll_height;
        var handle_y = scroll_y + (scroll_offset / total_height) * (scroll_height - handle_height);
        draw_set_color(c_white);
        draw_rectangle(scroll_x, handle_y, scroll_x + scroll_bar_width, handle_y + handle_height, false);
    }
}

// Draw purchase button
if (selected_item != noone) {
    var btn = purchase_button;
    var can_buy = can_purchase_selected();
    draw_set_color(can_buy ? (btn.hover ? c_lime : c_green) : c_gray);
    draw_rectangle(btn.x, btn.y, btn.x + btn.width, btn.y + btn.height, false);
    draw_set_color(c_white);
    draw_rectangle(btn.x, btn.y, btn.x + btn.width, btn.y + btn.height, true);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(btn.x + btn.width/2, btn.y + btn.height/2, can_buy ? "Purchase" : "Can't Afford");
}

// Draw close button
draw_set_color(close_button.hover ? c_red : c_white);
draw_line(close_button.x, close_button.y, 
          close_button.x + close_button.width, close_button.y + close_button.height);
draw_line(close_button.x + close_button.width, close_button.y, 
          close_button.x, close_button.y + close_button.height);

// Reset draw properties
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_font(-1); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_shop_ui
File: Mouse_53.gml
/// @description Handle mouse click for purchases

// Get GUI mouse position
var gui_mx = device_mouse_x_to_gui(0);
var gui_my = device_mouse_y_to_gui(0);

// Check close button
if (point_in_rectangle(gui_mx, gui_my,
    close_button.x, close_button.y,
    close_button.x + close_button.width,
    close_button.y + close_button.height)) {
    instance_destroy();
    exit;
}

// Check category buttons
for (var i = 0; i < array_length(category_buttons); i++) {
    var btn = category_buttons[i];
    if (point_in_rectangle(gui_mx, gui_my,
        btn.x, btn.y,
        btn.x + btn.width,
        btn.y + btn.height)) {
        current_category = i;
        selected_item = noone;
        scroll_offset = 0;
        update_shop_items();
        exit;
    }
}

// Check purchase button
if (selected_item != noone) {
    if (point_in_rectangle(gui_mx, gui_my,
        purchase_button.x, purchase_button.y,
        purchase_button.x + purchase_button.width,
        purchase_button.y + purchase_button.height)) {
        
        var shop = get_shop_items(current_category);
        if (ds_map_exists(shop, selected_item)) {
            var item = shop[? selected_item];
            var final_price = item.price * (1 - item.discount);
            
            if (can_afford_item(final_price)) {
                // Attempt purchase
                if (spend_coins(final_price, selected_item)) {
                    // Add item to inventory
                    var inventory_slot = -1;
                    for (var i = 0; i < array_length(global.inventory); i++) {
                        if (global.inventory[i] == -1) {
                            inventory_slot = i;
                            break;
                        }
                    }
                    
                    if (inventory_slot != -1) {
                        global.inventory[inventory_slot] = selected_item;
                        
                        // Update stock if limited
                        if (item.stock > 0) {
                            item.stock--;
                            if (item.stock == 0) {
                                selected_item = noone;
                            }
                        }
                        
                        // Show success notification
                        if (instance_exists(obj_notification_manager)) {
                            obj_notification_manager.show_notification(
                                "Purchased " + item.name + "!",
                                c_lime
                            );
                        }
                        
                        // Play purchase sound
                        audio_play_sound(snd_purchase, 1, false);
                    } else {
                        // Refund if inventory is full
                        earn_coins(final_price, "refund");
                        if (instance_exists(obj_notification_manager)) {
                            obj_notification_manager.show_notification(
                                "Inventory is full!",
                                c_red
                            );
                        }
                    }
                }
            } else {
                // Show cannot afford notification
                if (instance_exists(obj_notification_manager)) {
                    obj_notification_manager.show_notification(
                        "Not enough coins!",
                        c_red
                    );
                }
            }
        }
        exit;
    }
}

// Check item grid
var shop = get_shop_items(current_category);
if (shop != noone) {
    var items = ds_map_keys_to_array(shop);
    var visible_area_height = ui_height - grid_start_y - 60;
    var y_offset = grid_start_y - scroll_offset;
    
    for (var i = 0; i < array_length(items); i++) {
        var grid_x = i mod grid_columns;
        var grid_y = i div grid_columns;
        
        var item_x = grid_start_x + grid_x * (item_width + grid_spacing);
        var item_y = y_offset + grid_y * (item_height + grid_spacing);
        
        if (item_y + item_height > ui_y && item_y < ui_y + ui_height) {
            if (point_in_rectangle(gui_mx, gui_my,
                item_x, item_y,
                item_x + item_width,
                item_y + item_height)) {
                selected_item = items[i];
                exit;
            }
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_shop_ui
File: Step_0.gml
/// @description Handle shop UI interactions

// Get mouse GUI position
var mouse_gui_x = device_mouse_x_to_gui(0);
var mouse_gui_y = device_mouse_y_to_gui(0);

// Handle category button interactions
for (var i = 0; i < array_length(category_buttons); i++) {
    var btn = category_buttons[i];
    btn.hover = point_in_rectangle(mouse_gui_x, mouse_gui_y,
                                 btn.x, btn.y,
                                 btn.x + btn.width, btn.y + btn.height);
    
    if (btn.hover && mouse_check_button_pressed(mb_left)) {
        current_category = i;
        scroll_offset = 0;
        selected_item = noone;
        audio_play_sound(snd_button_click, 1, false);
    }
}

// Handle item selection
var items = get_shop_items(current_category);
if (items != noone) {
    var keys = ds_map_keys_to_array(items);
    var visible_area_height = ui_height - grid_start_y - 60;
    var row = 0;
    var col = 0;
    var clicked_item = noone;
    
    for (var i = 0; i < array_length(keys); i++) {
        var item_x = grid_start_x + col * (item_width + grid_spacing);
        var item_y = grid_start_y + row * (item_height + grid_spacing) - scroll_offset;
        
        // Check if item is visible and clicked
        if (item_y + item_height >= grid_start_y && item_y <= grid_start_y + visible_area_height) {
            if (point_in_rectangle(mouse_gui_x, mouse_gui_y,
                                item_x, item_y,
                                item_x + item_width, item_y + item_height)) {
                if (mouse_check_button_pressed(mb_left)) {
                    clicked_item = keys[i];
                }
            }
        }
        
        // Update grid position
        col++;
        if (col >= grid_columns) {
            col = 0;
            row++;
        }
    }
    
    if (clicked_item != noone) {
        if (clicked_item == selected_item) {
            selected_item = noone;
        } else {
            selected_item = clicked_item;
            audio_play_sound(snd_item_select, 1, false);
        }
    }
    
    // Handle scrolling
    if (can_scroll) {
        // Mouse wheel scrolling
        var wheel = mouse_wheel_down() - mouse_wheel_up();
        if (wheel != 0) {
            scroll_offset = clamp(scroll_offset + wheel * 32,
                                0,
                                max(0, total_height - visible_area_height));
        }
        
        // Scrollbar dragging
        var scroll_x = ui_x + ui_width - scroll_bar_width - 10;
        var scroll_y = grid_start_y;
        var scroll_height = visible_area_height;
        var handle_height = (visible_area_height / total_height) * scroll_height;
        
        if (point_in_rectangle(mouse_gui_x, mouse_gui_y,
                             scroll_x, scroll_y,
                             scroll_x + scroll_bar_width, scroll_y + scroll_height)) {
            if (mouse_check_button(mb_left)) {
                var mouse_ratio = (mouse_gui_y - scroll_y) / scroll_height;
                scroll_offset = clamp(mouse_ratio * total_height,
                                    0,
                                    max(0, total_height - visible_area_height));
            }
        }
    }
}

// Handle purchase button
if (selected_item != noone) {
    purchase_button.hover = point_in_rectangle(mouse_gui_x, mouse_gui_y,
                                            purchase_button.x, purchase_button.y,
                                            purchase_button.x + purchase_button.width,
                                            purchase_button.y + purchase_button.height);
    
    if (purchase_button.hover && mouse_check_button_pressed(mb_left)) {
        if (can_purchase_selected()) {
            var item = items[? selected_item];
            global.player_coins -= item.price;
            
            // Add item to inventory based on type
            switch (current_category) {
                case SHOP_TYPE.CLOTHING:
                    ds_list_add(global.player_clothing, selected_item);
                    break;
                case SHOP_TYPE.FURNITURE:
                    ds_list_add(global.player_furniture, selected_item);
                    break;
                case SHOP_TYPE.SPECIAL:
                case SHOP_TYPE.SEASONAL:
                    ds_list_add(global.player_items, selected_item);
                    break;
            }
            
            audio_play_sound(snd_purchase, 1, false);
            selected_item = noone;
        } else {
            audio_play_sound(snd_error, 1, false);
        }
    }
}

// Handle close button
close_button.hover = point_in_rectangle(mouse_gui_x, mouse_gui_y,
                                      close_button.x, close_button.y,
                                      close_button.x + close_button.width,
                                      close_button.y + close_button.height);

if (close_button.hover && mouse_check_button_pressed(mb_left)) {
    instance_destroy();
    audio_play_sound(snd_button_click, 1, false);
}

// Handle escape key to close
if (keyboard_check_pressed(vk_escape)) {
    instance_destroy();
    audio_play_sound(snd_button_click, 1, false);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpost
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpostalt
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skilift
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Create_0.gml
depth = -1000; // Ensuring the skin picker is in front of everything

// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Ensure the global skins array exists
if (!variable_global_exists("skins")) {
    global.skins = [
        {object: obj_player_icetruck, name: "Ice Truck"},
        {object: obj_player, name: "Penguin"},
        {object: obj_player_tube, name: "Tube"}
    ];
}

// Button properties
var button_width = 37.5; 
var button_height = 10; 
var button_padding = 2.5; 
var button_x = x + (menu_width - button_width) / 2; 
var button_y = y + button_padding; 

// Create buttons for each skin
for (var i = 0; i < array_length(global.skins); i++) {
    var skin = global.skins[i];
    var btn_skin = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton); // Reference obj_skinpickerbutton
    btn_skin.skin_object = skin.object; // Set the object to switch to
    btn_skin.skin_name = skin.name;    // Set the button label

    // Scale buttons
    btn_skin.image_xscale = button_width / sprite_get_width(spr_button);
    btn_skin.image_yscale = button_height / sprite_get_height(spr_button);

    button_y += button_height + button_padding; // Position the next button
}

// Create a Close button
var btn_close = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton);
btn_close.skin_object = noone; // No skin switch, just close
btn_close.skin_name = "Close"; 
btn_close.sprite_index = spr_button;

// Scale the Close button
btn_close.image_xscale = button_width / sprite_get_width(spr_button);
btn_close.image_yscale = button_height / sprite_get_height(spr_button);



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Destroy_0.gml
// Destroy all button instances when the skin picker menu is destroyed
with (obj_skinpickerbutton) {
    instance_destroy(); // Destroy all buttons linked to this menu
}
shader_reset(); // Reset the shader to remove the blur effect

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Draw_0.gml
// Draw Event for obj_skinpicker
//if (shader_is_compiled(shd_blur)) {
    // Apply blur shader
//    var tex = surface_get_texture(application_surface);
//    shader_set(shd_blur);
 //   shader_set_uniform_i(shader_get_uniform(shd_blur, "texture"), tex);
//    draw_surface(application_surface, 0, 0);
//    shader_reset();
//}

// Draw the skin picker menu
draw_self();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: KeyPress_80.gml
show_debug_message("Buttons left: " + string(instance_number(obj_skinpickerbutton)));
show_debug_message("Skinpickers left: " + string(instance_number(obj_skinpicker)));
show_debug_message("Skin picker buttons: " + string(instance_number(obj_skinpickerbutton)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Create_0.gml
depth = -1010; // Ensure buttons are in front of the skin picker

// Initialize button-specific variables
skin_object = noone; // The skin this button switches to
skin_name = "";      // The name displayed on the button

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Draw_0.gml
// Draw Event for obj_button
draw_self(); // Draw the button sprite

// Draw the button text
draw_set_color(c_black); // Set text color to black
draw_set_halign(fa_center); // Center text horizontally
draw_set_valign(fa_middle); // Center text vertically

var button_width = sprite_width * image_xscale;
var button_height = sprite_height * image_yscale;

var text_x = x + button_width / 2;
var text_y = y + button_height / 2;

draw_text(text_x, text_y, skin_name); // Center the text
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Mouse_4.gml
if (skin_object != noone) {
    obj_controller.switch_skin(skin_name);
}

// Destroy the skin picker menu if a valid skin was selected
if (skin_object != noone) {
    with (obj_skinpicker) {
        instance_destroy();
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Create_0.gml
/// @description Initialize sledding player

// Movement variables
xspd = 0;
yspd = 0;
base_speed = 5;
move_spd = base_speed;
max_speed = 8;
acceleration = 0.1;
turning_speed = 0.8; // How quickly the player can move left/right
momentum = 0;
max_momentum = 1;

// Game state variables
lives = 3;
score = 0;
distance_traveled = 0;
global.game_started = true;
game_timer = 30 * 60; // 30 seconds timer (assuming 60 FPS)
collision_cooldown = 0;
invincible = false;
invincible_timer = 0;
flash_alpha = 1;

// Speed boost variables
on_ice_path = false;
boost_multiplier = 1.5;
boost_duration = 0;
boost_cooldown = 0;
boost_particles = part_system_create();
part_system_depth(boost_particles, -1000);

// Create particle types
trail_particle = part_type_create();
part_type_sprite(trail_particle, spr_snow_particle, true, true, false);
part_type_size(trail_particle, 0.1, 0.3, -0.01, 0);
part_type_scale(trail_particle, 1, 1);
part_type_speed(trail_particle, 1, 3, -0.1, 0);
part_type_direction(trail_particle, 80, 100, 0, 0);
part_type_orientation(trail_particle, 0, 360, 0, 0, true);
part_type_life(trail_particle, 20, 30);
part_type_alpha3(trail_particle, 0.8, 0.5, 0);
part_type_colour3(trail_particle, c_white, c_ltgray, c_gray);

boost_particle = part_type_create();
part_type_sprite(boost_particle, spr_sparkle, true, true, false);
part_type_size(boost_particle, 0.2, 0.4, -0.02, 0);
part_type_scale(boost_particle, 1, 1);
part_type_speed(boost_particle, 2, 4, -0.1, 0);
part_type_direction(boost_particle, 80, 100, 0, 0);
part_type_orientation(boost_particle, 0, 360, 0, 0, true);
part_type_life(boost_particle, 15, 25);
part_type_alpha3(boost_particle, 1, 0.6, 0);
part_type_colour3(boost_particle, c_aqua, c_blue, c_navy);

// Create emitter
trail_emitter = part_emitter_create(boost_particles);

// Combo system
combo_count = 0;
combo_timer = 0;
max_combo = 10;
combo_multiplier = 1;

// Achievement tracking
obstacles_dodged = 0;
ice_paths_used = 0;
max_speed_reached = 0;
longest_combo = 0;

// Screen shake
screen_shake = 0;
shake_magnitude = 0;

// Sound effects
audio_falloff_set_model(audio_falloff_linear_distance);
wind_sound = noone;
slide_sound = noone;

// Initialize wind sound
if (audio_exists(snd_wind)) {
    wind_sound = audio_play_sound(snd_wind, 1, true);
    audio_sound_gain(wind_sound, 0, 0);
}

// Initialize slide sound
if (audio_exists(snd_sliding)) {
    slide_sound = audio_play_sound(snd_sliding, 1, true);
    audio_sound_gain(slide_sound, 0, 0);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Draw_0.gml
/// @description Draw sled player and effects

// Draw the player sprite with flash effect if invincible
draw_sprite_ext(sprite_index, image_index, x, y, 
    image_xscale, image_yscale, image_angle, c_white, flash_alpha);

// Draw speed lines when moving fast
if (move_spd > base_speed) {
    var line_count = floor((move_spd - base_speed) * 3);
    var line_length = move_spd * 2;
    var line_alpha = (move_spd / max_speed) * 0.7;
    
    draw_set_alpha(line_alpha);
    draw_set_color(c_white);
    
    for (var i = 0; i < line_count; i++) {
        var line_x = x + random_range(-sprite_width/2, sprite_width/2);
        var line_y = y + random_range(-sprite_height/2, sprite_height/2);
        draw_line(line_x, line_y, line_x, line_y + line_length);
    }
    
    draw_set_alpha(1);
}

// Draw combo indicator
if (combo_count > 0) {
    draw_set_font(fnt_combo);
    draw_set_halign(fa_center);
    draw_set_valign(fa_bottom);
    
    var combo_text = string(combo_count) + "x Combo!";
    var text_y = y - sprite_height - 10;
    
    // Draw combo text with outline
    draw_set_color(c_black);
    draw_text(x+1, text_y+1, combo_text);
    draw_text(x-1, text_y-1, combo_text);
    draw_text(x+1, text_y-1, combo_text);
    draw_text(x-1, text_y+1, combo_text);
    
    // Draw main text with color based on combo multiplier
    var text_color = make_color_hsv(
        (combo_multiplier - 1) * 255, // Hue changes with multiplier
        255, // Full saturation
        255  // Full value
    );
    draw_set_color(text_color);
    draw_text(x, text_y, combo_text);
}

// Reset draw properties
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_color(c_white);

if (global.game_started) {
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_black);
    draw_text(10, 10, "Lives: " + string(lives));
    draw_text(10, 30, "Time: " + string(ceil(game_timer / 60))); // Display in seconds
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Draw_64.gml
/// @description Draw GUI elements

// Set up text properties
draw_set_font(fnt_gui);
draw_set_halign(fa_left);
draw_set_valign(fa_top);

// Draw time remaining
var time_remaining = ceil(game_timer / room_speed);
draw_set_color(c_black);
draw_text(11, 11, "Time: " + string(time_remaining));
draw_set_color(c_white);
draw_text(10, 10, "Time: " + string(time_remaining));

// Draw lives
for (var i = 0; i < lives; i++) {
    draw_sprite(spr_life, 0, 10 + (i * 32), 40);
}

// Draw score
draw_set_color(c_black);
draw_text(11, 71, "Score: " + string(score));
draw_set_color(c_white);
draw_text(10, 70, "Score: " + string(score));

// Draw speed meter
var speed_percent = (move_spd / max_speed) * 100;
var meter_width = 150;
var meter_height = 20;
var meter_x = 10;
var meter_y = 100;

// Draw meter background
draw_set_color(c_dkgray);
draw_rectangle(meter_x, meter_y, meter_x + meter_width, meter_y + meter_height, false);

// Draw meter fill
var fill_width = (speed_percent / 100) * meter_width;
var fill_color = make_color_hsv((speed_percent / 100) * 85, 255, 255);
draw_set_color(fill_color);
draw_rectangle(meter_x, meter_y, meter_x + fill_width, meter_y + meter_height, false);

// Draw meter border
draw_set_color(c_white);
draw_rectangle(meter_x, meter_y, meter_x + meter_width, meter_y + meter_height, true);

// Draw speed text
draw_set_color(c_black);
draw_text(meter_x + 1, meter_y + meter_height + 6, "Speed: " + string_format(speed_percent, 0, 1) + "%");
draw_set_color(c_white);
draw_text(meter_x, meter_y + meter_height + 5, "Speed: " + string_format(speed_percent, 0, 1) + "%");

// Draw distance
var distance_text = "Distance: " + string_format(distance_traveled, 0, 1) + "m";
draw_set_color(c_black);
draw_text(11, 151, distance_text);
draw_set_color(c_white);
draw_text(10, 150, distance_text);

// Draw game over screen
if (!global.game_started) {
    draw_set_alpha(0.7);
    draw_set_color(c_black);
    draw_rectangle(0, 0, display_get_gui_width(), display_get_gui_height(), false);
    draw_set_alpha(1);
    
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var center_x = display_get_gui_width() / 2;
    var center_y = display_get_gui_height() / 2;
    
    // Draw game over text
    draw_set_font(fnt_large);
    draw_set_color(c_white);
    draw_text(center_x, center_y - 50, lives <= 0 ? "GAME OVER!" : "FINISH!");
    
    // Draw stats
    draw_set_font(fnt_gui);
    var stats_y = center_y + 10;
    draw_text(center_x, stats_y, "Final Score: " + string(score));
    draw_text(center_x, stats_y + 30, "Distance: " + string_format(distance_traveled, 0, 1) + "m");
    draw_text(center_x, stats_y + 60, "Longest Combo: " + string(longest_combo) + "x");
    draw_text(center_x, stats_y + 90, "Ice Paths Used: " + string(ice_paths_used));
    
    // Draw restart prompt
    draw_set_font(fnt_small);
    draw_text(center_x, stats_y + 140, "Press SPACE to try again!");
}

// Reset draw properties
draw_set_halign(fa_left);
draw_set_valign(fa_top);
draw_set_alpha(1);
draw_set_color(c_white); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Other_4.gml
// Room Start Event for obj_sled_player
global.player_instance = id;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Step_0.gml
/// @description Handle sledding mechanics

if (!global.game_started) exit;

// Input handling
var move_input = keyboard_check(vk_right) - keyboard_check(vk_left);

// Apply momentum and turning
var target_xspd = move_input * turning_speed;
xspd = lerp(xspd, target_xspd, 0.1);
momentum = clamp(momentum + acceleration, 0, max_momentum);

// Update movement speed based on momentum and boosts
move_spd = base_speed + (momentum * 2);
if (on_ice_path) {
    move_spd *= boost_multiplier;
    
    // Create boost particles
    part_emitter_region(boost_particles, trail_emitter, 
        x - 5, x + 5, y, y + 10, ps_shape_rectangle, ps_distr_linear);
    part_emitter_burst(boost_particles, trail_emitter, boost_particle, 2);
}

// Create snow trail particles
part_emitter_region(boost_particles, trail_emitter, 
    x - 2, x + 2, y, y + 5, ps_shape_rectangle, ps_distr_linear);
part_emitter_burst(boost_particles, trail_emitter, trail_particle, 1);

// Update position
x += xspd;
y += yspd;

// Keep player within bounds
x = clamp(x, sprite_width/2, room_width - sprite_width/2);

// Update game timer
if (game_timer > 0) {
    game_timer--;
    distance_traveled += move_spd / room_speed;
} else {
    // End game when timer runs out
    global.game_started = false;
    // Save high score and achievements here
}

// Handle collisions with obstacles
if (collision_cooldown > 0) {
    collision_cooldown--;
}

if (place_meeting(x, y, obj_obstacle) && collision_cooldown <= 0) {
    lives--;
    collision_cooldown = room_speed; // 1 second cooldown
    momentum = 0;
    combo_count = 0;
    combo_multiplier = 1;
    
    // Screen shake effect
    screen_shake = 10;
    shake_magnitude = 5;
    
    if (lives <= 0) {
        global.game_started = false;
        // Game over logic here
    }
}

// Check for ice path collision
var was_on_ice = on_ice_path;
on_ice_path = place_meeting(x, y, obj_slippery);

if (on_ice_path && !was_on_ice) {
    ice_paths_used++;
    combo_count++;
    combo_timer = room_speed * 2; // 2 seconds to maintain combo
    
    if (combo_count > longest_combo) {
        longest_combo = combo_count;
    }
    
    combo_multiplier = min(1 + (combo_count * 0.1), 2.0);
    score += 10 * combo_multiplier;
}

// Update combo timer
if (combo_timer > 0) {
    combo_timer--;
} else {
    combo_count = 0;
    combo_multiplier = 1;
}

// Update screen shake
if (screen_shake > 0) {
    screen_shake--;
    x += random_range(-shake_magnitude, shake_magnitude);
    shake_magnitude *= 0.9;
}

// Update sound effects
if (wind_sound != noone) {
    var wind_volume = (move_spd / max_speed) * 0.5;
    audio_sound_gain(wind_sound, wind_volume, 100);
}

if (slide_sound != noone) {
    var slide_volume = on_ice_path ? 0.3 : 0;
    audio_sound_gain(slide_sound, slide_volume, 100);
}

// Track max speed
if (move_spd > max_speed_reached) {
    max_speed_reached = move_spd;
}

// Update invincibility
if (invincible) {
    invincible_timer--;
    flash_alpha = (invincible_timer mod 8 < 4) ? 0.5 : 1;
    
    if (invincible_timer <= 0) {
        invincible = false;
        flash_alpha = 1;
    }
}

// Update score based on distance
score += (move_spd / room_speed) * combo_multiplier;


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Create_0.gml
xspd = 0;
yspd = 0;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Step_0.gml
if (place_meeting(x, y, obj_player) || place_meeting(x, y, obj_player_tube)) {
    if (!sliding) {
        sliding = true;
        
        // Get the player's last movement direction
        var player = instance_nearest(x, y, obj_player); // Get closest player
        if (!instance_exists(player)) player = instance_nearest(x, y, obj_player_tube);

        if (instance_exists(player)) {
            slide_dir_x = sign(player.xspd);
            slide_dir_y = sign(player.yspd);
            slide_speed = max(abs(player.xspd), abs(player.yspd)); // Carry over momentum
        }
    }
}

// **Sliding Deceleration Logic**
if (sliding) {
    x += slide_dir_x * slide_speed;
    y += slide_dir_y * slide_speed;

    // Reduce speed gradually
    slide_speed *= 0.95; 

    // Stop sliding when slow enough
    if (slide_speed < 0.1) {
        sliding = false;
        slide_speed = 0;
    }

    // **Collision Handling (Bounce Effect)**
    if (place_meeting(x + slide_dir_x * slide_speed, y, obj_wall)) {
        slide_dir_x = -slide_dir_x; // Reverse direction on X collision
        slide_speed *= 0.7; // Reduce speed slightly when bouncing
    }
    
    if (place_meeting(x, y + slide_dir_y * slide_speed, obj_wall)) {
        slide_dir_y = -slide_dir_y; // Reverse direction on Y collision
        slide_speed *= 0.7;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_bushes
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sml_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Cleanup_0.gml
/// @description Clean up resources
if (ds_exists(hit_objects, ds_type_list)) {
    ds_list_destroy(hit_objects);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Create_0.gml
/// @description Initialize snowball
event_inherited();

// Set sprite
sprite_index = spr_snowball;

// Initialize throwable properties
var throw_props = init_throwable(10, 0.4, 0.3); // Faster speed, less gravity, less bounce

// Set depth based on height
depth = -y;

// Collision properties
damage = 1;
hit_objects = ds_list_create();

// Lifetime properties
lifetime = room_speed * 3; // 3 seconds
alarm[0] = lifetime; // Set destruction timer

// Sprite properties
image_speed = 0;
image_index = 0;

// Initialize rotation based on direction
image_angle = 0;
rotation_speed = 5; // Degrees per step
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Draw_0.gml
/// @description Draw snowball with shadow
draw_throwable();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Step_0.gml
/// @description Handle snowball physics and collisions

// Update throwable physics
var throw_ended = update_throwable();
if (throw_ended) {
    instance_destroy();
    return;
}

// Update depth based on position and height
depth = -(y + z);

// Rotate snowball while in air
if (z > 0) {
    image_angle += rotation_speed * image_xscale; // Rotate based on direction
}

// Check for collisions with objects
var targets = ds_list_create();
var count = collision_circle_list(x, y, sprite_width/2, all, false, true, targets, false);

if (count > 0) {
    for (var i = 0; i < count; i++) {
        var target = targets[| i];
        
        // Skip if already hit
        if (ds_list_find_index(hit_objects, target) != -1) continue;
        
        // Handle collision based on object type
        if (object_is_ancestor(target.object_index, obj_player_base)) {
            // Hit player
            with (target) {
                // Add knockback or effect here if desired
                show_debug_message("Player hit by snowball!");
            }
            ds_list_add(hit_objects, target);
            instance_destroy();
            break;
        }
        else if (object_is_ancestor(target.object_index, obj_npc)) {
            // Hit NPC
            with (target) {
                // Add NPC reaction here
                show_debug_message("NPC hit by snowball!");
            }
            ds_list_add(hit_objects, target);
            instance_destroy();
            break;
        }
    }
}

ds_list_destroy(targets);

// Update lifetime
lifetime--;

// Destroy if lifetime expired
if (lifetime <= 0) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowshovel_item
File: Create_0.gml
event_inherited();
item_name = "Snow Shovel";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snow_item
File: Create_0.gml
event_inherited();
item_name = "Snow";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_stampbook_item
File: Create_0.gml
event_inherited();
item_name = "Stamp Book";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_starterdeck_item
File: Create_0.gml
event_inherited();
item_name = "Starter Deck";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_test_controller
File: Alarm_0.gml
/// @description Run Tests

if (!tests_running) {
    tests_running = true;
    
    // Clear previous results
    ds_list_clear(debug_messages);
    
    // Run tests
    global.test_manager.run_all_tests();
    
    // Mark as complete
    test_complete = true;
    tests_running = false;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_test_controller
File: Create_0.gml
/// @description Initialize Test Controller

// Initialize test suite
initialize_test_suite();

// Create debug UI variables
debug_window_x = 32;
debug_window_y = 32;
debug_window_width = 300;
debug_window_height = 400;
debug_scroll = 0;
debug_messages = ds_list_create();
max_messages = 50;

// Test execution state
tests_running = false;
test_complete = false;

// Add debug logging listener
show_debug_overlay(true);

// Override show_debug_message
function capture_debug_message(message) {
    ds_list_add(debug_messages, string(message));
    if (ds_list_size(debug_messages) > max_messages) {
        ds_list_delete(debug_messages, 0);
    }
    show_debug_message(message); // Still show in normal debug output
}

// Start tests automatically
alarm[0] = 1; 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_test_controller
File: Draw_64.gml
/// @description Draw Debug Window

// Set up drawing properties
draw_set_font(fnt_debug);
draw_set_color(c_black);
draw_set_alpha(0.8);

// Draw debug window background
draw_rectangle(debug_window_x, debug_window_y, 
              debug_window_x + debug_window_width, 
              debug_window_y + debug_window_height, false);

// Draw debug messages
draw_set_color(c_white);
draw_set_alpha(1);
var line_height = 20;
var padding = 10;
var draw_y = debug_window_y + padding - debug_scroll;

// Draw test results if complete
if (test_complete && variable_global_exists("test_manager")) {
    var results = global.test_manager.results;
    draw_text(debug_window_x + padding, draw_y, 
              "Test Results: " + string(results.passed) + "/" + string(results.total) + " passed");
    draw_y += line_height * 2;
}

// Draw debug messages
for (var i = 0; i < ds_list_size(debug_messages); i++) {
    var message = debug_messages[| i];
    if (string_pos("PASS", message) != 0) {
        draw_set_color(c_lime);
    } else if (string_pos("FAIL", message) != 0) {
        draw_set_color(c_red);
    } else {
        draw_set_color(c_white);
    }
    
    if (draw_y + line_height > debug_window_y && 
        draw_y < debug_window_y + debug_window_height) {
        draw_text_ext(debug_window_x + padding, draw_y, message, 
                     line_height, debug_window_width - padding * 2);
    }
    draw_y += string_height_ext(message, line_height, 
                               debug_window_width - padding * 2);
}

// Draw scrollbar if needed
var content_height = draw_y - (debug_window_y + padding) + debug_scroll;
if (content_height > debug_window_height) {
    var scrollbar_height = (debug_window_height / content_height) * debug_window_height;
    var scrollbar_y = debug_window_y + (debug_scroll / content_height) * debug_window_height;
    
    draw_set_color(c_gray);
    draw_rectangle(debug_window_x + debug_window_width - 5, scrollbar_y,
                  debug_window_x + debug_window_width, scrollbar_y + scrollbar_height, false);
}

// Reset drawing properties
draw_set_color(c_white);
draw_set_alpha(1); 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_test_controller
File: Step_0.gml
/// @description Handle Debug Window Interaction

// Handle mouse wheel scrolling
if (point_in_rectangle(mouse_x, mouse_y,
                      debug_window_x, debug_window_y,
                      debug_window_x + debug_window_width,
                      debug_window_y + debug_window_height)) {
    var wheel = mouse_wheel_down() - mouse_wheel_up();
    if (wheel != 0) {
        debug_scroll = clamp(debug_scroll + wheel * 20,
                           0,
                           max(0, ds_list_size(debug_messages) * 20 - debug_window_height));
    }
}

// Handle keyboard shortcuts
if (keyboard_check_pressed(vk_f12)) {
    // Rerun tests
    alarm[0] = 1;
}

if (keyboard_check_pressed(vk_escape)) {
    // Clear debug messages
    ds_list_clear(debug_messages);
    test_complete = false;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Create_0.gml
item_name = "Toboggan";
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];         // DOWN
toboggan_sprites[UP] = [24, 0];          // UP
toboggan_sprites[DOWN_RIGHT] = [48, 0];  // DOWN_RIGHT
toboggan_sprites[UP_LEFT] = [72, 0];     // UP_LEFT
toboggan_sprites[LEFT] = [96, 0];        // LEFT
toboggan_sprites[RIGHT] = [120, 0];      // RIGHT
toboggan_sprites[DOWN_LEFT] = [144, 0];   // Same as DOWN_RIGHT, flipped in Draw
toboggan_sprites[UP_RIGHT] = [168, 0];    // Same as UP_LEFT, flipped in Draw
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Draw_0.gml
var base_x = toboggan_sprites[face][0];
var base_y = toboggan_sprites[face][1];
var flip = (face == DOWN_LEFT || face == UP_RIGHT) ? -1 : 1;
draw_sprite_part_ext(spr_toboggan_sheet, 0, base_x, base_y, 24, 24, x - 12, y - 12, flip, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Step_0.gml
event_inherited();
item_name = "Toboggan";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tour_booth
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_town_complete
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Create_0.gml
item_name = "Tube";

// Core variables
face = DOWN;

// Assign sprite sheet directions (indices for spr_tube_sheet)
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        // UP, LEFT
tube_sprites[LEFT] = [0, 0];
tube_sprites[DOWN] = [24, 0];     // DOWN, RIGHT
tube_sprites[RIGHT] = [24, 0];
tube_sprites[UP_LEFT] = [48, 0];  // UP_LEFT, DOWN_RIGHT
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; // DOWN_LEFT, UP_RIGHT
tube_sprites[UP_RIGHT] = [72, 0];
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube_tower_decoration
File: Create_0.gml
item_name = "Tube";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube_tower_decoration
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Create_0.gml
// obj_ui_create.txt
// Initialize variables
ui_elements = []; // Array to store UI elements

// Example: Add a button to the UI
var button = {
    x: 100,
    y: 100,
    width: 200,
    height: 50,
    text: "Click Me",
    action: function() {
        show_message("Button Clicked!");
    }
};
array_push(ui_elements, button);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Draw_0.gml
// obj_ui_draw.txt
// Set font and alignment for UI text
draw_set_font(fnt_bumbastika_sml);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Draw UI elements
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    draw_rectangle(elem.x, elem.y, elem.x + elem.width, elem.y + elem.height, false);
    draw_text(elem.x + elem.width / 2, elem.y + elem.height / 2, elem.text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Mouse_4.gml
// obj_ui_leftpressed.txt
// Get mouse position
var mouse_x_pos = device_mouse_x_to_gui(0);
var mouse_y_pos = device_mouse_y_to_gui(0);

// Check if any UI element is clicked
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    if (mouse_x_pos > elem.x && mouse_x_pos < elem.x + elem.width && mouse_y_pos > elem.y && mouse_y_pos < elem.y + elem.height) {
        // Execute the action associated with the UI element
        elem.action();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui_manager
File: Create_0.gml
// obj_ui_manager Create Event
persistent = true; // Make persistent to stay across rooms
global.ui_manager = id;

// Initialize UI fonts
ui_fonts = {
    score: fnt_acme_explosive,      // For mini-game scores and high numbers
    general: fnt_bumbastika_sml,    // For general UI text
    impact: fnt_bonkfatty,          // For damage numbers and important notifications
    special: fnt_AgentCode          // For card games and special content
};

// Initialize UI sprites
ui_sprites = {
    panel: spr_blue_square_panel,
    button: spr_button,
    button_alt: spr_button_white,
    banner: spr_white_banner,
    progress: spr_blue_bar,
    dialog: spr_npc_dialouge_box,
    dialog_full: spr_npc_dialouge_full_window,
    chat: spr_chat_head_box
};

// Initialize UI configurations
ui_config = {
    achievement: {
        display_time: 3,            // Seconds to show achievement popup
        fade_time: 0.5,             // Seconds to fade out
        use_sprite: ui_sprites.dialog,
        use_font: ui_fonts.general
    },
    battle: {
        hp_bar_sprite: ui_sprites.progress,
        status_sprite: ui_sprites.banner,
        message_sprite: ui_sprites.dialog,
        damage_font: ui_fonts.impact
    },
    card_game: {
        background: ui_sprites.panel,
        status_bar: ui_sprites.banner,
        font: ui_fonts.special
    },
    tutorial: {
        window: ui_sprites.dialog_full,
        next_button: ui_sprites.button,
        font: ui_fonts.general
    },
    loading: {
        bar_bg: ui_sprites.banner,
        bar_fill: ui_sprites.progress,
        font: ui_fonts.general
    }
};

// Weather particle systems
if (!variable_global_exists("weather_systems")) {
    global.weather_systems = {
        snow: part_system_create(),
        rain: part_system_create()
    };
    
    // Snow particles using existing snow sprite
    var snow_particle = part_type_create();
    part_type_sprite(snow_particle, spr_snow_item, false, false, true);
    part_type_scale(snow_particle, 0.3, 0.3);
    part_type_alpha2(snow_particle, 0.8, 0);
    part_type_speed(snow_particle, 1, 2, 0, 0);
    part_type_direction(snow_particle, 260, 280, 0, 0.1);
    part_type_life(snow_particle, room_speed * 2, room_speed * 3);
    
    // Rain particles using modified snow sprite
    var rain_particle = part_type_create();
    part_type_sprite(rain_particle, spr_snow_item, false, false, true);
    part_type_scale(rain_particle, 0.1, 0.4);
    part_type_alpha2(rain_particle, 0.6, 0);
    part_type_speed(rain_particle, 8, 10, 0, 0);
    part_type_direction(rain_particle, 260, 280, 0, 0);
    part_type_life(rain_particle, room_speed, room_speed * 1.5);
    
    global.weather_particles = {
        snow: snow_particle,
        rain: rain_particle
    };
}

active_ui = noone;  // Current UI instance
inventory_instance = instance_exists(obj_inventory) ? obj_inventory : instance_create_layer(0, 0, "UI", obj_inventory);
depth = -1000;  // Above all UI elements

// Initialize emote system using existing player sprites
emote_config = {
    happy: { sprite: spr_player_body, frame: 0 },    // Normal stance
    wave: { sprite: spr_player_body, frame: 1 },     // Wave frame
    dance: { sprite: spr_player_body, frame: 2 },    // Dance frame
    sad: { sprite: spr_player_body, frame: 3 },      // Idle frame
    excited: { sprite: spr_player_body, frame: 4 }   // Action frame
};

show_debug_message("UI Manager initialized with consolidated assets.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui_manager
File: Step_0.gml
// obj_ui_manager Step Event
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_settings_menu);
if (!is_ui_room && !global.is_pause_menu_active) {
    if (instance_exists(inventory_instance) && active_ui == noone) {
        inventory_instance.visible = true;
    }
}
if (active_ui != noone && !instance_exists(active_ui)) {
    active_ui = noone;  // Clear if destroyed
    if (instance_exists(inventory_instance)) {
        inventory_instance.visible = true;
        show_debug_message("UI Manager restored inventory visibility.");
    }
}

// Function to open UI
function open_ui(ui_object) {
    if (active_ui != noone && instance_exists(active_ui)) {
        instance_destroy(active_ui);
    }
    active_ui = instance_create_layer(0, 0, "UI", ui_object);
    show_debug_message("UI opened: " + object_get_name(ui_object));
    return active_ui;
}

// Function to close UI
function close_ui() {
    if (active_ui != noone && instance_exists(active_ui)) {
        instance_destroy(active_ui);
        active_ui = noone;
        show_debug_message("UI closed.");
        // Reactivate expanded HUD if it exists
        if (instance_exists(obj_hud_expanded)) {
            obj_hud_expanded.is_active = true;
            show_debug_message("Reactivated expanded HUD after closing UI.");
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wall
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Alarm_0.gml
/// Alarm[0] Event
global.warp_cooldown = false;
show_debug_message("DEBUG: Warp cooldown finished. Player can warp again.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Create_0.gml
// obj_warp: Create Event
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
target_instance = noone;

global.warp_cooldown = true;
alarm[0] = room_speed / 2;

show_debug_message("obj_warp initialized. Target Room: " + string(target_rm));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Draw_0.gml
draw_sprite_tiled(sprite_index, image_index, 0, 0)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Other_7.gml
/// Animation End Event for obj_warp
show_debug_message("DEBUG: obj_warp transition initiated. Moving player before room transition.");
global.player_instance = target_instance; // Update global instance
// Ensure the player moves before switching rooms
if (target_instance != noone) {
	global.warp_target_x = target_x;
	global.warp_target_y = target_y;
	global.warp_target_face = target_face;
    show_debug_message("Player successfully moved to new position.");
} else {
    show_debug_message("ERROR: Target instance not found during warp.");
}

// Perform the room transition
room_goto(target_rm);

// Restore camera settings
if (instance_exists(global.camera)) {
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, 640, 480);
    show_debug_message("DEBUG: Camera viewport restored after room transition.");
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Step_0.gml
// Step Event for obj_warp
if (room == target_rm && image_index < 1) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Create_0.gml
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Other_4.gml
// Check if a warp instance exists
if (instance_exists(obj_warp)) {
    var warp_inst = instance_find(obj_warp, 0);
    if (warp_inst != noone) {
        if (instance_exists(global.player_instance)) {
            global.player_instance.x = warp_inst.target_x;
            global.player_instance.y = warp_inst.target_y;
            // Optional: Adjust the player's facing direction
            if (is_real(warp_inst.target_face)) {
                global.player_instance.face = warp_inst.target_face;
            }
        } else {
            show_debug_message("WARNING: Player instance does not exist for warping.");
        }
        instance_destroy(warp_inst);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Step_0.gml
/// Step Event for obj_warp_block

// Handle Player Warping
if (instance_exists(global.player_instance) && place_meeting(x, y, global.player_instance) && !instance_exists(obj_warp)) 
{
    show_debug_message("DEBUG: obj_player detected on obj_warp_block. Warping...");
    
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;   // Ensure correct target coordinates
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance; // Use global instance of player
	
}

// Handle Ice Truck Warping
if (instance_exists(obj_player_icetruck) && place_meeting(x, y, obj_player_icetruck) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = obj_player_icetruck.face;
    inst.target_instance = instance_find(obj_player_icetruck, 0);

}

/// Step Event for obj_warp_block

// Handle Player Warping
if (instance_exists(global.player_instance) && place_meeting(global.player_instance.x, global.player_instance.y, id) && !instance_exists(obj_warp)) 
{
    show_debug_message("DEBUG: obj_player_tube detected on obj_warp_block. Warping...");

    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;   // Correctly assign the warp block's values
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance;

    // Debugging output to confirm correct values are passed
    show_debug_message("Warping obj_player_tube to Room: " + string(inst.target_rm) +
        " Position: (" + string(inst.target_x) + ", " + string(inst.target_y) + ") Facing: " + string(inst.target_face));
}



// Handle NPC Warping
if (instance_exists(obj_npc_old) && place_meeting(x, y, obj_npc_old) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = obj_npc_old.face;
    inst.target_instance = instance_find(obj_npc_old, 0);

}

if (!global.warp_cooldown && instance_exists(global.player_instance) && place_meeting(global.player_instance.x, global.player_instance.y, id) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance;
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Create_0.gml
// obj_warp_map: Create Event
target_rm = noone;  // Set this in Creation Code
target_x = 0;  
target_y = 0;  
target_face = 0;  
depth = -9999;  // Ensure it's drawn on top
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Mouse_4.gml
// obj_warp_map: Left Pressed Event (Handles Click to Warp)
if (target_rm != noone) {
    show_debug_message("Warping to Room: " + string(target_rm) + " at (" + string(target_x) + ", " + string(target_y) + ")");
    
    // Store last room before warping
    global.last_room = room;  
    
    // Create warp instance to handle transition
    var warp_inst = instance_create_depth(0, 0, -9999, obj_warp);
    warp_inst.target_rm = target_rm;
    warp_inst.target_x = target_x;
    warp_inst.target_y = target_y;
    warp_inst.target_face = target_face;
    warp_inst.target_instance = global.player_instance;

	global.camera_reset = true; // Ensure camera resets correctly
    // Room transition handling
    room_goto(target_rm);

    // Improved handling to check if player instance exists after room transition
    alarm[0] = 2;  // Set alarm to delay camera setup and check for player existence
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wood_item
File: Create_0.gml
event_inherited();
item_name = "Wood";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wrench_item
File: Step_0.gml
event_inherited();
item_name = "Wrench";
