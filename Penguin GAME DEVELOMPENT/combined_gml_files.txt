Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_battery
File: Create_0.gml
event_inherited();
item_name = "Battery";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_beta_hat
File: Create_0.gml
event_inherited();
item_name = "Beta Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_big_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_boxpuffleo_item
File: Create_0.gml
event_inherited();
item_name = "Box Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_broken_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Broken Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_bulletin_board
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Alarm_0.gml
/// obj_camera: Alarm[0] Event (Handles delayed camera setup after room transition)
if (instance_exists(global.player_instance)) {
    camera_set_view_target(global.camera, global.player_instance);  // Attach camera to player
    camera_set_view_pos(global.camera, 
        global.player_instance.x - (camera_get_view_width(global.camera) / 2),
        global.player_instance.y - (camera_get_view_height(global.camera) / 2));
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);  // Reset zoom
    show_debug_message("DEBUG: Camera attached to player at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
} else {
    show_debug_message("ERROR: Player instance still not found. Retrying...");
    alarm[0] = 2;  // Retry after 2 frames if player instance is not found yet
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Create_0.gml
// Create Event for obj_camera
    global.camera = camera_create();
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New global camera created. ID: " + string(global.camera));
	
	global.camera_reset = false;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Other_4.gml
/// obj_camera - Room Start Event
if (global.camera_reset) {
    alarm[0] = 2; // Delay camera setup by 2 frames
    global.camera_reset = false;
} else {
    alarm[0] = 2; // Always delay on room start to ensure player exists
}

show_debug_message("DEBUG: Room Start - Camera setup delayed by 2 frames.");

// Ensure the camera is valid
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New global camera created. ID: " + string(global.camera));
} else {
    view_set_camera(0, global.camera);
    show_debug_message("DEBUG: Reattached to existing global camera. ID: " + string(global.camera));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_camera
File: Step_0.gml
// obj_camera Step Event
if (instance_exists(global.player_instance)) {
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);
    target_x = clamp(target_x, 0, room_width - camera_get_view_width(global.camera));
    target_y = clamp(target_y, 0, room_height - camera_get_view_height(global.camera));
    camera_set_view_pos(global.camera, 
        lerp(camera_get_view_x(global.camera), target_x, 0.9),
        lerp(camera_get_view_y(global.camera), target_y, 0.9));
} else if (alarm[0] == -1) { // Only retry if alarm isnâ€™t already set
    show_debug_message("WARNING: Player instance missing. Trying again in 2 frames...");
    alarm[0] = 2;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Create_0.gml
// Create Event for Unified Chat System
global.chat_active = false;
global.chat_npc = noone;
dialog_queue = [];
dialog_index = 0;
choice_selected = 0; // For future choice-based dialogs

depth = -1000;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Draw_0.gml
if (global.chat_active) {
    // Draw chat window
    var window_width = 400;
    var window_height = 200;
    var window_x = camera_get_view_x(global.camera) + (camera_get_view_width(global.camera) / 2) - (window_width / 2);
    var window_y = camera_get_view_y(global.camera) + camera_get_view_height(global.camera) - window_height - 20;

    draw_sprite_stretched(spr_chat, 0, window_x, window_y, window_width, window_height);

    // Draw text
    draw_set_color(c_black);
    draw_text(window_x + 20, window_y + 20, dialog_queue[dialog_index]);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Mouse_4.gml
// Mouse Left Pressed Event
if (global.chat_active) {
    var camera_x = camera_get_view_x(global.camera);
    var camera_y = camera_get_view_y(global.camera);
    var camera_width = camera_get_view_width(global.camera);
    var camera_height = camera_get_view_height(global.camera);

    var menu_width = 300;
    var menu_height = 150;
    var menu_x = camera_x + (camera_width - menu_width) / 2;
    var menu_y = camera_y + camera_height - menu_height - 50;

    var close_button_size = 20;
    var close_x = menu_x + menu_width - close_button_size - 20;
    var close_y = menu_y + 20;

    if (mouse_x >= close_x && mouse_x <= close_x + close_button_size &&
        mouse_y >= close_y && mouse_y <= close_y + close_button_size) {
        global.chat_active = false;
        global.chat_npc = noone;
        dialog_queue = [];
        show_debug_message("Close button clicked. Chat deactivated.");
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_chat_window
File: Step_0.gml
if (global.chat_active) {
    // Advance dialog with Spacebar
    if (keyboard_check_pressed(vk_space)) {
        if (dialog_index < array_length(dialog_queue) - 1) {
            dialog_index++;
        } else {
            global.chat_active = false;
            dialog_index = 0;
            global.chat_npc = noone;
        }
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Create_0.gml
// Initialize state
image_index = 0; // Default: not selected
is_selected = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_icon
File: Mouse_4.gml

// Deselect all other color icons
with (obj_color_icon) {
    image_index = 0; // Not selected
    is_selected = false;
}

// Select this icon
image_index = 1; // Selected
is_selected = true;

// Set global player color
global.player_color = icon_color;
global.last_player_color = global.player_color; // Save the choice persistently


// Ensure this icon is assigned a valid color
if (icon_color == undefined) {
    show_debug_message("ERROR: Icon color is undefined in obj_color_icon.");
    icon_color = c_white; // Default to white
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_picker_controller
File: Create_0.gml
// Define custom colors
var c_notblack = make_color_rgb(51, 59, 70);
var c_bluer = make_color_rgb(41, 82, 172);
var c_brown = make_color_rgb(150, 102, 36);
var c_cyan = make_color_rgb(7, 167, 163);
var c_emerald = make_color_rgb(7, 106, 68);
var c_greener = make_color_rgb(6, 155, 77);
var c_lavender = make_color_rgb(176, 126, 194);
var c_lightblue = make_color_rgb(8, 153, 211);
var c_mint = make_color_rgb(189, 252, 201);
var c_oranger = make_color_rgb(232, 94, 28);
var c_pink = make_color_rgb(234, 20, 160);
var c_purpler = make_color_rgb(102, 49, 158);
var c_reder = make_color_rgb(210, 13, 48);
var c_salmon = make_color_rgb(233, 98, 110);
var c_yellower = make_color_rgb(234, 194, 25);

// Colors array
var colors = [
    c_notblack, c_bluer, c_brown, c_cyan, c_emerald,
    c_greener, c_lavender, c_lightblue, c_mint, c_oranger,
    c_pink, c_purpler, c_reder, c_salmon, c_yellower
];

// Sprites for color icons
var sprites = [
    spr_colouricon_black, spr_colouricon_blue, spr_colouricon_brown, spr_colouricon_cyan, spr_colouricon_emerald,
    spr_colouricon_green, spr_colouricon_lavendar, spr_colouricon_lightblue, spr_colouricon_mint, spr_colouricon_orange,
    spr_colouricon_pink, spr_colouricon_purple, spr_colouricon_red, spr_colouricon_salmon, spr_colouricon_yellow
];

// Grid dimensions
var cols = 5;
var rows = 3;
var spacing = 70; // Distance between grid items
var start_x = room_width / 2.2 - ((cols - 1) * spacing) / 2;
var start_y = room_height / 2.2 - ((rows - 1) * spacing) / 2;

// Create the grid
for (var i = 0; i < array_length(colors); i++) { // Use array_length explicitly
    var x_pos = start_x + (i mod cols) * spacing;
    var y_pos = start_y + (i div cols) * spacing;

    // Create color icon instance
    var color_icon = instance_create_layer(x_pos, y_pos, "Instances", obj_color_icon);
    color_icon.icon_color = colors[i];       // Assign color
    color_icon.sprite_index = sprites[i];    // Assign corresponding sprite
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Create_0.gml
depth = -1000;
// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Initialize variables
selected_color = c_white;
global.player_color = c_white;

// Define selection areas
color_wheel_x = x + 31;
color_wheel_y = y + 19;
color_wheel_width = 46;
color_wheel_height = 46;

exit_x = x + 6;
exit_y = y + 6;
exit_width = 9;
exit_height = 9;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Draw_0.gml
// Draw the background first
draw_sprite(spr_colorpicker_background, 0, x, y);

// Draw the color wheel directly without using the surface
draw_sprite(spr_color_bar, 0, x + 31, y + 19);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Mouse_4.gml
var mx = (device_mouse_x_to_gui(0) / display_get_gui_width()) * camera_get_view_width(global.camera) + camera_get_view_x(global.camera);
var my = (device_mouse_y_to_gui(0) / display_get_gui_height()) * camera_get_view_height(global.camera) + camera_get_view_y(global.camera);

// Check if the player clicked inside the exit button (6,6 to 14,14)
if (point_in_rectangle(mx, my, exit_x, exit_y, exit_x + exit_width, exit_y + exit_height)) {
    show_debug_message("Closing color wheel...");
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
    return;
}

// Check if the click is inside the color wheel selection area
if (point_in_rectangle(mx, my, color_wheel_x, color_wheel_y, color_wheel_x + color_wheel_width, color_wheel_y + color_wheel_height)) {
    var sx = mx - color_wheel_x; // Convert to surface coordinates
	var sy = my - color_wheel_y;

	if (sx >= 0 && sy >= 0 && sx < sprite_get_width(spr_color_bar) && sy < sprite_get_height(spr_color_bar)) {
		selected_color = surface_getpixel(surf_color_wheel, sx, sy);
	}

   if (selected_color != c_black) { // Avoid selecting transparent areas
    global.player_color = selected_color;

    if (instance_exists(global.player_instance)) {
        global.player_instance.image_blend = global.player_color;
    }

    show_debug_message("Color selected: " + string(selected_color));
    
    // Close color wheel & pause menu
    with (obj_pause_menu) instance_destroy();
    instance_destroy();
	}
}

show_debug_message("Color picked: " + string(draw_getpixel(mx, my)));
show_debug_message("Fixed Mouse World X: " + string(mouse_world_x) + " | Y: " + string(mouse_world_y));
show_debug_message("View X: " + string(camera_get_view_x(global.camera)) + " | View Y: " + string(camera_get_view_y(global.camera)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_color_wheel
File: Step_0.gml
// Handle mouse click for selecting a color
if (mouse_check_button_pressed(mb_left)) {
    var mx = device_mouse_x_to_gui(0);
    var my = device_mouse_y_to_gui(0);

    if (point_in_rectangle(mx, my, x, y, x + sprite_width, y + sprite_height)) {
        var sx = mx - x; // Convert to surface coordinates
        var sy = my - y;

        // Ensure the surface exists before sampling
        if (surface_exists(surf_color_wheel)) {
            selected_color = surface_getpixel(surf_color_wheel, sx, sy);
        } else {
            selected_color = c_black; // Fallback
        }

        // Apply color globally if valid
        if (selected_color != c_black) {
            global.player_color = selected_color;
            if (instance_exists(global.player_instance)) {
                global.player_instance.image_blend = global.player_color;
            }
            show_debug_message("Color selected: " + string(selected_color));
        }
        
        // Close the color wheel and return to previous room
        if (variable_global_exists("last_room") && global.last_room != noone) {
            room_goto(global.last_room);
        } else {
            room_goto(rm_town); // Default return room
        }
        instance_destroy();
    }
}


// Debug mouse position
show_debug_message("Mouse X: " + string(mouse_x) + " | Mouse Y: " + string(mouse_y));
show_debug_message("GUI Mouse X: " + string(device_mouse_x_to_gui(0)) + " | GUI Mouse Y: " + string(device_mouse_y_to_gui(0)));
show_debug_message("View X: " + string(camera_get_view_x(view_camera[0])) + " | View Y: " + string(camera_get_view_y(view_camera[0])));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Alarm_0.gml
// Ensure the new player instance is created after the previous one is destroyed
if (global.skin_to_spawn != noone) {
    var player_x = global.last_player_x;
    var player_y = global.last_player_y;

    // Create the new player instance
    global.player_instance = instance_create_layer(player_x, player_y, "Instances", global.skin_to_spawn);
    global.current_skin = global.skin_name_to_spawn;

    // Reset the temporary skin variables
    global.skin_to_spawn = noone;
    global.skin_name_to_spawn = "";

    // Ensure camera follows the new player
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
        if (global.debug) show_debug_message("Skin switched to: " + global.current_skin + ". New instance ID: " + string(global.player_instance));
    } else {
        if (global.debug) show_debug_message("ERROR: Failed to create player instance.");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Create_0.gml
/// Create Event for obj_controller
global.debug = true; // Set to false for release builds
global.player_controls_enabled = true;
persistent = true;

// Initialize global variables early
global.dialogue_active = false;
global.countdown_timer = 5 * room_speed; // 5 seconds countdown
global.is_pause_menu_active = false;
global.game_started = false;
global.lives = 3;
game_timer = 0;
global.skin_switching = false;
global.high_scores = [0, 0, 0];  // Top 3 scores

// Sled racing globals
if (!variable_global_exists("sled_difficulty")) {
    global.sled_difficulty = "easy"; // Default difficulty
}
if (!variable_global_exists("selected_sled")) {
    global.selected_sled = "standard"; // Default sled
}
if (!variable_global_exists("sled_score")) {
    global.sled_score = 0;
}
if (!variable_global_exists("high_scores")) {
    global.high_scores = []; // Array for top 5 scores
}

if (!variable_global_exists("selected_sled_type")) {
    global.selected_sled_type = "Tube"; // Default
}

// Skins array
global.skins = [
    { name: "player", object: obj_player },
    { name: "icetruck", object: obj_player_icetruck },
    { name: "tube", object: obj_player_tube },
    { name: "toboggan", object: obj_player_toboggan },
    { name: "sled_player", object: obj_sled_player },
    { name: "ninja", object: obj_player_ninja }
];

global.current_skin = "player";
global.player_instance = noone;
global.icetruck_destroyed = false;

// Room state management
if (!variable_global_exists("room_states")) {
    global.room_states = ds_map_create();
}
global.current_room = room;

// Spawn player if none exists
if (global.player_instance == noone) {
    global.player_instance = instance_create_layer(x, y, "Instances", obj_player);
}

if (instance_exists(global.player_instance)) {
    global.player_instance.image_blend = global.player_color;
    if (global.debug) show_debug_message("Restored player color: " + string(global.player_color));
}

if (global.debug) show_debug_message("obj_controller Create event executed");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_4.gml
/// Room Start Event for obj_controller
load_room_state(room);
if (global.debug) show_debug_message("DEBUG: Room Start Event triggered in obj_controller.");

var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || 
                  room == rm_pause_menu || room == rm_sled_menu || room == rm_settings_menu);

if (is_ui_room) {
    if (global.debug) show_debug_message("DEBUG: UI Room detected. Removing player instance.");
    if (instance_exists(global.player_instance)) {
        global.last_player_x = global.player_instance.x;
        global.last_player_y = global.player_instance.y;
        instance_destroy(global.player_instance);
        global.player_instance = noone;
    }
} else {
    if (!instance_exists(global.player_instance)) {
        var player_x = variable_global_exists("last_player_x") ? global.last_player_x : 170;
        var player_y = variable_global_exists("last_player_y") ? global.last_player_y : 154;
        var new_skin = obj_player; // Default
        for (var i = 0; i < array_length(global.skins); i++) {
            if (global.skins[i].name == global.current_skin) {
                new_skin = global.skins[i].object;
                break;
            }
        }
        global.player_instance = instance_create_layer(player_x, player_y, "Instances", new_skin);
        if (global.debug) show_debug_message("DEBUG: Player recreated at (" + string(player_x) + ", " + string(player_y) + ")");
    }
    if (instance_exists(global.player_instance)) {
        camera_set_view_target(global.camera, global.player_instance);
        if (global.debug) show_debug_message("DEBUG: Camera now follows player.");
    } else {
        if (global.debug) show_debug_message("ERROR: Camera could not follow new player instance.");
    }
}

// Ensure the camera follows the player
if (instance_exists(global.player_instance) && is_real(global.camera)) {
    var target_x = global.player_instance.x - (camera_get_view_width(global.camera) / 2);
    var target_y = global.player_instance.y - (camera_get_view_height(global.camera) / 2);

    camera_set_view_pos(global.camera, target_x, target_y);
}

// Ensure a "UI" layer exists for GUI elements
if (!layer_exists("UI")) {
    layer_create(0, "UI");
    if (global.debug) show_debug_message("DEBUG: UI layer created.");
} else {
    if (global.debug) show_debug_message("DEBUG: UI layer already exists.");
}

// Pause system
if (global.dialogue_active) {
    // Pause NPC and player movement during dialogue
    with (obj_player) { move_speed = 0; }
    with (obj_npc) { move_speed = 0; }
} else {
    // Resume NPC and player movement
    with (obj_player) { move_speed = move_spd; }
    with (obj_npc) { move_speed = move_spd; }
}

//Hide Inventory in the Pause Menu
if (room == rm_pause_menu || room == rm_sled_menu || rm_sled_racing) {
    // Hide inventory
    with (obj_inventory) {
        visible = false;
    }
    if (global.debug) show_debug_message("DEBUG: Inventory hidden in pause menu.");
} else {
    // Restore inventory visibility
    with (obj_inventory) {
        visible = true;
    }
    if (global.debug) show_debug_message("DEBUG: Inventory restored after pause menu.");
}

// Handle player instance and skin on room transition
if (!instance_exists(global.player_instance)) {
    if (global.current_skin == "player") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player);
    } else if (global.current_skin == "icetruck") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_icetruck);
    } else if (global.current_skin == "tube") {
        global.player_instance = instance_create_layer(x, y, "Instances", obj_player_tube);
    }
}

// Ensure the ice truck remains destroyed if it was destroyed previously
if (global.icetruck_destroyed && instance_exists(obj_icetruck)) {
    with (obj_icetruck) {
        instance_destroy();
    }
}

if (global.debug) show_debug_message("DEBUG: Room Start Event triggered in obj_controller.");

// Check and create the "UI" layer if it doesn't exist
if (!layer_exists("UI")) {
    layer_create(0, "UI");
    if (global.debug) show_debug_message("UI layer created successfully.");
} else {
    if (global.debug) show_debug_message("UI layer already exists.");
}

if (global.debug) show_debug_message("Pause menu closed.");
if (instance_exists(obj_skinpicker)) {
    if (global.debug) show_debug_message("Skin picker opened successfully.");
} else if (instance_exists(obj_color_wheel)) {
    if (global.debug) show_debug_message("Color wheel opened successfully.");
}

if (global.debug) show_debug_message("DEBUG: Room Start Event completed. Current skin: " + global.current_skin);
if (global.debug) show_debug_message("DEBUG: Player instance ID: " + string(global.player_instance));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Other_5.gml
save_room_state(room);
if (global.debug) show_debug_message("Saved state for room: " + room_get_name(room));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_controller
File: Step_0.gml
/// Step Event for obj_controller

// Toggle Pause Menu with ESC
if (keyboard_check_pressed(vk_escape) && !global.colour_picker_active) {
    global.is_pause_menu_active = !global.is_pause_menu_active;
    if (global.is_pause_menu_active) {
        global.player_controls_enabled = false;
        show_debug_message("Game Paused");
    } else {
        global.player_controls_enabled = true;
        show_debug_message("Game Resumed");
    }
}
if (global.is_pause_menu_active) exit;

// Toggle expanded inventory
if (keyboard_check_pressed(ord("I"))) {
    if (instance_exists(obj_inventory_expanded)) {
        with (obj_inventory_expanded) {
            instance_destroy();
        }
        global.game_paused = false;
    } else {
        instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
        global.game_paused = true;
    }
}

// Toggle icetruck colour picker with "C" when skin is icetruck
if (keyboard_check_pressed(ord("C")) && global.current_skin == "icetruck") {
    if (instance_exists(obj_icetruck_colourpicker)) {
        with (obj_icetruck_colourpicker) instance_destroy();
    } else {
        instance_create_layer(0, 0, "Instances", obj_icetruck_colourpicker);
    }
}

// Hide inventory in UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_sled_menu || room == rm_sled_racing || room == rm_settings_menu);
if (is_ui_room) {
    if (instance_exists(obj_inventory)) {
        with (obj_inventory) {
            visible = false;
        }
        show_debug_message("DEBUG: Inventory hidden in UI room.");
    }
} else {
    if (instance_exists(obj_inventory)) {
        with (obj_inventory) {
            visible = true;
        }
    }
}

// Hide Player in UI rooms
var is_playerui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_sled_menu  || room == rm_settings_menu);
if (is_playerui_room) {
    if (instance_exists(obj_controller)) {
        with (obj_controller) {
            visible = false;
        }
        show_debug_message("DEBUG: Inventory hidden in UI room.");
    }
} else {
    if (instance_exists(obj_controller)) {
        with (obj_controller) {
            visible = true;
        }
    }
}

// Function to switch player skins
function switch_skin(new_skin) {
    if (global.skin_switching) return;
    global.skin_switching = true;

    var player_x = global.player_instance != noone ? global.player_instance.x : global.last_player_x;
    var player_y = global.player_instance != noone ? global.player_instance.y : global.last_player_y;
    var player_face = DOWN;
    var saved_icetruck_tint = c_white;

    // Preserve tint if switching from icetruck
    if (instance_exists(global.player_instance) && global.current_skin == "icetruck") {
        saved_icetruck_tint = global.player_instance.icetruck_tint;
    }

    if (instance_exists(global.player_instance)) {
        if (variable_instance_exists(global.player_instance, "face")) {
            player_face = global.player_instance.face;
        }
        instance_destroy(global.player_instance);
    }

    var new_instance = noone;
    var skin_found = false;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (global.skins[i].name == new_skin) {
            new_instance = instance_create_layer(player_x, player_y, "Instances", global.skins[i].object);
            global.current_skin = new_skin;
            skin_found = true;
            break;
        }
    }

    if (!skin_found || new_instance == noone) {
        new_instance = instance_create_layer(player_x, player_y, "Instances", obj_player);
        global.current_skin = "player";
        show_debug_message("WARNING: Defaulted to player skin. Invalid skin name: " + new_skin);
    }

    if (variable_instance_exists(new_instance, "face")) {
        new_instance.face = player_face;
    }
    if (new_skin == "icetruck" && variable_instance_exists(new_instance, "icetruck_tint")) {
        new_instance.icetruck_tint = saved_icetruck_tint;
    }

    global.player_instance = new_instance;
    camera_set_view_target(global.camera, global.player_instance);
    show_debug_message("Switched to skin: " + new_skin + ". New instance ID: " + string(new_instance));

    global.skin_switching = false;
}

// In Step_0.gml, under the rm_sled_racing block:
if (room == rm_sled_racing) {
    if (!instance_exists(obj_sled_player)) {
        var sled_x, sled_y;
        switch (irandom_range(1, 4)) {
            case 1: sled_x = 90; sled_y = 41; break;
            case 2: sled_x = 118; sled_y = 41; break;
            case 3: sled_x = 146; sled_y = 41; break;
            case 4: sled_x = 174; sled_y = 41; break;
        }
        global.player_instance = instance_create_layer(sled_x, sled_y, "Instances", obj_sled_player);
        show_debug_message("Spawning obj_sled_player at (" + string(sled_x) + ", " + string(sled_y) + ")");
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_crates
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Create_0.gml
// Set item properties
item_type = ""; // Set when the object is created
sprite_index = spr_inventory_items;
is_savable = true; // Mark as savable
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Draw_0.gml
// Draw the dropped item
draw_sprite(sprite_index, 0, x, y);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_dropped_item
File: Step_0.gml
// Check if player picks up the item
if (distance_to_object(global.player_instance) < 16 && keyboard_check_pressed(ord("E"))) {
    obj_inventory.add_to_inventory(item_type);
    instance_destroy();
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_epfphone_item
File: Create_0.gml
event_inherited();
item_name = "EPF Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel1
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel2
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel3
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishbarrel4
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_fishing_rod
File: Create_0.gml
event_inherited();
item_name = "Fishing Rod";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icepath
File: Step_0.gml
if (global.obstacles_moving) {
    y -= global.scroll_speed;
    if (y < -sprite_height) {
        y = room_height + sprite_height;
        x = irandom_range(0, room_width - sprite_width);
    }
    if (place_meeting(x, y, obj_sled_player)) {
        with (obj_sled_player) move_spd = 7;
    } else {
        with (obj_sled_player) move_spd = (global.selected_sled_type == "Tube") ? 4 : 4;
		with (obj_sled_player) move_spd = (global.selected_sled_type == "Toboggan") ? 4 : 4;
    }
}
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint
mask_index = spr_icetruck_down; // For collision detection

// Existing state variables
repair_required = false;
is_driveable = true;
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming DOWN direction
var frame_y = 0;
var frame_width = 48;
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display interaction prompt when player is close
if (distance_to_object(global.player_instance) < 16 && global.current_skin == "player") {
    var text = "Press 'E' to drive";
    var text_width = string_width(text);
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x + (sprite_width / 2) - (text_width / 2), y - 20, text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck
File: Step_0.gml
// Ensure the truck is repaired before allowing entry
if (!repair_required) { 
    if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 32) {
        if (global.current_skin == "player") {
            // Enter the ice truck
            var player_x = global.player_instance.x;
            var player_y = global.player_instance.y;

            instance_destroy(global.player_instance); // Remove player
            instance_destroy(id); // Remove icetruck

            global.player_instance = instance_create_layer(player_x, player_y, "Instances", obj_player_icetruck);
            global.current_skin = "icetruck";

            show_debug_message("Entered ice truck. Current skin: " + global.current_skin);
        }
    }
} else {
    show_debug_message("The truck is still broken! Repair it first.");
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_0.gml
global.repair_cooldown = false;
show_debug_message("Repair cooldown ended. You can now enter the truck.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Alarm_1.gml
show_debug_message("DEBUG: Resetting repair flag...");
global.repair_complete = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Create_0.gml
// Sprite definitions
sprite_base = spr_icetruck_base_empty_repairable;
sprite_colour = spr_icetruck_colour;
sprite_window = spr_icetruck_window;
icetruck_tint = c_yellow; // Default tint, consistent with obj_player_icetruck
mask_index = spr_icetruck_facedown; // For collision detection

// Existing state variables
repair_required = true;
repair_complete = false;
global.repair_complete = false;
is_driveable = false;

alarm[1] = 5; // Keep the repair flag active for 5 frames
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Draw_0.gml
// Define drawing position and frame (static, facing DOWN)
var draw_x = x;
var draw_y = y;
var frame_x = 0; // Assuming frame 0 is the DOWN direction
var frame_y = 0;
var frame_width = 48; // Match sprite sheet dimensions
var frame_height = 48;

depth = -1000; // Maintain existing depth

// Draw layered sprites
draw_sprite_part(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, icetruck_tint, 1);
draw_sprite_part(sprite_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y);

// Display repair prompt if player is near
if (distance_to_object(obj_player) < 24) {
    draw_set_font(fnt_earlygb);
    draw_set_color(c_black);
    draw_text(x - 20, y - 20, "Press 'R' to repair");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_broken
File: Step_0.gml
// Ensure player is near and pressing "R" to repair
if (keyboard_check_pressed(ord("R")) && distance_to_object(obj_player) < 16) {
    if (obj_inventory.has_item("Wrench") > 0 || obj_inventory.has_item("Battery") > 0) {
    
        show_debug_message("Repairing ice truck...");
        
        // Destroy the broken truck
        instance_destroy();
        
        // Replace with repaired version
        var new_truck = instance_create_layer(x, y, "Instances", obj_icetruck);
        new_truck.repair_required = false;
		new_truck.repair_complete = true;
		global.repair_complete = true;
		show_debug_message("DEBUG: Setting global.repair_complete = true");
        new_truck.is_driveable = true;

        // Prevent instant entry by disabling key input for a short time
        global.repair_cooldown = true;
        alarm[0] = 30; // 0.5 sec cooldown
        
        show_debug_message("Ice truck repaired! It is now driveable.");
    } else {
        show_debug_message("You need a wrench or a battery to repair this!");
		show_debug_message("Has Wrench: " + string(obj_inventory.has_item("Wrench")));
		show_debug_message("Has Battery: " + string(obj_inventory.has_item("Battery")));
		show_debug_message("Distance to player: " + string(distance_to_object(obj_player)));
		if (keyboard_check_pressed(ord("R"))) {
	    show_debug_message("R key pressed");
	}
    }
}

// Ensure correct depth
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Create_0.gml
// Create Event for obj_icetruck_colourpicker
depth = -1000;
scale = 3; // Scaling factor (adjust as needed)
preview_tint = instance_exists(obj_player_icetruck) ? obj_player_icetruck.icetruck_tint : c_white; // Initial tint

// Adjusted dimensions with scaling
picker_width = sprite_get_width(spr_icetruck_colourpicker) * scale;
picker_height = sprite_get_height(spr_icetruck_colourpicker) * scale;

// Center on GUI
gui_width = display_get_gui_width();
gui_height = display_get_gui_height();
x = (gui_width - picker_width) / 2;
y = (gui_height - picker_height) / 2;

// Colour options
colours = [c_red, c_blue, c_green, c_yellow, c_purple, c_orange];
colour_slots = [
    [10 * scale, 95 * scale, 27 * scale, 112 * scale],
    [30 * scale, 95 * scale, 47 * scale, 112 * scale],
    [50 * scale, 95 * scale, 67 * scale, 112 * scale],
    [70 * scale, 95 * scale, 87 * scale, 112 * scale],
    [90 * scale, 95 * scale, 107 * scale, 112 * scale],
    [110 * scale, 95 * scale, 127 * scale, 112 * scale]
];

// Viewer position (scaled)
viewer_x = 11 * scale;
viewer_y = 16 * scale;
viewer_width = (124 - 11) * scale;
viewer_height = (90 - 16) * scale;

global.colour_picker_active = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Destroy_0.gml
// Destroy Event for obj_icetruck_colourpicker
if (instance_exists(obj_player_icetruck)) {
    obj_player_icetruck.icetruck_tint = preview_tint;
    show_debug_message("Icetruck tint updated to: " + string(preview_tint));
}
global.colour_picker_active = false;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Draw_64.gml
// Draw GUI Event for obj_icetruck_colourpicker
draw_sprite_ext(spr_icetruck_colourpicker, 0, x, y, scale, scale, 0, c_white, 1);

// Draw colour squares
for (var i = 0; i < 6; i++) {
    var slot = colour_slots[i];
    draw_rectangle_color(x + slot[0], y + slot[1], x + slot[2], y + slot[3], colours[i], colours[i], colours[i], colours[i], false);
}

// Draw static icetruck preview with preview_tint
var frame_x = 0; // DOWN direction frame 1
var frame_y = 0;
var frame_width = 48;
var frame_height = 48;
var draw_x = x + viewer_x + (viewer_width - frame_width * scale) / 2;
var draw_y = y + viewer_y + (viewer_height - frame_height * scale) / 2;

draw_sprite_part_ext(spr_icetruck_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, scale, scale, c_white, 1);
draw_sprite_part_ext(spr_icetruck_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, scale, scale, preview_tint, 1);
draw_sprite_part_ext(spr_icetruck_penguin_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, scale, scale, global.player_color, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Mouse_4.gml
// Mouse Pressed Event for obj_icetruck_colourpicker
var mx = device_mouse_x_to_gui(0);
var my = device_mouse_y_to_gui(0);

for (var i = 0; i < array_length(colour_slots[i]); i++) {
    var slot_x = x + slot_positions[i][0];
    var slot_y = y + slot_positions[i][1];
    if (point_in_rectangle(mx, my, slot_x, slot_y, slot_x + 17, slot_y + 17)) {
        if (instance_exists(obj_player_icetruck)) {
            obj_player_icetruck.icetruck_tint = color_options[i];
            show_debug_message("Ice truck color changed to: " + string(color_options[i]));
        }
        break;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_icetruck_colourpicker
File: Step_0.gml
// Step Event for obj_icetruck_colourpicker
if (global.game_paused || !instance_exists(obj_player_icetruck)) {
    instance_destroy();
    exit;
}

// Close menu with Escape or C
if (keyboard_check_pressed(vk_escape) || keyboard_check_pressed(ord("C"))) {
    instance_destroy();
}

// Mouse input for colour selection
if (mouse_check_button_pressed(mb_left)) {
    var mx = mouse_x - x;
    var my = mouse_y - y;
    for (var i = 0; i < 6; i++) {
        var slot = colour_slots[i];
        if (mx >= slot[0] && mx <= slot[2] && my >= slot[1] && my <= slot[3]) {
            preview_tint = colours[i]; // Update preview tint
            show_debug_message("Selected colour: " + string(i));
            break;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Create_0.gml
/// Create Event for obj_initializer

// Initialize inventory items
if (!variable_global_exists("item_index_map")) {
    global.item_index_map = ds_map_create();
    var item_names = ["Beta Hat", "Party Hat", "Wrench", "Tube", "Toboggan", "Battery", "Spy Phone", "Broken Spy Phone", "EPF Phone","Fishing Rod", "Jackhammer", "Snow Shovel", "Pizza Slice",  "Puffle O", "Box Puffle O", "Fish", "Mullet", "Wood", "Snow"];
    for (var i = 0; i < array_length(item_names); i++) {
        ds_map_add(global.item_index_map, item_names[i], i);
    }
    show_debug_message("DEBUG: global.item_index_map initialized in obj_initializer.");
} else {
    show_debug_message("DEBUG: global.item_index_map already exists.");
}

// Initialize dropped items
if (!variable_global_exists("item_object_map")) {
    global.item_object_map = ds_map_create();
    ds_map_add(global.item_object_map, "Battery", obj_battery);
    ds_map_add(global.item_object_map, "Box Puffle O", obj_boxpuffleo_item);
    ds_map_add(global.item_object_map, "EPF Phone", obj_epfphone_item);
    ds_map_add(global.item_object_map, "Fishing Rod", obj_fishing_rod);
    ds_map_add(global.item_object_map, "Jackhammer", obj_Jackhammer_item);
    ds_map_add(global.item_object_map, "Map", obj_map_item);
    ds_map_add(global.item_object_map, "Party Hat", obj_party_hat);
	ds_map_add(global.item_object_map, "Beta Hat", obj_beta_hat);
    ds_map_add(global.item_object_map, "Pizza Slice", obj_pizzaslice_item);
    ds_map_add(global.item_object_map, "Puffle O", obj_puffleo_item);
    ds_map_add(global.item_object_map, "Puffle Whistle", obj_pufflewhistle_item);
    ds_map_add(global.item_object_map, "Snow", obj_snow_item);
    ds_map_add(global.item_object_map, "Snow Shovel", obj_snowshovel_item);
	ds_map_add(global.item_object_map, "Broken_Spy Phone", obj_broken_spyphone_item);
    ds_map_add(global.item_object_map, "Spy Phone", obj_spyphone_item);
    ds_map_add(global.item_object_map, "Stamp Book", obj_stampbook_item);
    ds_map_add(global.item_object_map, "Starter Deck", obj_starterdeck_item);
    ds_map_add(global.item_object_map, "Wood", obj_wood_item);
    ds_map_add(global.item_object_map, "Tube", obj_tube);
	ds_map_add(global.item_object_map, "Toboggan", obj_toboggan);
	ds_map_add(global.item_object_map, "Wrench", obj_wrench_item);
    show_debug_message("DEBUG: global.item_object_map initialized in obj_initializer.");
} else {
    show_debug_message("DEBUG: global.item_object_map already exists.");
}

//initialize expanded inventory
if (!variable_global_exists("inventory_expanded")) {
    global.inventory_expanded = false;
}

// obj_initializer: Create Event (append to existing code)
if (!instance_exists(obj_inventory)) {
    instance_create_layer(0, 0, "Instances", obj_inventory);
}
if (!instance_exists(obj_map_icon)) {
    instance_create_layer(0, 0, "Instances", obj_map_icon);
}

// obj_initializer: Create Event (append)
if (!variable_global_exists("game_paused")) {
    global.game_paused = false;
}
//init expanded inventory equipped items
if (!variable_global_exists("equipped_items")) {
    global.equipped_items = {
        head: -1,
        face: -1,
        neck: -1,
        body: -1,
        hand: -1,
        feet: -1
    };
}
//init special action sprites
if (!variable_global_exists("item_player_sprites")) {
    global.item_player_sprites = ds_map_create();
    ds_map_add(global.item_player_sprites, 0, spr_player_betahat); // Beta Hat
	ds_map_add(global.item_player_sprites, 1, spr_player_partyhat); // Party Hat
    ds_map_add(global.item_player_sprites, ds_map_find_value(global.item_index_map, "Jackhammer"), spr_jackhammer_object);
    ds_map_add(global.item_player_sprites, ds_map_find_value(global.item_index_map, "Snow Shovel"), spr_snowshovel_object);
}
//init expanded inventory clothing item sprites
if (!variable_global_exists("item_type_map")) {
    global.item_type_map = ds_map_create();
    ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Beta Hat"), "head");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Party Hat"), "head");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Cool Shades"), "face");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Scarf"), "neck");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Jacket"), "body");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Gloves"), "hand");
	ds_map_add(global.item_type_map, ds_map_find_value(global.item_index_map, "Boots"), "feet");
// Add all other clothing items similarly
}

// Ensure party_hat_visible is set (default to false)
if (!variable_global_exists("party_hat_visible")) {
    global.party_hat_visible = false;
}

// Ensure beta_hat_visible is set (default to false)
if (!variable_global_exists("beta_hat_visible")) {
    global.beta_hat_visible = false;
}

// Initialize the global camera
if (!variable_global_exists("camera") || !is_real(global.camera)) {
    global.camera = camera_create();
    camera_set_view_size(global.camera, view_wview[0], view_hview[0]);
    camera_set_view_pos(global.camera, 0, 0);
    show_debug_message("DEBUG: New camera created.");
}
view_set_camera(0, global.camera);

// Ensure global player instance is correctly set
if (!variable_global_exists("player_instance") || global.player_instance == noone) {
    if (instance_exists(obj_player)) {
        global.player_instance = obj_player;
    } else if (instance_exists(obj_sled_player)) {
        global.player_instance = obj_sled_player;
    } else if (instance_exists(obj_player_icetruck)) {
        global.player_instance = obj_player_icetruck;
    } else if (instance_exists(obj_player_tube)) {
        global.player_instance = obj_player_tube;
    }
    show_debug_message("DEBUG: global.player_instance set to: " + string(global.player_instance));
}

//initialize icetruck colour picker
global.colour_picker_active = false;

show_debug_message("DEBUG: obj_initializer Create Event executed.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Other_2.gml
// Initialize all required global variables
global.player_instance = noone;
global.player_instance_initialized = false;
global.camera = noone;
global.current_skin = "player"; // Default skin
global.initialized = false; // To track overall initialization

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_initializer
File: Step_0.gml
// Step Event for obj_initializer

// Ensure the camera is correctly set to follow the player
var cam = camera_create();
camera_set_view_target(cam, global.player_instance);
camera_apply(cam);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Create_0.gml
// obj_inventory: Create Event
inventory_size = 42;
inventory = array_create(inventory_size, -1);
active_slot = 0;
global.active_item_index = active_slot;
persistent = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Draw_64.gml
// In obj_inventory Draw GUI Event
var ui_scale = 3; // Adjust to match obj_map_icon size
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();
var inv_width = sprite_get_width(spr_inventory_ui) * ui_scale;
var inv_height = sprite_get_height(spr_inventory_ui) * ui_scale;
var inv_x = (gui_width - inv_width) / 2;
var inv_y = gui_height - inv_height + 0 * ui_scale;
draw_sprite_ext(spr_inventory_ui, 0, inv_x, inv_y, ui_scale, ui_scale, 0, c_white, 1);

// Update slot positions
var slot_positions = [
    [inv_x + 5 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 25 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 45 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 65 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 85 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 105 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 125 * ui_scale, inv_y + 14 * ui_scale],
    [inv_x + 145 * ui_scale, inv_y + 14 * ui_scale]
];
for (var i = 0; i < 8; i++) {
    if (inventory[i] != -1) {
        var slot_x = slot_positions[i][0];
        var slot_y = slot_positions[i][1];
        draw_sprite_part_ext(spr_inventory_items, 0, inventory[i] * 18, 0, 18, 18, slot_x, slot_y, ui_scale, ui_scale, c_white, 1);
        if (i == active_slot) {
            draw_sprite_ext(spr_inventory_highlight, 0, slot_x - 1 * ui_scale, slot_y - 1 * ui_scale, ui_scale, ui_scale, 0, c_white, 1);
        }
    }
}

// Update click area for opening expanded inventory
var click_area_left = inv_x + 55 * ui_scale;
var click_area_top = inv_y + 3 * ui_scale;
var click_area_right = inv_x + 111 * ui_scale;
var click_area_bottom = inv_y + 9 * ui_scale;
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);
if (mouse_check_button_pressed(mb_left) &&
    gui_mouse_x >= click_area_left && gui_mouse_x <= click_area_right &&
    gui_mouse_y >= click_area_top && gui_mouse_y <= click_area_bottom &&
    !instance_exists(obj_inventory_expanded)) {
    instance_create_layer(0, 0, "Instances", obj_inventory_expanded);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory
File: Step_0.gml
// obj_inventory: Step Event
// Existing logic (scroll, drop, Tube, Party Hat, Beta Hat)
if (mouse_wheel_up()) {
    active_slot = min(active_slot + 1, 7);
    global.active_item_index = inventory[active_slot];
}
if (mouse_wheel_down()) {
    active_slot = max(active_slot - 1, 0);
    global.active_item_index = inventory[active_slot];
}
if (keyboard_check_pressed(ord("F"))) {
    drop_active_item();
}

// Remove the used item from inventory
if (keyboard_check_pressed(ord("R")) && global.repair_complete) { 
    show_debug_message("DEBUG: Repair complete flag detected in inventory."); 
    if (has_item("Battery")) {
        show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
        remove_item("Battery");
        show_debug_message("Battery removed after repair.");
    } else {
        show_debug_message("ERROR: Neither Battery nor Wrench found in inventory!");
    }
}

// Auto-remove Tube when switching to obj_player_tube
if (keyboard_check_pressed(ord("T")) && global.current_skin == "tube") {
    show_debug_message("Switching from tube to player");
    obj_controller.switch_skin("player");
    if (!has_item("Tube")) {
        add_to_inventory("Tube");
    }
    show_debug_message("Exited tube. Switched back to player. Tube added back to inventory.");
} else if (keyboard_check_pressed(ord("T")) && global.current_skin == "player" && has_item("Tube")) {
    show_debug_message("Switching from player to tube");
    obj_controller.switch_skin("tube");
    if (has_item("Tube")) {
        show_debug_message("Removing Tube from inventory...");
        remove_item("Tube");
    } else {
        show_debug_message("ERROR: Tube not found in inventory!");
    }
}

// Toggle Party Hat when pressing "P"
if (keyboard_check_pressed(ord("P"))) {
    var item_index = inventory[active_slot];
    if (item_index != -1) {
        var item_type = ds_map_find_value(global.item_type_map, item_index);
        if (!is_undefined(item_type) && variable_struct_exists(global.equipped_items, item_type)) {
            var equipped_item = global.equipped_items[$ item_type];
            if (equipped_item != -1) {
                // Swap back to inventory
                var empty_slot = array_find_index(inventory, function(val) { return val == -1; });
                if (empty_slot != -1) {
                    inventory[empty_slot] = equipped_item;
                } else {
                    show_debug_message("Inventory full, cannot swap out equipped item.");
                    exit;
                }
            }
            // Equip new item
            global.equipped_items[$ item_type] = item_index;
            inventory[active_slot] = -1;
            show_debug_message("Equipped " + item_type + " item: " + string(item_index));
        } else {
            show_debug_message("Cannot equip this item.");
        }
    } else {
        // Unequip logic (only unequip head if no item in active slot)
        var category = "head"; // Adjust if needed to support other categories
        if (global.equipped_items[$ category] != -1) {
            var empty_slot = array_find_index(inventory, function(val) { return val == -1; });
            if (empty_slot != -1) {
                inventory[empty_slot] = global.equipped_items[$ category];
                global.equipped_items[$ category] = -1;
                show_debug_message("Unequipped " + category + " item to slot " + string(empty_slot));
            } else {
                show_debug_message("Inventory full, cannot unequip " + category + " item.");
            }
        } else {
            show_debug_message("No equipped item in " + category + " to unequip.");
        }
    }
}

// Depth setting for UI layering
depth = -1000;

// Function: Check if player has an item
function has_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) return false;
    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) return true;
    }
    return false;
}

// Function: Add an item to the inventory
function add_to_inventory(item_name) {
    if (has_item(item_name)) {
        show_debug_message("WARNING: " + item_name + " is already in the inventory.");
        return false;
    }

    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == -1) { // Empty slot
            inventory[i] = item_index;
            show_debug_message("Added " + item_name + " to inventory in slot " + string(i));
            return true;
        }
    }

    show_debug_message("Inventory full!");
    return false;
}

// Function: Remove an item from the inventory
function remove_item(item_name) {
    var item_index = ds_map_find_value(global.item_index_map, item_name);
    if (is_undefined(item_index)) {
        show_debug_message("ERROR: Invalid item name - " + string(item_name));
        return false;
    }

    for (var i = 0; i < inventory_size; i++) {
        if (inventory[i] == item_index) {
            inventory[i] = -1;
            show_debug_message("Removed " + item_name + " from inventory slot " + string(i));
            return true;
        }
    }

    show_debug_message("ERROR: Item " + item_name + " not found in inventory!");
    return false;
}

// Function: Drop the active item
function drop_active_item() {
    var item_index = inventory[active_slot];
    if (item_index == -1) {
        show_debug_message("No item in active slot to drop.");
        return;
    }

    // Find the item name from the index
    var item_name = "";
    var keys = ds_map_keys_to_array(global.item_index_map);
    for (var i = 0; i < array_length(keys); i++) {
        if (ds_map_find_value(global.item_index_map, keys[i]) == item_index) {
            item_name = keys[i];
            break;
        }
    }

    if (item_name != "") {
        // Get the corresponding object from item_object_map
        var dropped_object = ds_map_find_value(global.item_object_map, item_name);
        if (!is_undefined(dropped_object) && object_exists(dropped_object)) {
            // Create the specific object instance at the player's position
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", dropped_object);
            show_debug_message("Dropped " + item_name + " as " + object_get_name(dropped_object) + " at (" + string(global.player_instance.x) + ", " + string(global.player_instance.y) + ")");
        } else {
            show_debug_message("ERROR: No valid object mapped for item " + item_name + ". Dropping as generic obj_dropped_item.");
            var dropped_item = instance_create_layer(global.player_instance.x, global.player_instance.y, "Instances", obj_dropped_item);
            dropped_item.item_type = item_name; // Fallback to generic item
        }
    } else {
        show_debug_message("ERROR: Could not find item name for index " + string(item_index));
        return;
    }

    // Remove the item from the inventory
    inventory[active_slot] = -1;
    show_debug_message("Removed " + item_name + " from inventory slot " + string(active_slot));
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Create_0.gml
// obj_inventory_expanded: Create Event
global.game_paused = true;
depth = -10000;

// Default inventory states
global.inventory_open_state = "closed"; // Inventory starts in the closed state
global.inventory_visible = true; // Both sprites are visible by default

// Character variables
character_face = DOWN; // Default direction
character_action = "none"; // Default no action
character_image_index = 0; // Default animation frame

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Destroy_0.gml
// obj_inventory_expanded: Destroy Event
global.game_paused = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Draw_64.gml
var ui_scale = 2.2;

// GUI dimensions
var gui_width = display_get_gui_width();
var gui_height = display_get_gui_height();

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (gui_width / 2) - closed_width - 0; // Slightly shifted right
var closed_y = (gui_height - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35; // Overlaps slightly with the closed inventory
var open_y = (gui_height - open_height) / 2;

// Draw sprites based on inventory state
if (global.inventory_visible) {
    // Draw the closed inventory sprite
    draw_sprite_ext(spr_inventory_closed, 0, closed_x, closed_y, ui_scale, ui_scale, 0, c_white, 1);
    
    // Draw equipped items in clothing slots
    var clothing_slots = [
        [9, 20], [9, 40], [9, 60], [9, 80], [9, 100], [9, 120]
    ];
    var slots = ["head", "face", "neck", "body", "hand", "feet"];
    for (var i = 0; i < array_length(slots); i++) {
        var item_index = global.equipped_items[$ slots[i]];
        if (item_index != -1) {
            var slot_x = closed_x + clothing_slots[i][0] * ui_scale;
            var slot_y = closed_y + clothing_slots[i][1] * ui_scale;
            draw_sprite_part_ext(
                spr_inventory_items, 0,
                item_index * 18, 0, 18, 18,
                slot_x, slot_y,
                ui_scale, ui_scale, c_white, 1
            );
        }
    }
    
    // Character viewer positioning
    var viewer_x = closed_x + 29 * ui_scale; // Relative to closed inventory
    var viewer_y = closed_y + 40 * ui_scale;
    var viewer_width = 75 * ui_scale; // Width based on provided dimensions
    var viewer_height = 115 * ui_scale; // Height based on provided dimensions

	// Define drawing position and scale (adjust as needed)
	var draw_x = x + viewer_x; // Example: viewer_x = 50
	var draw_y = y + viewer_y; // Example: viewer_y = 50
	var char_scale = 7; // Scale for visibility

    // Default frame settings
	var frame_x = 0; // DOWN direction
	var frame_width = 24;
	var frame_height = 24;

	switch (global.current_skin) {
	    case "player":
	        // Draw walking pose for regular player
	        var frame_y = 0; // Walking pose from spr_player_body
	        draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
	        break;
    
	    case "tube":
	        // Draw sitting pose for tube
	        var frame_y = 72; // Sitting pose from spr_player_body
			draw_sprite_part_ext(spr_tube_sheet, 0, 24, 0, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, c_white, 1);
	        draw_sprite_part_ext(spr_player_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, char_scale, char_scale, global.player_color, 1);
	        break;
    
	    case "icetruck":
	        // Draw icetruck with penguin inside (simplified preview)
	        frame_width = 48; // Icetruck sprite size
	        frame_height = 48;
	        var frame_y = 0; // DOWN direction frame
	        draw_sprite_part_ext(spr_icetruck_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, c_white, 1);
	        draw_sprite_part_ext(spr_icetruck_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, obj_player_icetruck.icetruck_tint, 1);
	        draw_sprite_part_ext(spr_icetruck_penguin_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 20, char_scale - 2, char_scale - 2, global.player_color, 1);
			draw_sprite_part_ext(spr_icetruck_window, 0, frame_x, frame_y, frame_width, frame_height, draw_x - 40, draw_y - 25, char_scale - 2, char_scale - 2, c_white, 1);
	        break;
	}
    // Draw equipped items with slight offset for head items
    for (var i = 0; i < array_length(slots); i++) {
        var item_index = global.equipped_items[$ slots[i]];
        if (item_index != -1) {
            var item_sprite = ds_map_find_value(global.item_player_sprites, item_index);
            if (!is_undefined(item_sprite)) {
                var offset_x = (slots[i] == "head") ? 2 * char_scale : 0; // Adjust head item to the right
                draw_sprite_part_ext(item_sprite, 0, frame_x, frame_y, frame_width, frame_height, draw_x + offset_x - 10, draw_y, char_scale, char_scale, c_white, 1);
            }
        }
    }

    if (global.inventory_open_state == "open") {
        // Draw the open inventory sprite
        draw_sprite_ext(spr_inventory_open, 0, open_x, open_y, ui_scale, ui_scale, 0, c_white, 1);

        // Draw inventory grid
        var grid_start = [3, 6];
        var grid_size = [7, 6];
        for (var row = 0; row < grid_size[1]; row++) {
            for (var col = 0; col < grid_size[0]; col++) {
                var slot_index = row * grid_size[0] + col;
                if (slot_index < 42 && obj_inventory.inventory[slot_index] != -1) {
                    var item_index = obj_inventory.inventory[slot_index];
                    draw_sprite_part_ext(
                        spr_inventory_items, 0,
                        item_index * 18, 0, 18, 18,
                        open_x + (grid_start[0] + col * 20) * ui_scale,
                        open_y + (grid_start[1] + row * 20) * ui_scale,
                        ui_scale, ui_scale, c_white, 1
                    );
                }
            }
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_inventory_expanded
File: Step_0.gml
// obj_inventory_expanded: Step Event
var ui_scale = 2.2;
var gui_mouse_x = device_mouse_x_to_gui(0);
var gui_mouse_y = device_mouse_y_to_gui(0);

// Closed inventory positioning
var closed_width = sprite_get_width(spr_inventory_closed) * ui_scale;
var closed_height = sprite_get_height(spr_inventory_closed) * ui_scale;
var closed_x = (display_get_gui_width() / 2) - closed_width - 0;
var closed_y = (display_get_gui_height() - closed_height) / 2;

// Open inventory positioning
var open_width = sprite_get_width(spr_inventory_open) * ui_scale;
var open_height = sprite_get_height(spr_inventory_open) * ui_scale;
var open_x = closed_x + closed_width - 35;
var open_y = closed_y;

if (global.inventory_visible) {
    if (global.inventory_open_state == "closed") {
        // Define "Open Expanded Inventory" button area
        var open_left = closed_x + 117 * ui_scale;
        var open_top = closed_y + 61 * ui_scale;
        var open_right = closed_x + 125 * ui_scale;
        var open_bottom = closed_y + 93 * ui_scale;

        if (mouse_check_button_pressed(mb_left) &&
            gui_mouse_x >= open_left && gui_mouse_x <= open_right &&
            gui_mouse_y >= open_top && gui_mouse_y <= open_bottom) {
            show_debug_message("DEBUG: Opening expanded inventory.");
            global.inventory_open_state = "open";
        }
    } else if (global.inventory_open_state == "open") {
        // Define "Close Expanded Inventory" button area
        var close_left = open_x + 144 * ui_scale;
        var close_top = open_y + 47 * ui_scale;
        var close_right = open_x + 152 * ui_scale;
        var close_bottom = open_y + 79 * ui_scale;

        if (mouse_check_button_pressed(mb_left) &&
            gui_mouse_x >= close_left && gui_mouse_x <= close_right) {
            show_debug_message("DEBUG: Closing expanded inventory.");
            global.inventory_open_state = "closed";
        }
    }

    // Define "Close All Expanded Inventory" button
    var close_all_left = closed_x + 47 * ui_scale;
    var close_all_top = closed_y + 3 * ui_scale;
    var close_all_right = closed_x + 89 * ui_scale;
    var close_all_bottom = closed_y + 11 * ui_scale;

    if (mouse_check_button_pressed(mb_left) &&
        gui_mouse_x >= close_all_left && gui_mouse_x <= close_all_right) {
        show_debug_message("DEBUG: Closing all inventory.");
        global.inventory_visible = false;
        global.inventory_open_state = "closed";
        global.game_paused = false; // Unpause the game
        instance_destroy();
        exit;
    }
}

// Close inventory with "I" key
if (keyboard_check_pressed(ord("I"))) {
    show_debug_message("DEBUG: Closing inventory with 'I'.");
    global.game_paused = false;
    instance_destroy();
}

// Special actions and animation logic (unchanged)
if (keyboard_check_pressed(ord("H"))) {
    character_action = "dance";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("J"))) {
    character_action = "wave";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("K"))) {
    character_action = "none";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("B")) && obj_inventory.has_item("Jackhammer")) {
    character_action = "jackhammer";
    character_image_index = 0;
} else if (keyboard_check_pressed(ord("N")) && obj_inventory.has_item("Snow Shovel")) {
    character_action = "snowshovel";
    character_image_index = 0;
}

// Animate the character
if (character_action != "none") {
    var anim_speed = ds_map_find_value(global.player_instance.action_anim_speed, character_action);
    character_image_index += anim_speed;
    var frames = ds_map_find_value(global.player_instance.action_frame_data, character_action);
    if (character_image_index >= array_length(frames)) character_image_index = 0;
} else {
    character_image_index += 0.15; // Idle animation speed
    if (character_image_index >= 3) character_image_index = 0;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_Jackhammer_item
File: Create_0.gml
event_inherited();
item_name = "Jackhammer";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lamp
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_long_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_lrg_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Create_0.gml
// obj_pause_menu create event
depth = -99990; // Ensure it's drawn above all other objects

// Disable player controls
global.player_controls_enabled = false;

width = display_get_width();
height = display_get_height();
op_border = 8;
op_space = 16;
pos = 0;

// Settings menu options
option[0, 0] = "Window Size";
option[0, 1] = "Brightness";
option[0, 2] = "Controls";
option[0, 3] = "Back";

menu_level = 0;
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid initial menu_level " + string(menu_level));
    menu_level = 0; // Reset to default
}
op_length = array_length(option[menu_level]); // Dynamically set op_length

// Pause the game
game_paused = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Draw_0.gml
draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) {
    show_debug_message("ERROR: Invalid menu_level " + string(menu_level));
    return; // Exit the Draw Event
}

// Dynamically get width and height of menu
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check that index is within bounds
        var _op_w = string_width(option[menu_level][i]);
        _new_w = max(_new_w, _op_w);
    }
}
width = _new_w + op_border * 2;
height = op_border * 4.5 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    0, 
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw the options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) { // Check bounds again
        var _c = c_white;
        if (pos == i) { 
            _c = c_yellow; // Highlight the option being hovered over
        }
        draw_text_color(
            x + width / 2, 
            y + op_border + op_space * i, 
            option[menu_level][i], // Access using nested arrays
            _c, 
            _c, 
            _c, 
            _c, 
            1
        );
    } else {
        show_debug_message("ERROR: Invalid option index " + string(i) + " for menu_level " + string(menu_level));
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_main_settings
File: Step_0.gml
// Update op_length dynamically based on menu_level
op_length = array_length(option[menu_level]);

// Menu navigation using the mouse
var mouse_x_pos = device_mouse_x(0); // Get mouse x-coordinate
var mouse_y_pos = device_mouse_y(0); // Get mouse y-coordinate

var menu_width = 300; // Width of the menu
var menu_height = 40 * op_length + 20; // Height of the menu
var menu_top = y - menu_height / 2 + 20; // Top of the menu options
var menu_left = x - menu_width / 2; // Left of the menu

if (mouse_x_pos > menu_left && mouse_x_pos < menu_left + menu_width) {
    pos = floor((mouse_y_pos - menu_top) / 40); // Calculate option index
} else {
    pos = -1; // Mouse is not over the menu
}

// Ensure pos stays within bounds
if (pos < 0 || pos >= op_length) {
    pos = -1;
}

// Handle selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main settings menu
             switch (pos) {
                case 0: 
                    break; // Window Size (placeholder)
                case 1: 
                    break; // Brightness (placeholder)
                case 2: 
                    break; // Controls (placeholder)
				case 3:	
					room_goto(rm_main_menu);
					break;
            }
            break;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Create_0.gml
// obj_map Create Event
depth = -9998; // Ensure it's drawn above all other objects

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Draw_0.gml
// obj_map Draw Event
draw_self(); // Draw the full map sprite

// Draw markers or labels for clickable regions (halved size)
draw_set_color(c_red);
draw_rectangle(185 - 25, 228 - 25, 185 + 25, 228 + 25, false); // Town
draw_rectangle(55 - 25, 190 - 25, 55 + 25, 190 + 25, false); // Beach
draw_rectangle(155 - 25, 128 - 25, 155 + 25, 128 + 25, false); // Ski village
draw_rectangle(280 - 25, 250 - 25, 280 + 25, 250 + 25, false); // Snow fort
draw_rectangle(410 - 25, 277 - 25, 410 + 25, 277 + 25, false); // Welcome room
draw_rectangle(380 - 25, 230 - 25, 380 + 25, 230 + 25, false); // Plaza
draw_rectangle(395 - 25, 170 - 25, 395 + 25, 170 + 25, false); // Forest
draw_rectangle(400 - 25, 130 - 25, 400 + 25, 130 + 25, false); // Cove
draw_rectangle(135 - 25, 60 - 25, 135 + 25, 60 + 25, false); // Mountain top

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_27.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

camera_set_view_size(global.camera, global.camera_width, global.camera_height); // Restore original camera view size
instance_destroy(id);
show_debug_message("Map closed.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: KeyPress_77.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use

    // Ensure the player instance is recreated when switching back
    room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_4.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit; // Prevent interaction when the chat window is open
}

// obj_map Mouse Left Pressed Event
var click_x = device_mouse_x_to_gui(0);
var click_y = device_mouse_y_to_gui(0);

show_debug_message("Mouse clicked at: " + string(click_x) + ", " + string(click_y));

// Define clickable regions for different rooms (halved size)
if (click_x > 87 - 25 && click_x < 87 + 25 && click_y > 283 - 25 && click_y < 283 + 25) {
    // Move to Beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 185 - 25 && click_x < 185 + 25 && click_y > 228 - 25 && click_y < 228 + 25) {
    // Move to town
    show_debug_message("Town region clicked");
    room_goto(rm_town);
} else if (click_x > 55 - 25 && click_x < 55 + 25 && click_y > 190 - 25 && click_y < 190 + 25) {
    // Move to beach
    show_debug_message("Beach region clicked");
    room_goto(rm_beach);
} else if (click_x > 155 - 25 && click_x < 155 + 25 && click_y > 128 - 25 && click_y < 128 + 25) {
    // Move to ski village
    show_debug_message("Ski village region clicked");
    room_goto(rm_ski_village);
} else if (click_x > 280 - 25 && click_x < 280 + 25 && click_y > 250 - 25 && click_y < 250 + 25) {
    // Move to snow fort
    show_debug_message("Snow fort region clicked");
    room_goto(rm_snow_fort);
} else if (click_x > 410 - 25 && click_x < 410 + 25 && click_y > 277 - 25 && click_y < 277 + 25) {
    // Move to welcome room
    show_debug_message("Welcome room region clicked");
    room_goto(rm_welcome_room);
} else if (click_x > 380 - 25 && click_x < 380 + 25 && click_y > 230 - 25 && click_y < 230 + 25) {
    // Move to plaza
    show_debug_message("Plaza region clicked");
    room_goto(rm_plaza);
} else if (click_x > 395 - 25 && click_x < 395 + 25 && click_y > 170 - 25 && click_y < 170 + 25) {
    // Move to forest
    show_debug_message("Forest region clicked");
    room_goto(rm_forest);
} else if (click_x > 400 - 25 && click_x < 400 + 25 && click_y > 130 - 25 && click_y < 130 + 25) {
    // Move to cove
    show_debug_message("Cove region clicked");
    room_goto(rm_cove);
} else if (click_x > 135 - 25 && click_x < 135 + 25 && click_y > 60 - 25 && click_y < 60 + 25) {
    // Move to mountain top
    show_debug_message("Mountain top region clicked");
    room_goto(rm_ski_mountaintop);
} else {
    show_debug_message("No region matched. Click ignored.");
}

function create_warp_instance(target_room) {
    // Create a warp instance at the correct position
    var inst = instance_create_depth(0, 0, -9999, obj_warp);

    // Ensure the player warps to a valid position
    if (instance_exists(global.player_instance)) {
        inst.target_x = global.player_instance.x;
        inst.target_y = global.player_instance.y;
    } else {
        inst.target_x = 320; // Default center of the room (fallback)
        inst.target_y = 240;
    }

    inst.target_rm = target_room;
    inst.target_face = 0; // Set default direction
    inst.target_instance = global.player_instance;

    show_debug_message("DEBUG: Creating warp to " + string(target_room) + 
        " at (" + string(inst.target_x) + ", " + string(inst.target_y) + ")");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map
File: Mouse_5.gml
if (global.chat_active) {
    show_debug_message("Map interaction blocked: Chat is active.");
    exit;
}

if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    var target_room = global.last_room;
    global.last_room = noone; // Reset after use
	room_goto(target_room);
} else {
    show_debug_message("No previous room recorded. Returning to default.");
    room_goto(rm_welcome_room);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Draw_64.gml
/// Draw GUI Event for obj_map_icon
draw_sprite_ext(
    sprite_index, image_index,
    10, display_get_height() - sprite_height - 10, // Fixed GUI position
    1, 1, 0, c_white, 1
);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Mouse_4.gml
if (room != rm_map) {
    if (instance_exists(global.player_instance)) {
        global.player_x = global.player_instance.x;
        global.player_y = global.player_instance.y;

        show_debug_message("DEBUG: Stored player position: (" + string(global.player_x) + ", " + string(global.player_y) + ")");
        
        // Hide the player instead of destroying
        global.player_instance.visible = false;
    } else {
        show_debug_message("WARNING: No player instance found before switching rooms! Using default coordinates.");
        
        // Set default safe position
        global.player_x = 170;
        global.player_y = 154;
    }

    show_debug_message("Switching to map room...");
    global.last_room = room;
    room_goto(rm_map);
}
else if (variable_global_exists("last_room") && global.last_room != noone) {
    show_debug_message("Returning to previous room: " + string(global.last_room));
    room_goto(global.last_room);

}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_icon
File: Step_0.gml
//Step event
depth = -1000;

// Position map icon in the corner of the screen
x = camera_get_view_x(global.camera);
y = camera_get_view_y(global.camera) + camera_get_view_height(global.camera) - sprite_height;

// Check if the mouse is hovering over the icon
if (position_meeting(mouse_x, mouse_y, id)) {
    image_index = 1; // Change to highlighted sprite
} else {
    image_index = 0; // Revert to normal sprite
}

// Hide player instead of destroying in UI rooms
var is_ui_room = (room == rm_init || room == rm_main_menu || room == rm_map || room == rm_pause_menu || room == rm_sled_menu || room == rm_sled_racing || room == rm_settings_menu);

if (is_ui_room) {
    if (instance_exists(obj_map_icon)) {
        obj_map_icon.visible = false;
        show_debug_message("DEBUG: UI Room detected. Player instance hidden.");
    }
} else {
    if (instance_exists(obj_map_icon)) {
       obj_map_icon.visible = true;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_map_item
File: Create_0.gml
event_inherited();
item_name = "Map";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Create_0.gml
btn_action = ""; // This will define what the button does (e.g., "play", "exit")
btn_text = "";   // Text to display on the button
btn_font = -1;   // Default font (-1 means no custom font used)
text_color = c_white; // Default text color
hover = false;   // To detect mouse hover
btn_font = fnt_bonkfatty;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Draw_0.gml
// Draw the button sprite
draw_self();

// Set text alignment
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Calculate text position
var text_x = x + sprite_width / 2; // Center horizontally
var text_y = y + sprite_height / 2; // Center vertically

// Draw the button text with wrapping
draw_set_color(c_white);
draw_set_font(btn_font);
draw_text_ext(text_x, text_y, btn_text, -1, sprite_width - 100);

// Reset alignment (optional, for other draw calls later)
draw_set_halign(fa_left);
draw_set_valign(fa_top);

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_10.gml
hover = true;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_11.gml
hover = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_button
File: Mouse_4.gml
if (btn_action == "play") {
    room_goto(rm_init); // Go to the next room (your game room)
} else if (btn_action == "colour") {
    room_goto(rm_colorpicker_menu);
} else if (btn_action == "settings") {
    room_goto(rm_settings_menu);
} else if (btn_action == "exit") {
    game_end(); // Exit the game
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Create_0.gml
global.menu_state = "none"; // Possible values: "none", "puffle_menu", "name_puffle"
global.selected_puffle = noone;
global.menu_index = 0; // Selected option
name = "";
owner = noone;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Draw_64.gml
if (global.menu_state == "puffle_menu") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false); // Menu background
    draw_set_color(c_white);
    draw_text(150, 120, "Adopt");
    draw_text(150, 140, "Cancel");
    draw_text(130, 120 + global.menu_index * 20, ">"); // Cursor
}

if (global.menu_state == "name_puffle") {
    draw_set_color(c_black);
    draw_rectangle(100, 100, 300, 200, false);
    draw_set_color(c_white);
    draw_text(150, 140, "Press Enter to name your puffle");
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_menu_controller
File: Step_0.gml
if (global.menu_state == "puffle_menu") {
    // Menu options
    var options = ["Adopt", "Cancel"];
    var choice = -1;
    
    // Simple keyboard navigation (expand for mouse if needed)
    if (keyboard_check_pressed(vk_down)) global.menu_index = min(global.menu_index + 1, 1);
    if (keyboard_check_pressed(vk_up)) global.menu_index = max(global.menu_index - 1, 0);
    if (keyboard_check_pressed(vk_enter)) choice = global.menu_index;
    
    // Handle choice
    if (choice == 0) { // Adopt
        global.menu_state = "name_puffle";
        global.menu_index = 0; // Reset for next menu
    } else if (choice == 1) { // Cancel
        global.menu_state = "none";
        global.selected_puffle = noone;
    }
}

if (global.menu_state == "name_puffle") {
    if (keyboard_check_pressed(vk_enter)) {
        var puffle_name = get_string("Enter a name for your puffle:", "Puffle");
        if (puffle_name != "") {
            with (global.selected_puffle) {
                name = puffle_name;
                owner = obj_player; // Mark as adopted
            }
            obj_player.puffle_os -= 1; // Consume one Puffle-O
            global.menu_state = "none";
            global.selected_puffle = noone;
        }
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_minigame_warp_block
File: Alarm_0.gml
/// @description Alarm[0] Event for obj_minigame_warp_block
global.warp_cooldown = false;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_minigame_warp_block
File: Create_0.gml
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_minigame_warp_block
File: Other_4.gml
// Check if a warp instance exists
if (instance_exists(obj_warp)) {
    var warp_inst = instance_find(obj_warp, 0);
    if (warp_inst != noone) {
        // Move the player instance to the target coordinates
        global.player_instance.x = warp_inst.target_x;
        global.player_instance.y = warp_inst.target_y;

        // Optional: Adjust the player's facing direction
        if (is_real(warp_inst.target_face)) {
            global.player_instance.face = warp_inst.target_face;
        }

        // Destroy the warp instance once used
        instance_destroy(warp_inst);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_minigame_warp_block
File: Step_0.gml
/// @description Temporary Step Event for obj_minigame_warp_block
if (place_meeting(x, y, global.player_instance)) {
    room_goto(rm_sled_menu);
    global.player_instance.x = 129;
    global.player_instance.y = 29;
    global.sled_difficulty = "easy";
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Create_0.gml
//global volume control
global.masterVolume = 1;
global.musicVolume = 1;

//info for the song that we are currently playing / trying to play
songInstance = noone;
songAsset = noone;
targetSongAsset = noone;
endFadeOutTime = 0;//how many frames to fade out the song currently playing
startFadeInTime = 0;//how many frames to fade in the new song
fadeInInstVol = 1;//the volume of songInstance

//for fading music out and stopping songs that are no longer playing
fadeOutInstances = array_create(0);//audio instances to fade out
fadeOutInstVol = array_create(0);//the volume of each indiviual audio instance
fadeOutInstTime = array_create(0);//how fast the fadeout should happen
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Other_4.gml
// Play the correct music

if room == rm_welcome_room
|| room == rm_plaza
|| room == rm_shore
{
	set_song_ingame( bg_music, 60, 0 );
}

//For other rooms that require different music
//if room == rm_template
//{
//	set_song_ingame( bg_music, 3*60 );
//}

//if room == rm_template
//{
//	set_song_ingame( bg_music, 2*60, 2*60 );
//}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_musicmanager
File: Step_0.gml
var _finalVol = global.musicVolume*global.masterVolume;

//Play the target song
if songAsset != targetSongAsset
{
	//Tell the old song to fade out
	if audio_is_playing( songInstance )
	{
		//add out songInstance to our array of songs to fade out
		array_push( fadeOutInstances, songInstance );
		//add the songInstance's starting volume (so theres no adrupt change in volume)
		array_push( fadeOutInstVol, fadeInInstVol );
		//add the fadeOutInstance's fade out frames
		array_push( fadeOutInstTime, endFadeOutTime );
		
		//reset the songInstance and songAsset variables
		songInstance = noone;
		songAsset = noone;
	}
	
	
	//Play the song if the old song has faded out
	if array_length( fadeOutInstances) == 0
	{
		if audio_exists( targetSongAsset)
		{
			//Play the song and store its instance in a variable
			songInstance = audio_play_sound( targetSongAsset, 4, true );
	
			//Start the song's volume at 0
			audio_sound_gain( songInstance, 0, 0 );
			fadeInInstVol = 0;
		}
	
	//Set the songAssest to match the targetSongAsset
	songAsset = targetSongAsset;
	}
}


//Volume Control
	//Main song volume
	if audio_is_playing( songInstance )
	{
		//Fade the song in
		if startFadeInTime > 0
		{
			if fadeInInstVol < 1 { fadeInInstVol += 1/startFadeInTime; } else fadeInInstVol = 1
		}
		//Immediately start the song if the fade in time is 0 framces
		else
		{
			fadeInInstVol = 1;
		}
	
		//Actually set the gain
		audio_sound_gain( songInstance, fadeInInstVol*_finalVol, 0 )
	}
	
	//Fading songs out
	for(var i = 0; i < array_length(fadeOutInstances); i++ )
	{
		//Fade the volume
		if fadeOutInstTime[i] > 0
		{
			if	fadeOutInstVol[i] > 0 {fadeOutInstVol[i] -= 1/fadeOutInstTime[i]; }
		}
		//Immediately cut volume to 0 otherwuse
		else
		{
			fadeOutInstVol[i] = 0;
		}
		
		//Actually set the gain
		audio_sound_gain( fadeOutInstances[i], fadeOutInstVol[i]*_finalVol, 0 );
		
		//Stop the song when it's volume is at 0 and remove it from ALL arrays
		if fadeOutInstVol[i] <= 0
		{
			//stop the song	
			if audio_is_playing( fadeOutInstances[i] ) { audio_stop_sound( fadeOutInstances[i] ); };
			//remove it from the arrays
			array_delete( fadeOutInstances, i, 1);
			array_delete( fadeOutInstVol, i, 1);
			array_delete( fadeOutInstTime, i, 1);
			//set the loop back 1 since we just deleted an entry
			i--;
		}
	}
	
	
	
	
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Alarm_0.gml
if (npc_portrait != "") {
    sprite_index = npc_portrait;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Create_0.gml
// Movement settings (keep existing movement)
xspd = 0;
yspd = 0;
move_spd = 0;
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0;
stuck_timer = 0;
wait_timer = 3;
last_x = x;
last_y = y;
face = DOWN;

// NPC Settings
npc_name = "NPC";  // Default name
npc_portrait = spr_ninja_down;  // Default portrait
is_static = true;  // If true, NPC doesn't move

// Dialogue and quest-related variables
quest_active = false; // Is a quest active?
quest_complete = false; // Is the quest completed?
current_dialogue_index = -1; // Start with no dialogue active
dialogue = ["Hello there!", "I have nothing important to say."]; // Custom dialogue

// Quest System
is_quest_giver = false;  // Can this NPC give a quest?
quest_given = false;  // Has the quest been given?
quest_required_item = "";  // Item required for quest ("" = no quest)
quest_completed = false;  // Has the player completed the quest?
quest_reward = "";  // Reward given after quest completion

// Set the sprite based on the NPC's unique properties
if (npc_portrait != "") {
    sprite_index = npc_portrait;
}

// Stop animation from cycling through frames
image_speed = 0; 
image_index = 0;

// Delay sprite assignment until the next step
alarm[0] = 1;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Draw_0.gml
depth = -1000;
// Draw NPC as usual
draw_self();

// Draw the dialogue box if active
if (current_dialogue_index >= 0) {
    // Text and box parameters
    var margin = 8; // Padding around the text
    var max_width = 200; // Maximum width for the dialogue box
    var text_scale = 0.50; // Scale the text smaller

    // Calculate text dimensions
	draw_set_font(fnt_acme_secretagent_bold);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(dialogue[current_dialogue_index]) * text_scale;
    var text_height = string_height(dialogue[current_dialogue_index]) * text_scale;

    // Calculate box dimensions (add padding around the text)
    var box_width = min(max_width, text_width + margin * 2);
    var box_height = text_height + margin * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 0.5;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_chat,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, dialogue[current_dialogue_index], text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc
File: Step_0.gml
// Check for interaction with player
if (keyboard_check_pressed(ord("E"))) {
    var _player = instance_nearest(x, y, obj_player);
    
    if (_player != noone && distance_to_object(_player) < 16) {
        if (current_dialogue_index == -1) {
            // Start dialogue
            current_dialogue_index = 0;
        } else {
            // Progress dialogue
            current_dialogue_index++;
            if (current_dialogue_index >= array_length(dialogue)) {
                // Reset dialogue if all lines have been shown
                current_dialogue_index = -1;

                // If NPC is a quest giver and has not given the quest reward yet
                if (is_quest_giver && !quest_given) {
                    quest_given = true; // Mark quest as given

                    // Ensure `obj_inventory` exists before giving the item
                    if (instance_exists(obj_inventory)) {
                        if (!obj_inventory.has_item(quest_reward)) {
                            obj_inventory.add_to_inventory(quest_reward);
                            show_debug_message(npc_name + " gave you a " + quest_reward + "!");
                        } else {
                            show_debug_message("You already have a " + quest_reward + ".");
                        }
                    } else {
                        show_debug_message("ERROR: obj_inventory not found!");
                    }
                }
            }
        }
    }
}

// Ensure correct depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Alarm_0.gml
// Alarm[0] Event
// Reset moving state to allow the NPC to pick a new target
is_moving = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Create_0.gml
xspd = 0;
yspd = 0;

move_spd = 0.5; // Lower speed for smoother movement
move_x = 0;
move_y = 0;
is_moving = false;
collision_delay = 0; // Timer for delaying after a collision
stuck_timer = 0; // Timer to handle stuck state
wait_timer = 3; //Timer to handle how long to pause before walking
last_x = x;      // Tracks previous position for stuck detection
last_y = y;      // Tracks previous position for stuck detection

// Initialize movement variables
target_x = x; // Default to current position
target_y = y; // Default to current position
is_moving = false;
move_speed = 1; // Default movement speed

sprite[RIGHT] = spr_player_right;
sprite[UP] = spr_player_up;
sprite[LEFT] = spr_player_left;
sprite[DOWN] = spr_player_down;
sprite[UP_RIGHT] = spr_player_up_right;
sprite[UP_LEFT] = spr_player_up_left;
sprite[DOWN_RIGHT] = spr_player_down_right;
sprite[DOWN_LEFT] = spr_player_down_left;

face = DOWN;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Random initial direction
direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
change_direction_timer = fps * 2; // Change direction every 2 seconds

phrases = ["Hello there!", "Nice to meet you!", "What brings you here?", "Have a great day!", "Stay safe!"];
current_phrase = ""; // Will hold the currently displayed phrase
talk_timer = 0; // Timer for how long the phrase is displayed
interact_pause = 0; // Timer to pause movement after interaction


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Draw_0.gml
// Draw NPC as usual
draw_self();

// Ensure chat box is drawn above everything
if (talk_timer > 0) {
    // Text setup
    var text = current_phrase;
    var text_scale = 0.5; // Scale factor for text
    var text_padding = 10; // Padding around the text

    // Calculate text dimensions
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    var text_width = string_width(text) * text_scale; // Scaled width of the text
    var text_height = string_height(text) * text_scale; // Scaled height of the text

    // Calculate box dimensions (add padding around the text)
    var box_width = max(64, text_width + text_padding * 2); // Minimum width for aesthetics
    var box_height = text_height + text_padding * 2;

    // Position the box
    var box_x = x - box_width / 2;
    var box_y = y - sprite_height - box_height - 10;

    // Draw 9-slice sprite background
    draw_sprite_stretched(
        spr_menu,     // Sprite
        0,                       // Sub-image index
        box_x,                   // X position
        box_y,                   // Y position
        box_width,               // Scaled width
        box_height               // Scaled height
    );

    // Draw the scaled text
    var text_x = box_x + box_width / 2;
    var text_y = box_y + box_height / 2;
    draw_set_color(c_black);
    draw_text_transformed(text_x, text_y, text, text_scale, text_scale, 0);
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_npc_old
File: Step_0.gml
// Step Event for obj_npc
if (!sliding) {
    // Normal movement logic
    var move_x = lengthdir_x(move_spd, direction);
    var move_y = lengthdir_y(move_spd, direction);

    // Handle collisions with walls
    if (place_meeting(x + move_x, y, obj_wall)) {
        direction = 360 - direction; // Reverse direction on x-axis
    }
    if (place_meeting(x, y + move_y, obj_wall)) {
        direction = 180 - direction; // Reverse direction on y-axis
    }

    // Check for collision with obj_slippery to start sliding
    if (place_meeting(x + move_x, y, obj_slippery) || place_meeting(x, y + move_y, obj_slippery)) {
        sliding = true;
        slide_dir_x = sign(move_x);
        slide_dir_y = sign(move_y);
        slide_speed = move_spd * 1.5; // Initial slide speed, adjust as necessary
    } else {
        // Move the NPC normally
        x += move_x;
        y += move_y;
    }

    // Decrease the timer for changing direction
    change_direction_timer--;
    if (change_direction_timer <= 0) {
        direction = choose(0, 45, 90, 135, 180, 225, 270, 315);
        change_direction_timer = fps * 2; // Reset the timer
    }
} else {
    // Sliding logic
    var slide_move_x = slide_dir_x * slide_speed;
    var slide_move_y = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        slide_move_x = 0;
        slide_move_y = 0;
    }

    // Move the NPC while sliding
    x += slide_move_x;
    y += slide_move_y;
}

// Update the sprite based on direction
if (slide_speed > 0) {
    if (slide_dir_y < 0) {
        if (slide_dir_x < 0) { face = UP_LEFT; }
        if (slide_dir_x > 0) { face = UP_RIGHT; }
        if (slide_dir_x == 0) { face = UP; }
    }
    if (slide_dir_y > 0) {
        if (slide_dir_x < 0) { face = DOWN_LEFT; }
        if (slide_dir_x > 0) { face = DOWN_RIGHT; }
        if (slide_dir_x == 0) { face = DOWN; }
    }
    if (slide_dir_y == 0) {
        if (slide_dir_x > 0) { face = RIGHT; }
        if (slide_dir_x < 0) { face = LEFT; }
    }
} else {
    if (direction == 0) face = RIGHT;
    else if (direction == 45) face = UP_RIGHT;
    else if (direction == 90) face = UP;
    else if (direction == 135) face = UP_LEFT;
    else if (direction == 180) face = LEFT;
    else if (direction == 225) face = DOWN_LEFT;
    else if (direction == 270) face = DOWN;
    else if (direction == 315) face = DOWN_RIGHT;
}
sprite_index = sprite[face];

// Depth
depth = -bbox_bottom;

// Debugging logs

show_debug_message("NPC Direction: " + string(direction));
show_debug_message("NPC Face: " + string(face));
show_debug_message("NPC Position: " + string(x) + ", " + string(y));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Create_0.gml
/// Create Event for obj_obstacle
global.game_started = false;
countdown = 5;
type = choose("log", "snow_log", "rock");
switch (type) {
    case "log": sprite_index = spr_sled_log; break;
    case "snow_log": sprite_index = spr_sled_log_snowcovered; break;
    case "rock": sprite_index = spr_sled_rock; break; // Add spr_rock if desired
}
x = random_range(0, room_width - sprite_width);
y = room_height + sprite_height;
speed = 5; // Base speed
direction = 90;

// Adjust speed by difficulty
switch (global.sled_difficulty) {
    case "medium": speed = 6; break;
    case "hard": speed = 7; break;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle
File: Step_0.gml
/// Step Event for obj_obstacle
if (countdown > 0) {
    countdown -= 1;
    if (countdown == 0) {
        race_started = true;
        global.game_started = true;
    }
    exit;
}

if (global.game_started) {
    y -= 5;
    if (y < -sprite_height) {
        y = room_height + sprite_height;
        x = irandom_range(0, room_width - sprite_width);
    }
    if (!obj_sled_player.invincible && place_meeting(x, y, obj_sled_player)) {
        with (obj_sled_player) {
            lives -= 1;
            invincible = true;
            invincible_timer = room_speed * 2;
        }
    }
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Alarm_0.gml
instance_create_layer(irandom_range(0, room_width - sprite_get_width(spr_long_bush)), room_height, "Instances", obj_obstacle);
alarm[0] = 30; // Reset alarm
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Create_0.gml
/// Create Event for obj_obstacle_controller
spawn_timer = 5;
spawn_interval = room_speed * 2; // Base interval
difficulty = global.sled_difficulty;
race_finished = false;

switch (difficulty) {
    case "medium": spawn_interval = room_speed * 1.5; break;
    case "hard": spawn_interval = room_speed * 1; break;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_obstacle_controller
File: Step_0.gml
/// Step Event for obj_obstacle_controller
if (!global.game_started || !instance_exists(obj_sled_player) || obj_sled_player.race_finished) exit;

spawn_timer += 1;
if (spawn_timer >= spawn_interval) {
    spawn_timer = 0;
    if (random(1) < 0.2) {
        instance_create_layer(0, 0, "Instances", obj_powerup);
    } else {
        instance_create_layer(0, 0, "Instances", obj_obstacle);
    }
    if (global.sled_difficulty == "hard") spawn_interval = max(spawn_interval - 0.1, room_speed * 0.5);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Create_0.gml
depth = 10000;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_parallax_background
File: Draw_0.gml
var _camx = camera_get_view_x(global.camera);  // Use global.camera explicitly
var _camy = camera_get_view_y(global.camera);

var _p = 0.5;  // Parallax factor (adjust as needed)

if (sprite_exists(bg_sky)) {
    draw_sprite(bg_sky, 0, _camx * _p, _camy * _p);
} else {
    show_debug_message("ERROR: bg_sky sprite does not exist!");
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_party_hat
File: Create_0.gml
event_inherited();
item_name = "Party Hat";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Create_0.gml
depth = -99990; // Ensure pause menu is drawn on top
global.is_pause_menu_active = false;
global.inventory_visible = false; 

image_speed = 0.5; // Menu animation speed

op_border = 8;
op_space = 16;
pos = 0;

// Pause menu options
option[0, 0] = "Back to Game";
option[0, 1] = "Settings";
option[0, 2] = "Quit Game";

// Settings menu options
option[1, 0] = "Change Skin";
option[1, 1] = "Back";

menu_level = 0; 
op_length = array_length(option[menu_level]); // Set initial length dynamically

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Draw_0.gml
// Only draw when the pause menu is active
if (!global.is_pause_menu_active) {
    exit;
}

draw_set_font(fnt_bumbastika_sml);

// Ensure menu_level is valid
// Ensure menu_level is valid
if (menu_level < 0 || menu_level >= array_length(option)) return;

// Dynamically calculate menu width
var _new_w = 0;
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        _new_w = max(_new_w, string_width(option[menu_level][i]));
    }
}
width = _new_w + op_border * 2;
height = op_border * 4 + string_height(option[menu_level][0]) * op_length;

// Center menu
x = camera_get_view_x(view_camera[0]) + (camera_get_view_width(view_camera[0]) - width) / 2;
y = camera_get_view_y(view_camera[0]) + (camera_get_view_height(view_camera[0]) - height) / 2;

// Draw the menu background
draw_sprite_ext(
    spr_pause_menu, 
    floor(image_index), // Use image_index for animation
    x, 
    y, 
    width / sprite_get_width(spr_pause_menu), 
    height / sprite_get_height(spr_pause_menu), 
    0, 
    c_white, 
    1
);

// Draw menu options
draw_set_valign(fa_top);
draw_set_halign(fa_center);
for (var i = 0; i < op_length; i++) {
    if (i < array_length(option[menu_level])) {
        var color = (pos == i) ? c_yellow : c_white; // Highlight selection
        draw_text_color(x + width / 2, y + op_border + op_space * i, option[menu_level][i], color, color, color, color, 1);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pause_menu
File: Step_0.gml
// obj_pause_menu: Step Event

// Skip input processing if expanded inventory is visible
if (global.inventory_visible) {
    exit; // Do not process inputs while inventory is open
}

// Update menu options dynamically
op_length = array_length(option[menu_level]);

// Mouse Position Adjusted to GUI Coordinates
var menu_width = 300; 
var menu_height = op_length * 40 + 20; 
var menu_top = y - menu_height / 2 + 20; 
var menu_left = x - menu_width / 2; 

if (mouse_x > menu_left && mouse_x < menu_left + menu_width) {
    pos = floor((mouse_y - menu_top) / 40);
} else {
    pos = -1;
}

// Ensure pos is within valid bounds
if (pos < 0 || pos >= op_length) pos = -1;

// Handle menu selection with mouse click
if (mouse_check_button_pressed(mb_left) && pos >= 0) {
    switch (menu_level) {
        case 0: // Main Pause Menu
            switch (pos) {
                case 0: // Resume Game
                    global.is_pause_menu_active = false;
                    global.player_controls_enabled = true;
                    show_debug_message("Game Resumed");
                    break;

                case 1: // Go to Settings
                    menu_level = 1; 
                    break;

                case 2: // Quit Game
                    game_end();
                    break;
            }
            break;

        case 1: // Settings Menu
            switch (pos) {
                case 0: // Open Skin Picker
                    instance_create_layer(x, y, "UI", obj_skinpicker); 
                    global.is_pause_menu_active = false;
                    break;
                
                case 1: // Back to Pause Menu
                    menu_level = 0;
                    break;
            }
            break;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Create_0.gml
// obj_pickup_item Create Event
is_savable = true;
item_name = ""; // Set in creation code or instance variables

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pickup_item
File: Step_0.gml
// obj_pickup_item Step Event
if (keyboard_check_pressed(ord("E")) && distance_to_object(global.player_instance) < 20) {
    if (instance_exists(obj_inventory)) {
        var added = obj_inventory.add_to_inventory(item_name);
        if (added) {
            show_debug_message(item_name + " added to inventory.");
            instance_destroy();
        } else {
            show_debug_message("Inventory full.");
        }
    }
}
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pizzaslice_item
File: Create_0.gml
event_inherited();
item_name = "Pizza Slice";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 1;
state = "walking";
if (!variable_global_exists("player_color")) { global.player_color = c_white; }
if (variable_global_exists("last_player_color")) { global.player_color = global.last_player_color; } else { global.player_color = c_white; }

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
original_sprite = sprite_index;

// Snowball throw variables
is_throwing = false;
throw_frame = 0;
throw_direction = -1;
throw_animation_length = 28; // 28 frames per animation
snowball_release_frame = 15; // Snowball spawns mid-animation

// Set direction and sprites
face = DOWN;
//init_sprites(spr_player_right, spr_player_up, spr_player_left, spr_player_down, spr_player_up_right, spr_player_up_left, spr_player_down_right, spr_player_down_left);
sprite_body = spr_player_body; // Default sprite
sprite_color = spr_player_colour;
mask_index = spr_player_down;

// Frame data for walking (192x72 sprite sheet: 3 frames per direction)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];

// Special actions system
action_state = "none";  // "none", "dance", "wave", "sit", "jackhammer", "snowshovel"
action_timer = 0;
action_duration = 0;

// Frame data and sprite maps for special actions
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();

// Sit (8 frames, 24x24, y=72 in spr_player_body)
ds_map_add(action_frame_data, "sit", [
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24],
    [96, 72, 24, 24], [120, 72, 24, 24], [144, 72, 24, 24], [168, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "sit", spr_player_body);
ds_map_add(action_sprite_color, "sit", spr_player_colour);
ds_map_add(action_anim_speed, "sit", 0); // Static

// Wave (16 frames, 24x24, y=96-120 in spr_player_body)
ds_map_add(action_frame_data, "wave", [
    [0, 96, 24, 24], [24, 96, 24, 24], [48, 96, 24, 24], [72, 96, 24, 24],
    [96, 96, 24, 24], [120, 96, 24, 24], [144, 96, 24, 24], [168, 96, 24, 24],
    [0, 120, 24, 24], [24, 120, 24, 24], [48, 120, 24, 24], [72, 120, 24, 24],
    [96, 120, 24, 24], [120, 120, 24, 24], [144, 120, 24, 24], [168, 120, 24, 24]
]);
ds_map_add(action_sprite_body, "wave", spr_player_body);
ds_map_add(action_sprite_color, "wave", spr_player_colour);
ds_map_add(action_anim_speed, "wave", 0.2); // ~5 FPS

// Dance (56 frames, 24x24, y=144-288 in spr_player_body)
ds_map_add(action_frame_data, "dance", [
    [0, 144, 24, 24], [24, 144, 24, 24], [48, 144, 24, 24], [72, 144, 24, 24], [96, 144, 24, 24], [120, 144, 24, 24], [144, 144, 24, 24], [168, 144, 24, 24],
    [0, 168, 24, 24], [24, 168, 24, 24], [48, 168, 24, 24], [72, 168, 24, 24], [96, 168, 24, 24], [120, 168, 24, 24], [144, 168, 24, 24], [168, 168, 24, 24],
    [0, 192, 24, 24], [24, 192, 24, 24], [48, 192, 24, 24], [72, 192, 24, 24], [96, 192, 24, 24], [120, 192, 24, 24], [144, 192, 24, 24], [168, 192, 24, 24],
    [0, 216, 24, 24], [24, 216, 24, 24], [48, 216, 24, 24], [72, 216, 24, 24], [96, 216, 24, 24], [120, 216, 24, 24], [144, 216, 24, 24], [168, 216, 24, 24],
    [0, 240, 24, 24], [24, 240, 24, 24], [48, 240, 24, 24], [72, 240, 24, 24], [96, 240, 24, 24], [120, 240, 24, 24], [144, 240, 24, 24], [168, 240, 24, 24],
    [0, 264, 24, 24], [24, 264, 24, 24], [48, 264, 24, 24], [72, 264, 24, 24], [96, 264, 24, 24], [120, 264, 24, 24], [144, 264, 24, 24], [168, 264, 24, 24],
    [0, 288, 24, 24], [24, 288, 24, 24], [48, 288, 24, 24], [72, 288, 24, 24], [96, 288, 24, 24], [120, 288, 24, 24], [144, 288, 24, 24], [168, 288, 24, 24]
]);
ds_map_add(action_sprite_body, "dance", spr_player_body);
ds_map_add(action_sprite_color, "dance", spr_player_colour);
ds_map_add(action_anim_speed, "dance", 0.25); // ~4 FPS

// Jackhammer (50 frames, 32x24, spr_player_body_jackhammer)
ds_map_add(action_frame_data, "jackhammer", [
    [0, 0, 32, 24], [32, 0, 32, 24], [64, 0, 32, 24], [96, 0, 32, 24], [128, 0, 32, 24], [160, 0, 32, 24],
    [0, 24, 32, 24], [32, 24, 32, 24], [64, 24, 32, 24], [96, 24, 32, 24], [128, 24, 32, 24], [160, 24, 32, 24],
    [0, 48, 32, 24], [32, 48, 32, 24], [64, 48, 32, 24], [96, 48, 32, 24], [128, 48, 32, 24], [160, 48, 32, 24],
    [0, 72, 32, 24], [32, 72, 32, 24], [64, 72, 32, 24], [96, 72, 32, 24], [128, 72, 32, 24], [160, 72, 32, 24],
    [0, 96, 32, 24], [32, 96, 32, 24], [64, 96, 32, 24], [96, 96, 32, 24], [128, 96, 32, 24], [160, 96, 32, 24],
    [0, 120, 32, 24], [32, 120, 32, 24], [64, 120, 32, 24], [96, 120, 32, 24], [128, 120, 32, 24], [160, 120, 32, 24],
    [0, 144, 32, 24], [32, 144, 32, 24], [64, 144, 32, 24], [96, 144, 32, 24], [128, 144, 32, 24], [160, 144, 32, 24],
    [0, 168, 32, 24], [32, 168, 32, 24], [64, 168, 32, 24], [96, 168, 32, 24], [128, 168, 32, 24], [160, 168, 32, 24],
    [0, 192, 32, 24], [32, 192, 32, 24], [64, 192, 32, 24], [96, 192, 32, 24], [128, 192, 32, 24], [160, 192, 32, 24]
]);
ds_map_add(action_sprite_body, "jackhammer", spr_player_body_jackhammer);
ds_map_add(action_sprite_color, "jackhammer", spr_player_colour_jackhammer);
ds_map_add(action_anim_speed, "jackhammer", 0.3); // ~3.33 FPS

// Snow Shovel (16 frames, 24x48, spr_player_body_snowshovel)
ds_map_add(action_frame_data, "snowshovel", [
    [0, 0, 24, 48], [24, 0, 24, 48], [48, 0, 24, 48], [72, 0, 24, 48], [96, 0, 24, 48], [120, 0, 24, 48], [144, 0, 24, 48], [168, 0, 24, 48],
    [0, 48, 24, 48], [24, 48, 24, 48], [48, 48, 24, 48], [72, 48, 24, 48], [96, 48, 24, 48], [120, 48, 24, 48], [144, 48, 24, 48], [168, 48, 24, 48]
]);
ds_map_add(action_sprite_body, "snowshovel", spr_player_body_snowshovel);
ds_map_add(action_sprite_color, "snowshovel", spr_player_colour_snowshovel);
ds_map_add(action_anim_speed, "snowshovel", 0.2); // ~5 FPS

// Debugging
show_debug_message("obj_player: Initialized. Driving state: " + string(driving));

// Throw Snowball (28 frames, 24x24, assuming spr_throwsnowball_body at y=0-96)
ds_map_add(action_frame_data, "throw", [
    [0, 0, 24, 24], [24, 0, 24, 24], [48, 0, 24, 24], [72, 0, 24, 24], 
    [96, 0, 24, 24], [120, 0, 24, 24], [144, 0, 24, 24], [168, 0, 24, 24],
    [0, 24, 24, 24], [24, 24, 24, 24], [48, 24, 24, 24], [72, 24, 24, 24], 
    [96, 24, 24, 24], [120, 24, 24, 24], [144, 24, 24, 24], [168, 24, 24, 24],
    [0, 48, 24, 24], [24, 48, 24, 24], [48, 48, 24, 24], [72, 48, 24, 24], 
    [96, 48, 24, 24], [120, 48, 24, 24], [144, 48, 24, 24], [168, 48, 24, 24],
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5); // Reduced from 1.0 to 0.5 (half speed)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Draw_0.gml
var draw_x = x;
var draw_y = y;
var frame_x, frame_y, frame_width, frame_height;
var current_sprite_body = sprite_body; // Default
var current_sprite_color = sprite_color;

if (action_state == "none") {
    // Walking animation
    var frame_index = floor(image_index) mod 3;  // 3 frames per direction
    frame_x = frame_data[face][frame_index * 4];
    frame_y = frame_data[face][frame_index * 4 + 1];
    frame_width = frame_data[face][frame_index * 4 + 2];
    frame_height = frame_data[face][frame_index * 4 + 3];
    draw_x -= frame_width / 2; // Center 24x24
    draw_y -= frame_height / 2;
} else {
    // Special actions
    var frames = ds_map_find_value(action_frame_data, action_state);
    var frame_count = array_length(frames);  // Number of sub-arrays (frames)
    var frame_index;
    if (action_state == "sit") {
        // Static sitting frame based on direction
        // Map face to match sprite order: DOWN=0, DOWN_LEFT=1, LEFT=2, UP_LEFT=3, UP=4, UP_RIGHT=5, RIGHT=6, DOWN_RIGHT=7
        var sit_frame_map = [6, 4, 2, 0, 7, 5, 1, 3]; // RIGHT=0 maps to RIGHT=6, etc.
        frame_index = clamp(sit_frame_map[face], 0, frame_count - 1);
        show_debug_message("Face: " + string(face) + ", Sitting Frame: " + string(frame_index));
    } else {
        // Animated actions (dance, wave, jackhammer, snowshovel)
        frame_index = floor(image_index) mod frame_count;
    }
    // Access the sub-array for the current frame
    var frame_data_array = frames[frame_index];
    frame_x = frame_data_array[0];
    frame_y = frame_data_array[1];
    frame_width = frame_data_array[2];
    frame_height = frame_data_array[3];
    
    // Set action-specific sprites
    current_sprite_body = ds_map_find_value(action_sprite_body, action_state);
    current_sprite_color = ds_map_find_value(action_sprite_color, action_state);
    draw_x -= frame_width / 2; // Dynamic centering
    draw_y -= frame_height / 2;
}

if (action_state == "throw") {
    // Variables to determine animation and flip
    var use_up_right = false; // False = "Throw Face Down Right", True = "Throw Face Up Right"
    var flip = false;         // False = normal, True = flipped horizontally

    // Determine animation and flip based on throw direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            use_up_right = false;
            flip = false;
            break;
        case UP_RIGHT:
            use_up_right = true;
            flip = false;
            break;
        case DOWN_LEFT:
            use_up_right = false;
            flip = true;
            break;
        case UP_LEFT:
            use_up_right = true;
            flip = true;
            break;
        case RIGHT:
            use_up_right = choose(false, true); // 50% chance for each animation
            flip = false;
            break;
        case LEFT:
            use_up_right = choose(false, true); // 50% chance for each animation
            flip = true;
            break;
        case UP:
            use_up_right = true; // Always use "Throw Face Up Right"
            flip = choose(false, true); // 50% chance to flip
            break;
        case DOWN:
            use_up_right = false; // Always use "Throw Face Down Right"
            flip = choose(false, true); // 50% chance to flip
            break;
    }

    // Set frame offset based on animation
    var frame_offset = use_up_right ? 28 : 0; // Adjust if your sprite sheet layout differs

    // Calculate frame index
    var frames_per_animation = 28; // Number of frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Shift to the correct animation set

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust draw position for flipping
    var throwsprite_width = 24; // Assuming 24-pixel width
    var draw_x = x;
    if (flip) {
        draw_x = x + throwsprite_width; // Shift position for flipped sprite
    }

    // Draw the sprite once with correct scaling and positioning
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
}
// Draw the sprite parts
draw_sprite_part_ext(current_sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, c_white, 1);
gpu_set_blendmode(bm_normal);
draw_sprite_part_ext(current_sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, global.player_color, 1);

// Draw equipped head item with debug logging
if (global.equipped_items.head != -1) {
    var item_index = global.equipped_items.head; // e.g., 0 for Beta Hat, 1 for Party Hat
    var head_sprite = ds_map_find_value(global.item_player_sprites, item_index);
    if (!is_undefined(head_sprite)) {
        show_debug_message("Drawing head item sprite: " + sprite_get_name(head_sprite) + " for item index: " + string(item_index));
        var offset_x = -12; // Adjust this if the hat is misaligned
        var offset_y = -12;
        draw_sprite_part_ext(head_sprite, 0, frame_x, frame_y, frame_width, frame_height, x + offset_x, y + offset_y, 1, 1, c_white, 1);
    } else {
        show_debug_message("ERROR: No player sprite found for item index: " + string(item_index));
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player
File: Step_0.gml
if (global.game_paused || global.is_pause_menu_active) {
    exit; // Prevent updates when paused
}

// Always define movement inputs at the start
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Handle special actions (only when not driving)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) { // Dance
        action_state = "dance";
        action_timer = 0;
        action_duration = 224; // 56 frames * 4 steps
        image_index = 0;
        show_debug_message("Starting dance");
    } else if (keyboard_check_pressed(ord("J"))) { // Wave
        action_state = "wave";
        action_timer = 0;
        action_duration = 80; // 16 frames * 5 steps
        image_index = 0;
        show_debug_message("Starting wave");
    } else if (keyboard_check_pressed(ord("K"))) { // Sit
        action_state = "sit";
        action_timer = 0;
        action_duration = -1; // Infinite until toggled
        image_index = 0;
        show_debug_message("Starting sit");
    } else if (keyboard_check_pressed(ord("B"))) { // Jackhammer
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Jackhammer")) {
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150; // 50 frames * 3 steps
            image_index = 0;
            show_debug_message("Starting jackhammer");
        }
    } else if (keyboard_check_pressed(ord("N"))) { // Snow Shovel
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Snow Shovel")) {
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80; // 16 frames * 5 steps
            image_index = 0;
            show_debug_message("Starting snow shovel");
        }
    } else if (keyboard_check_pressed(ord("O"))) { // Throw Snowball
        action_state = "throw";
        action_timer = 0;
        action_duration = throw_animation_length; // 28 frames
        throw_direction = face; // Capture current facing direction
        image_index = 0;
        xspd = 0; // Stop movement
        yspd = 0;
        show_debug_message("Starting snowball throw");
    }
} else if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state);
    action_timer += 1;

    // Handle snowball throwing specifics
    if (action_state == "throw" && action_timer == snowball_release_frame) {
        // Define offsets based on throw direction
        var offset_x = 0;
        var offset_y = 0;
        switch (throw_direction) {
            case RIGHT: 
                offset_x = 12; 
                break;
            case LEFT: 
                offset_x = -12; 
                break;
            case UP: 
                offset_y = -12; 
                break;
            case DOWN: 
                offset_y = 12; 
                break;
            case UP_RIGHT: 
                offset_x = 8; 
                offset_y = -8; 
                break;
            case UP_LEFT: 
                offset_x = -8; 
                offset_y = -8; 
                break;
            case DOWN_RIGHT: 
                offset_x = 8; 
                offset_y = 8; 
                break;
            case DOWN_LEFT: 
                offset_x = -8; 
                offset_y = 8; 
                break;
        }
        // Create the snowball with the calculated offsets
        var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
        snowball.direction = get_throw_direction(throw_direction);
        snowball.speed = 3; // Reduced from 5 to 3 to slow it down
        // Timer is incremented in the outer block, so no need to increment here
    }

    // End special action
    if (action_state == "sit" && keyboard_check_pressed(ord("K"))) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Stopped sitting");
    } else if (action_timer >= action_duration && action_duration != -1) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Action " + action_state + " completed");
    }
}

// Handle movement (only when not in an action or throwing)
if (action_state == "none") {
    if (!sliding) {
        xspd = (right_key - left_key) * move_spd;
        yspd = (down_key - up_key) * move_spd;
    } else {
        xspd = slide_dir_x * slide_speed;
        yspd = slide_dir_y * slide_speed;
        slide_speed *= 0.98;
        if (abs(slide_speed) < 0.1) { sliding = false; xspd = 0; yspd = 0; }
    }

    if (instance_exists(obj_pauser)) { xspd = 0; yspd = 0; }

    // Update facing direction
    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; } else if (xspd > 0) { face = UP_RIGHT; } else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; } else if (xspd > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; } else if (xspd < 0) { face = LEFT; }
    }

    // Apply collision and movement
    xspd = handle_collision("x", xspd);
    yspd = handle_collision("y", yspd);
    if (irandom(1) == 0) {
        x += handle_collision("x", xspd * move_spd);
        y += handle_collision("y", yspd * move_spd);
    } else {
        y += handle_collision("y", yspd * move_spd);
        x += handle_collision("x", xspd * move_spd);
    }

    if (xspd != 0 || yspd != 0) { image_speed = 0.15; } else { image_speed = 0; image_index = 0; }
    if (image_index >= 3) { image_index = 0; }
}

// Handle existing interactions (only when not in an action)
if (action_state == "none") {
	// Enter/Exit Tube
    if (keyboard_check_pressed(ord("T"))) {
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Tube")) {
                obj_controller.switch_skin("tube");
                show_debug_message("Entered tube mode.");
            } else if (global.current_skin == "tube") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
	// Enter/Exit Toboggan
	if (keyboard_check_pressed(ord("T"))) {
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Toboggan")) {
                obj_controller.switch_skin("toboggan");
                show_debug_message("Entered toboggan mode.");
            } else if (global.current_skin == "toboggan") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
	// Enter/Exit Ice Truck
    if (keyboard_check_pressed(ord("E"))) {
        var truck_nearby = instance_exists(obj_icetruck) && distance_to_object(obj_icetruck) < 16;
        if (instance_exists(obj_controller)) {
            if (truck_nearby && global.current_skin == "player") {
                obj_controller.switch_skin("icetruck");
            } else if (global.current_skin == "icetruck") {
                obj_controller.switch_skin("player");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for ice truck switch.");
        }
    }
	// Repair Ice Truck
    if (keyboard_check_pressed(ord("R"))) {
        if (place_meeting(x, y, obj_icetruck_broken) && 
            (obj_inventory.has_item("Wrench") || obj_inventory.has_item("Battery"))) {
            show_debug_message("Repairing ice truck...");
            if (obj_inventory.has_item("Battery")) {
                show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
                obj_inventory.remove_item("Battery");
            }
            show_debug_message("Battery removed after repair.");
            with (instance_place(x, y, obj_icetruck_broken)) instance_destroy();
            instance_create_layer(x, y, "Instances", obj_icetruck);
            show_debug_message("Ice truck repaired!");
        }
    }
    if (instance_exists(obj_inventory)) { if (obj_inventory.has_item("Fishing Rod")) {} }
}

if (keyboard_check_pressed(ord("E"))) {
    var puffle = instance_nearest(x, y, obj_puffle);
    if (puffle != noone && distance_to_object(puffle) < 32) {
        // Check inventory for Puffle-Oâ€™s
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            global.selected_puffle = puffle;
            global.menu_state = "puffle_menu";
        } else {
            show_message("You need a Puffle O or Box Puffle O to interact with this puffle!");
        }
    }
}

set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Create_0.gml
// Core variables
xspd = 0;
yspd = 0;
move_spd = 2; // Adjust as needed for ice truck speed
state = "driving"; // Since this is the ice truck, assume driving state
if (!variable_global_exists("player_color")) { global.player_color = c_white; }

// Ice truck-specific tint
icetruck_tint = c_yellow; // Default tint for spr_icetruck_colour

// Direction
face = DOWN;

// Sprite definitions
sprite_base = spr_icetruck_base;
sprite_colour = spr_icetruck_colour;
sprite_penguin = spr_icetruck_penguin_colour;
sprite_window_tint = spr_icetruck_window
mask_index = spr_icetruck_down; // Use base sprite for collisions

// Animation variables
image_index = 0; // Current frame
image_speed = 0.1; // Animation speed (adjust as needed)

// Frame data for driving (96x240 sprite sheet: 2 frames per direction)
frame_data = array_create(8); // Array for 8 directions
// [frame1_x, frame1_y, width, height, frame2_x, frame2_y, width, height]
frame_data[DOWN] = [0, 0, 48, 48, 48, 0, 48, 48];           // Row 1
frame_data[DOWN_RIGHT] = [0, 48, 48, 48, 48, 48, 48, 48];  // Row 2
frame_data[RIGHT] = [0, 96, 48, 48, 48, 96, 48, 48];       // Row 3
frame_data[UP_RIGHT] = [0, 144, 48, 48, 48, 144, 48, 48];  // Row 4
frame_data[UP] = [0, 192, 48, 48, 48, 192, 48, 48];        // Row 5
// Left-facing directions will use right-facing frames with flipping
frame_data[DOWN_LEFT] = frame_data[DOWN_RIGHT];
frame_data[LEFT] = frame_data[RIGHT];
frame_data[UP_LEFT] = frame_data[UP_RIGHT];

// Debugging
if (place_meeting(x, y, obj_wall)) {
    show_debug_message("Icetruck colliding with wall at position (" + string(x) + ", " + string(y) + ")");
}

show_debug_message("obj_player_icetruck: Initialized.");
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Draw_0.gml
var draw_x = x;
var draw_y = y;
var frame_index = floor(image_index) mod 2; // 2 frames per direction
var frame_x = frame_data[face][frame_index * 4];
var frame_y = frame_data[face][frame_index * 4 + 1];
var frame_width = frame_data[face][frame_index * 4 + 2];
var frame_height = frame_data[face][frame_index * 4 + 3];

// Determine if flipping is needed
var xscale = 1;
if (face == LEFT || face == DOWN_LEFT || face == UP_LEFT) {
    xscale = -1;
}

// Center the sprite
draw_x -= (frame_width / 2) * xscale;
draw_y -= frame_height / 2;

// Draw all three layers
draw_sprite_part_ext(sprite_base, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
draw_sprite_part_ext(sprite_colour, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, icetruck_tint, 1);
draw_sprite_part_ext(sprite_penguin, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, global.player_color, 1);
draw_sprite_part_ext(sprite_window_tint, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, xscale, 1, c_white, 1);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_icetruck
File: Step_0.gml
// Step Event for obj_player_icetruck
// Prevent movement when paused or colour picker is open
if (global.is_pause_menu_active || instance_exists(obj_icetruck_colourpicker) || instance_exists(obj_inventory_expanded)) {
    show_debug_message("Paused or Colour Picker Open: " + string(instance_exists(obj_icetruck_colourpicker) + instance_exists(obj_inventory_expanded)));
    exit;
}

// Handle exiting the truck
if (keyboard_check_pressed(ord("E"))) {
    if (!place_meeting(x, y, obj_icetruck)) {
        var exit_x = x;
        var exit_y = y + 16;
        instance_destroy(id);
        global.player_instance = instance_create_layer(exit_x, exit_y, "Instances", obj_player);
        instance_create_layer(x, y, "Instances", obj_icetruck);
        global.current_skin = "player";
        show_debug_message("Exited ice truck. Current skin: " + global.current_skin);
    } else {
        show_debug_message("No space to exit!");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Update direction and animation
if (xspd != 0 || yspd != 0) {
    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; }
        else if (xspd > 0) { face = UP_RIGHT; }
        else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; }
        else if (xspd > 0) { face = DOWN_RIGHT; }
        else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; }
        else if (xspd < 0) { face = LEFT; }
    }
    image_speed = 0.1;
    image_index += image_speed;
    if (image_index >= 2) image_index = 0;
} else {
    image_speed = 0;
    image_index = 0;
}

// Apply collision handling
if (instance_exists(obj_wall)) {
    var xspd_adjusted = handle_collision("x", xspd);
    var yspd_adjusted = handle_collision("y", yspd);
    show_debug_message("xspd: " + string(xspd) + " -> " + string(xspd_adjusted) + " | yspd: " + string(yspd) + " -> " + string(yspd_adjusted));
    x += xspd_adjusted;
    y += yspd_adjusted;
} else {
    x += xspd;
    y += yspd;
}

set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Create_0.gml
// Create Event for obj_player_ninja

// Core variables
xspd = 0;
yspd = 0;
move_spd = 3;

// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Driving variables
driving = false;
ice_truck_sprite = spr_icetruck_facedown;
original_sprite = sprite_index;

// Set direction and sprites
face = DOWN;
init_sprites(spr_ninja_right, spr_ninja_up, spr_ninja_left, spr_ninja_down, spr_ninja_up_right, spr_ninja_up_left, spr_ninja_down_right, spr_ninja_down_left);

// Debugging
show_debug_message("obj_player_ninja: Initialized. Driving state: " + string(driving));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_ninja
File: Step_0.gml
// Step Event for obj_player
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Handle interaction with NPC
if (keyboard_check_pressed(ord("E"))) {
    var target_npc = instance_nearest(x, y, obj_npc_old); // Find the nearest NPC
    if (target_npc != noone && distance_to_object(target_npc) < 48) { // Check proximity
        target_npc.current_phrase = target_npc.phrases[irandom_range(0, array_length(target_npc.phrases) - 1)]; // Pick a random phrase
        target_npc.talk_timer = fps * 3; // Show the phrase for 3 seconds
        target_npc.interact_pause = fps * 3; // Pause NPC movement for 3 seconds
        show_debug_message("Player interacted with NPC. NPC says: " + target_npc.current_phrase);
    }
}

// Handle skin switching
if (keyboard_check_pressed(ord("E"))) {
    if (distance_to_object(obj_icetruck) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "icetruck" : "player");
    } else if (distance_to_object(obj_tube) < 32) {
        show_debug_message("E key pressed");
        obj_controller.switch_skin(global.current_skin == "player" ? "tube" : "player");
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Get xspd & yspd
if (!sliding) {
    xspd = (right_key - left_key) * move_spd;
    yspd = (down_key - up_key) * move_spd;
} else {
    // Continue sliding
    xspd = slide_dir_x * slide_speed;
    yspd = slide_dir_y * slide_speed;

    // Decelerate slide over time
    slide_speed *= 0.98; // Adjust this value to control sliding deceleration

    // Stop sliding if speed is low enough
    if (abs(slide_speed) < 0.1) {
        sliding = false;
        xspd = 0;
        yspd = 0;
    }
}

// Pause
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Set sprite
mask_index = sprite[DOWN];
if (yspd < 0) {
    if (xspd < 0) { face = UP_LEFT; }
    else if (xspd > 0) { face = UP_RIGHT; }
    else { face = UP; }
} else if (yspd > 0) {
    if (xspd < 0) { face = DOWN_LEFT; }
    else if (xspd > 0) { face = DOWN_RIGHT; }
    else { face = DOWN; }
} else {
    if (xspd > 0) { face = RIGHT; }
    else if (xspd < 0) { face = LEFT; }
}

sprite_index = sprite[face];

// Collisions
xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);

// Move the player
x += xspd;
y += yspd;

// Animate
if (xspd == 0 && yspd == 0) {
    image_index = 0;
}

// Depth
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Create_0.gml
// Create Event for obj_player_tube
// Core variables
xspd = 0;
yspd = 0;
move_spd = 2; // Same as tube, adjust if desired
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];
toboggan_sprites[UP] = [24, 0];
toboggan_sprites[DOWN_RIGHT] = [48, 0];
toboggan_sprites[UP_LEFT] = [72, 0];
toboggan_sprites[LEFT] = [96, 0];
toboggan_sprites[RIGHT] = [120, 0];
toboggan_sprites[UP_RIGHT] = [144, 0];
toboggan_sprites[DOWN_LEFT] = [168, 0];

mask_index = spr_toboggan; // Create this sprite if not already present
global.player_instance = id;
global.current_skin = "toboggan";
show_debug_message("obj_player_toboggan: Initialized. Player instance ID: " + string(id));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Draw_0.gml
var toboggan_x = toboggan_sprites[face][0];
var toboggan_y = toboggan_sprites[face][1];
draw_sprite_part(spr_toboggan_sheet, 0, toboggan_x, toboggan_y, 24, 24, x - 12, y - 12);

// Draw player sitting (reusing tube positions)
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];
var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, global.player_color, 1);

// Draw the Party Hat if toggled on
if (global.equipped_items.head != -1) {
    var item_index = global.equipped_items.head; // e.g., 0 for Beta Hat, 1 for Party Hat
    var head_sprite = ds_map_find_value(global.item_player_sprites, item_index);
    if (!is_undefined(head_sprite)) {
        show_debug_message("Drawing head item sprite: " + sprite_get_name(head_sprite) + " for item index: " + string(item_index));
        var offset_x = -12; // Adjust this if the hat is misaligned
        var offset_y = -13;
        draw_sprite_part_ext(head_sprite, 0, sit_x, sit_y, 24, 24, x + offset_x, y + offset_y, 1, 1, c_white, 1);
    } else {
        show_debug_message("ERROR: No player sprite found for item index: " + string(item_index));
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_toboggan
File: Step_0.gml
if (global.is_pause_menu_active) exit;

// Exit toboggan
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "toboggan" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Toboggan");
        show_debug_message("Exiting toboggan, switching back to player...");
        var old_instance = id;
        obj_controller.switch_skin("player");
        if (instance_exists(old_instance)) instance_destroy(old_instance);
    }
}

// Movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);
xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Pause check
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update direction
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision and movement
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;
x += handle_collision("x", xspd);
y += handle_collision("y", yspd);

// Depth sorting
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Create_0.gml
// Create Event for obj_player_tube

// Core variables
xspd = 0;
yspd = 0;
move_spd = 1.5;
sliding = true;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 3;

// Set direction
face = DOWN;

// Define sprite positions for the tube
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        
tube_sprites[LEFT] = [0, 0];      
tube_sprites[DOWN] = [24, 0];     
tube_sprites[RIGHT] = [24, 0];    
tube_sprites[UP_LEFT] = [48, 0];  
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; 
tube_sprites[UP_RIGHT] = [72, 0];

// Ensure a valid face direction
if (!array_length(tube_sprites[face])) {
    face = DOWN; // Default if invalid
}

mask_index = spr_tube; // Ensure collision works

// Set global player instance
global.player_instance = id;
global.current_skin = "tube";
is_savable = true;

// Debugging
show_debug_message("obj_player_tube: Initialized. Player instance ID: " + string(id));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];

// Draw player sitting
draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x, y, 1, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x, y, 1, 1, global.player_color, 1);

// Draw the Party Hat if toggled on
if (global.equipped_items.head != -1) {
    var item_index = global.equipped_items.head; // e.g., 0 for Beta Hat, 1 for Party Hat
    var head_sprite = ds_map_find_value(global.item_player_sprites, item_index);
    if (!is_undefined(head_sprite)) {
        show_debug_message("Drawing head item sprite: " + sprite_get_name(head_sprite) + " for item index: " + string(item_index));
        var offset_x = 0; // Adjust this if the hat is misaligned
        var offset_y = -1;
        draw_sprite_part_ext(head_sprite, 0, sit_x, sit_y, 24, 24, x + offset_x, y + offset_y, 1, 1, c_white, 1);
    } else {
        show_debug_message("ERROR: No player sprite found for item index: " + string(item_index));
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_player_tube
File: Step_0.gml
// Prevent player movement and interactions when paused
if (global.is_pause_menu_active) {
    exit; // This prevents the player from updating while paused
}

// Exit the tube
if (keyboard_check_pressed(ord("T"))) {
    if (global.current_skin == "tube" && !global.skin_switching) {
        obj_inventory.add_to_inventory("Tube");
        show_debug_message("Exiting tube, switching back to player...");
        var old_instance = id; // Store old instance ID
        obj_controller.switch_skin("player");
        // Destroy old instance only after switching
        if (instance_exists(old_instance)) {
            instance_destroy(old_instance);
        }
    }
}

// Handle movement input
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

xspd = (right_key - left_key) * move_spd;
yspd = (down_key - up_key) * move_spd;

// Disable movement if the game is paused
if (instance_exists(obj_pauser)) {
    xspd = 0;
    yspd = 0;
}

// Update tube direction and sprite only if moving
if (xspd != 0 || yspd != 0) {
    if (xspd > 0 && yspd == 0) face = RIGHT;
    else if (xspd < 0 && yspd == 0) face = LEFT;
    else if (yspd > 0 && xspd == 0) face = DOWN;
    else if (yspd < 0 && xspd == 0) face = UP;
    else if (xspd > 0 && yspd > 0) face = DOWN_RIGHT;
    else if (xspd > 0 && yspd < 0) face = UP_RIGHT;
    else if (xspd < 0 && yspd > 0) face = DOWN_LEFT;
    else if (xspd < 0 && yspd < 0) face = UP_LEFT;
}

// Collision handling
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;

// Apply movement
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

// Ensure proper depth sorting
set_depth();



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_post_race_menu
File: Create_0.gml
// Initialize menu properties
depth = -99990; // Ensure it draws on top of other objects
image_speed = 0.5; // Animation speed for the background
score_text = "Your Score: " + string(global.sled_score); // Display the playerâ€™s score
button_text = "Return to Ski Village"; // Button label

// Calculate menu position in GUI coordinates
width = 300; // Menu background width
height = 100; // Menu background height
x_pos = (display_get_gui_width() - width) / 2; // Center horizontally
y_pos = (display_get_gui_height() - height) / 2; // Center vertically

// Calculate button position within the menu
button_width = 100;
button_height = 30;
button_x = x_pos + (width - button_width) / 2; // Center horizontally
button_y = y_pos + height - button_height - 10; // Near the bottom
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_post_race_menu
File: Draw_0.gml
// Draw GUI Event for obj_post_race_menu
draw_set_font(fnt_bumbastika_sml); // Set your font
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
draw_set_color(c_black);

// Draw the menu background
draw_sprite_ext(spr_pause_menu, floor(image_index), x_pos, y_pos, width / sprite_get_width(spr_pause_menu), height / sprite_get_height(spr_pause_menu), 0, c_white, 1);

// Draw score and button
draw_text(x_pos + width / 2, y_pos + 20, score_text);
draw_rectangle(button_x, button_y, button_x + button_width, button_y + button_height, false);
draw_text(button_x + button_width / 2, button_y + button_height / 2, button_text);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_post_race_menu
File: Mouse_4.gml
// Mouse Left Pressed Event for obj_post_race_menu
var mx = device_mouse_x_to_gui(0);
var my = device_mouse_y_to_gui(0);

// Check if the mouse is clicking the button
if (point_in_rectangle(mx, my, button_x, button_y, button_x + button_width, button_y + button_height)) {
    room_goto(rm_ski_village); // Go back to the ski village
    instance_destroy(); // Remove the post-race menu
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_powerup
File: Create_0.gml
/// Create Event for obj_powerup
type = choose("coin", "shield");
switch (type) {
    case "coin": sprite_index = spr_coin; break; // Add spr_coin
    case "shield": sprite_index = spr_shield; break; // Add spr_shield
}
x = random_range(0, room_width - sprite_width);
y = room_height + sprite_height;
speed = 5;
direction = 90;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_powerup
File: Step_0.gml
/// Step Event for obj_powerup
if (!global.game_started) exit;
y -= speed;
if (y < -sprite_height) instance_destroy();

if (place_meeting(x, y, obj_sled_player)) {
    with (obj_sled_player) {
        if (other.type == "coin") score += 100;
        else if (other.type == "shield") {
            invincible = true;
            invincible_timer = room_speed * 5;
        }
    }
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Create_0.gml
// Movement variables (adapted from obj_npc_old for wandering)
xspd = 0;
yspd = 0;
move_spd = 0.5; // Slow wandering speed
direction = choose(0, 45, 90, 135, 180, 225, 270, 315); // Random initial direction
change_direction_timer = fps * 2; // Change direction every 2 seconds
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

// Sprite and animation variables
face = DOWN; // Initial direction
image_speed = 0; // Manual animation control
sprite_index = spr_puffle_walk;
anim_frame = 0; // Animation frame (0-7)
anim_speed = 0.2; // Animation speed

// Color customization
var colors = ["red", "blue", "green", "yellow"]; // Add more colors as needed
color = colors[irandom(array_length(colors) - 1)]; // Random color
switch (color) {
    case "red": sprite_index = spr_puffle_walk_red; break;
    case "blue": sprite_index = spr_puffle_walk_blue; break;
    case "green": sprite_index = spr_puffle_walk_green; break;
    case "yellow": sprite_index = spr_puffle_walk_yellow; break;
    // Add cases for other colors with their sprite sheets
    default: sprite_index = spr_puffle_walk_red; // Fallback
}

// Interaction and following variables
following = false;
target = noone;
show_adopt_button = false; // Initially, no adopt button is shown
following_player = false;
assigned_puffle_name = ""; // Empty name initially
naming_active = false; // Not in naming mode
is_savable = true; // For room state persistence
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Draw_0.gml
// Draw Event for obj_puffle

var base_subimage = get_puffle_sprite_data(face);
var anim_frame = floor(image_index % 8);
var final_frame = base_subimage + anim_frame;
draw_sprite(sprite_index, final_frame, x, y);

show_debug_message("Drawing frame: " + string(final_frame));

// Draw adopt button above the puffle
if (show_adopt_button) {
    var button_x = x;
    var button_y = y - sprite_height - 10;
    draw_sprite(spr_blue_bar, 0, button_x, button_y);
}

// Draw naming text box if active
if (naming_active) {
    var textbox_x = global.player_instance.x;
    var textbox_y = global.player_instance.y - global.player_instance.sprite_height - 20;
    draw_sprite(spr_white_bar, 0, textbox_x, textbox_y);
    draw_text(textbox_x + 5, textbox_y + 5, naming_text + "_"); // Blink cursor
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Mouse_4.gml
/// obj_puffle Mouse Left Pressed Event
if (show_adopt_button) {
    var button_x = x;
    var button_y = y - sprite_height - 10;

    // Check if mouse is over the button
    if (point_in_rectangle(mouse_x, mouse_y, button_x - 20, button_y - 10, button_x + 20, button_y + 10)) {
        start_naming_puffle(); // Begin naming process
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffle
File: Step_0.gml
/// obj_puffle Step Event
if (!following_player) {
    // Simple wandering behavior
    if (image_index < 0 || image_index >= 8) image_index = 0;
    image_index += anim_speed; // Increment animation frame
} else if (instance_exists(global.player_instance)) {
    // Follow the player smoothly
    var target_x = global.player_instance.x;
    var target_y = global.player_instance.y;
    x = lerp(x, target_x, 0.1);
    y = lerp(y, target_y, 0.1);

    // Update facing direction based on player's position
    if (abs(target_x - x) > abs(target_y - y)) {
        face = (target_x > x) ? RIGHT : LEFT;
    } else {
        face = (target_y > y) ? DOWN : UP;
    }
}

// Show adopt button when player is near and presses "E"
show_debug_message("Distance to player: " + string(distance_to_object(global.player_instance)));
show_debug_message("E key pressed: " + string(keyboard_check_pressed(ord("E"))));
if (distance_to_object(global.player_instance) < 16 && keyboard_check_pressed(ord("E"))) {
    show_debug_message("Has Box Puffle O: " + string(obj_inventory.has_item("Box Puffle O")));
    if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
        show_adopt_button = true;
    } else {
        show_debug_message("Player lacks Puffle O items.");
    }
}

// Handle naming process if active
if (naming_active) {
    handle_naming_input();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_puffleo_item
File: Create_0.gml
event_inherited();
item_name = "Puffle O";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_pufflewhistle_item
File: Create_0.gml
event_inherited();
item_name = "Puffle Whistle";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Create_0.gml
// Create Event for obj_repair_ui
visible = false;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Draw_64.gml
// Draw GUI Event for obj_repair_ui
if (visible) {
    var ui_x = camera_get_view_x(view_camera[0]) + 20;
    var ui_y = camera_get_view_y(view_camera[0]) + 20;

    draw_set_color(c_white);
    draw_rectangle(ui_x, ui_y, ui_x + 150, ui_y + 50, false);
    draw_set_color(c_black);
    draw_text(ui_x + 10, ui_y + 10, "Press 'E' to Repair");

    // Draw required materials
    for (var i = 0; i < 3; i++) {
        draw_sprite(spr_inventory_items, 7 + i, ui_x + 10 + (i * 20), ui_y + 30);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_repair_ui
File: Step_0.gml
// Step Event for obj_repair_ui
var b = instance_nearest(global.player_instance.x, global.player_instance.y, obj_building);

if (b != noone && distance_to_object(b) < 32 && b.repair_stage == 0) {
    visible = true;
} else {
    visible = false;
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_rocks
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: CleanUp_0.gml
//font_delete(global.font_main);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_settings
File: Create_0.gml
global.font_main = fnt_bumbastika_sml;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_signpost
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skilift
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Create_0.gml
depth = -1000; // Ensuring the skin picker is in front of everything

// Menu dimensions
menu_width = 109;
menu_height = 72;

// Position the skin picker around the current player instance or center it in the view
if (instance_exists(global.player_instance)) {
    x = global.player_instance.x - menu_width / 2;
    y = global.player_instance.y - menu_height / 2;
} else {
    x = view_xview[0] + (view_wview[0] - menu_width) / 2;
    y = view_yview[0] + (view_hview[0] - menu_height) / 2;
}

// Ensure the global skins array exists
if (!variable_global_exists("skins")) {
    global.skins = [
        {object: obj_player_icetruck, name: "Ice Truck"},
        {object: obj_player, name: "Penguin"},
        {object: obj_player_tube, name: "Tube"}
    ];
}

// Button properties
var button_width = 37.5; 
var button_height = 10; 
var button_padding = 2.5; 
var button_x = x + (menu_width - button_width) / 2; 
var button_y = y + button_padding; 

// Create buttons for each skin
for (var i = 0; i < array_length(global.skins); i++) {
    var skin = global.skins[i];
    var btn_skin = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton); // Reference obj_skinpickerbutton
    btn_skin.skin_object = skin.object; // Set the object to switch to
    btn_skin.skin_name = skin.name;    // Set the button label

    // Scale buttons
    btn_skin.image_xscale = button_width / sprite_get_width(spr_button);
    btn_skin.image_yscale = button_height / sprite_get_height(spr_button);

    button_y += button_height + button_padding; // Position the next button
}

// Create a Close button
var btn_close = instance_create_layer(button_x, button_y, "Instances", obj_skinpickerbutton);
btn_close.skin_object = noone; // No skin switch, just close
btn_close.skin_name = "Close"; 
btn_close.sprite_index = spr_button;

// Scale the Close button
btn_close.image_xscale = button_width / sprite_get_width(spr_button);
btn_close.image_yscale = button_height / sprite_get_height(spr_button);



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Destroy_0.gml
// Destroy all button instances when the skin picker menu is destroyed
with (obj_skinpickerbutton) {
    instance_destroy(); // Destroy all buttons linked to this menu
}
shader_reset(); // Reset the shader to remove the blur effect

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: Draw_0.gml
// Draw Event for obj_skinpicker
//if (shader_is_compiled(shd_blur)) {
    // Apply blur shader
//    var tex = surface_get_texture(application_surface);
//    shader_set(shd_blur);
 //   shader_set_uniform_i(shader_get_uniform(shd_blur, "texture"), tex);
//    draw_surface(application_surface, 0, 0);
//    shader_reset();
//}

// Draw the skin picker menu
draw_self();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpicker
File: KeyPress_80.gml
show_debug_message("Buttons left: " + string(instance_number(obj_skinpickerbutton)));
show_debug_message("Skinpickers left: " + string(instance_number(obj_skinpicker)));
show_debug_message("Skin picker buttons: " + string(instance_number(obj_skinpickerbutton)));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Create_0.gml
depth = -1010; // Ensure buttons are in front of the skin picker

// Initialize button-specific variables
skin_object = noone; // The skin this button switches to
skin_name = "";      // The name displayed on the button

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Draw_0.gml
// Draw Event for obj_button
draw_self(); // Draw the button sprite

// Draw the button text
draw_set_color(c_black); // Set text color to black
draw_set_halign(fa_center); // Center text horizontally
draw_set_valign(fa_middle); // Center text vertically

var button_width = sprite_width * image_xscale;
var button_height = sprite_height * image_yscale;

var text_x = x + button_width / 2;
var text_y = y + button_height / 2;

draw_text(text_x, text_y, skin_name); // Center the text
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_skinpickerbutton
File: Mouse_4.gml
if (skin_object != noone) {
    // Ensure the player instance exists
    if (instance_exists(global.player_instance)) {
        // Store the current player position
        var player_x = global.player_instance.x;
        var player_y = global.player_instance.y;

        // Destroy the current player instance
        instance_destroy(global.player_instance);

        // Create the new player instance with the selected skin
        global.player_instance = instance_create_layer(player_x, player_y, "Instances", skin_object);
        global.current_skin = skin_name; // Update the current skin name

        show_debug_message("Skin switched to: " + global.current_skin);
    } else {
        show_debug_message("Error: global.player_instance does not exist!");
    }
} else if (skin_name == "Close") {
    // Close the menu
    with (obj_skinpicker) {
        instance_destroy();
    }
    show_debug_message("Skin picker closed.");
} else {
    show_debug_message("Error: Skin object is invalid.");
}

// Destroy the skin picker menu if a valid skin was selected
if (skin_object != noone) {
    with (obj_skinpicker) {
        instance_destroy();
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_finishline
File: Step_0.gml
/// Step Event for obj_sled_finishline
if (global.game_started) {
    y -= global.scroll_speed;
    if (place_meeting(x, y, obj_sled_player)) {
        with (obj_sled_player) {
            global.sled_score = score;
            race_finished = true;
        }
        instance_create_layer(0, 0, "Instances", obj_post_race_menu);
        instance_destroy();
    }
}
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_log
File: Collision_obj_sled_player.gml
if (other == obj_sled_player) {
        global.player_lives -= 1; // Player loses a life
    }
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_log
File: Create_0.gml
image_index = irandom(1); // Randomly pick frame 0 or 1 ONCE

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_log
File: Step_0.gml
/// Step Event for obj_sled_log
if (global.obstacles_moving) {
    y -= global.scroll_speed;
    if (y < -sprite_height) {
        y = room_height + sprite_height; // Reset position
        x = irandom_range(0, room_width - sprite_width);
    }
}
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_log_snowcovered
File: Create_0.gml
image_index = irandom(1); // Randomly pick frame 0 or 1 ONCE

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_log_snowcovered
File: Step_0.gml
if (global.obstacles_moving) {
    y -= global.scroll_speed;
    if (y < -sprite_height) {
        y = room_height + sprite_height;
        x = irandom_range(0, room_width - sprite_width);
    }
}
set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_menu
File: Create_0.gml
/// Create Event for obj_sled_menu
depth = -1000;

sleds = [
    { name: "Tube", speed: 4, lives: 3, desc: "Balanced Ride" },
    { name: "Toboggan", speed: 4, lives: 3, desc: "Fast & Tricky" }
];

button_width = 150;
button_height = 50;
button_spacing = 20;
start_y = 200;
for (var i = 0; i < array_length(sleds); i++) {
    var btn = instance_create_layer(room_width / 2 - button_width / 2, start_y + i * (button_height + button_spacing), "Instances", obj_sled_menu_button);
    btn.sled_name = sleds[i].name;
    btn.desc = sleds[i].desc;
    btn.sled_image = (sleds[i].name == "Tube") ? spr_tube : spr_toboggan;
}

if (instance_exists(obj_inventory)) obj_inventory.visible = false;
if (instance_exists(global.player_instance)) {
    global.player_instance.visible = false;
    global.player_controls_enabled = false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_menu
File: Draw_0.gml
/// Draw Event for obj_sled_menu
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
draw_set_color(c_black); // High score text in black
draw_text(room_width / 2, 50, "Choose Your Sled");
draw_text(room_width / 2, 100, "High Score: " + string(global.high_scores[0]));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_menu_button
File: Create_0.gml
/// Create Event for obj_sled_menu_button
sled_name = "";
desc = "";
sled_image = noone; // Add sprite for sled image
sprite_index = spr_button;
image_xscale = 150 / sprite_get_width(spr_button);
image_yscale = 50 / sprite_get_height(spr_button);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_menu_button
File: Draw_0.gml
/// Draw Event for obj_sled_menu_button
draw_self();
if (sled_image != noone) {
    draw_sprite(sled_image, 0, x - 50, y); // Position image to the left of the button
}
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
draw_text(x + sprite_width / 2, y + sprite_height / 2, sled_name + "\n" + desc);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_menu_button
File: Mouse_4.gml
/// Mouse Left Pressed Event for obj_sled_menu_button
global.selected_sled_type = sled_name; // Update to use sled_type
room_goto(rm_sled_racing);
show_debug_message("Selected sled: " + sled_name);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Create_0.gml
/// Create Event for obj_sled_player
global.scroll_speed = 1; // Reduced from 2 to slow down movement (adjust as needed)
race_timer = 10 * room_speed; // e.g., 90 seconds at 60 FPS
countdown = 3 * room_speed; // 3-second countdown
race_started = false;
global.game_started = false;
obstacles_delay = 1 * room_speed; // Delay before obstacles move
global.obstacles_moving = false;
xspd = 0;
acceleration = 0.25;
deceleration = 0.15;
max_spd = 5;
lives = 3;
invincible = false;
invincible_timer = 0;
score = 0;
global.player_instance = id;
face = DOWN;
race_finished = false;
is_savable = true;

sled_type = global.selected_sled_type;
if (global.current_skin == "icetruck") {
    sled_type = "icetruck";
    invincible = true;
    icetruck_tint = instance_exists(obj_player_icetruck) ? obj_player_icetruck.icetruck_tint : c_white;
}

tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];
tube_sprites[LEFT] = [0, 0];
tube_sprites[DOWN] = [24, 0];
tube_sprites[RIGHT] = [24, 0];
tube_sprites[UP_LEFT] = [48, 0];
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0];
tube_sprites[UP_RIGHT] = [72, 0];

toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];
toboggan_sprites[UP] = [24, 0];
toboggan_sprites[DOWN_RIGHT] = [48, 0];
toboggan_sprites[UP_LEFT] = [72, 0];
toboggan_sprites[LEFT] = [96, 0];
toboggan_sprites[RIGHT] = [120, 0];
toboggan_sprites[UP_RIGHT] = [144, 0];
toboggan_sprites[DOWN_LEFT] = [168, 0];

sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

switch (sled_type) {
    case "Tube":
        move_spd = 4;
        lives = 3;
        mask_index = spr_tube;
        break;
    case "Toboggan":
        move_spd = 4;
        lives = 3;
        mask_index = spr_toboggan;
        break;
    case "icetruck":
        move_spd = 5;
        lives = 3;
        mask_index = spr_icetruck_down;
        break;
    default:
        move_spd = 4;
        lives = 3;
        mask_index = spr_tube;
}
global.player_instance = id;
show_debug_message("obj_sled_player initialized with sled type: " + string(sled_type));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Draw_0.gml
/// Draw Event for obj_sled_player
var base_x, base_y, flip = 1;

// Draw base sprite (tube, toboggan, or icetruck)
if (sled_type == "icetruck") {
    draw_sprite_part(spr_icetruck_base, 0, 0, 0, 48, 48, x - 24, y - 24);
    draw_sprite_part_ext(spr_icetruck_colour, 0, 0, 0, 48, 48, x - 24, y - 24, 1, 1, icetruck_tint, 1);
    draw_sprite_part(spr_icetruck_window, 0, 0, 0, 48, 48, x - 24, y - 24);
} else if (global.selected_sled_type == "Tube") {
    base_x = tube_sprites[face][0];
    base_y = tube_sprites[face][1];
    draw_sprite_part(spr_tube_sheet, 0, base_x, base_y, 24, 24, x - 12, y - 12);
} else if (global.selected_sled_type == "Toboggan") {
    base_x = toboggan_sprites[face][0];
    base_y = toboggan_sprites[face][1];
    draw_sprite_part(spr_toboggan_sheet, 0, base_x, base_y, 24, 24, x - 12, y - 12);
}

// Draw player sitting
var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
if (sled_type != "icetruck") {
    draw_sprite_part_ext(spr_player_body, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, c_white, image_alpha);
    draw_sprite_part_ext(spr_player_colour, 0, sit_x, sit_y, 24, 24, x - 12, y - 12, 1, 1, global.player_color, image_alpha);
}

// Ensure font is set for readability
draw_set_font(fnt_bumbastika_sml); // Use a defined font from your project
if (countdown > 0) {
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_set_color(c_black);
    draw_text(room_width / 2, room_height / 2, "Starting in " + string(ceil(countdown / room_speed)));
} else if (race_started) {
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_color(c_black);
    draw_text(10, 10, "Lives: " + string(lives));
    draw_text(10, 30, "Score: " + string(score));
    draw_text(10, 50, "Time: " + string(ceil(race_timer / room_speed)));
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Other_4.gml
// Room Start Event for obj_sled_player
global.player_instance = id;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sled_player
File: Step_0.gml
/// Step Event for obj_sled_player
if (instance_exists(obj_post_race_menu)) exit;

if (countdown > 0) {
    countdown -= 1;
    if (countdown == 0) {
        race_started = true;
        global.game_started = true;
        // Spawn finish line based on race_timer and scroll speed
        instance_create_layer(room_width / 2 - 16, y + race_timer * global.scroll_speed, "Instances", obj_sled_finishline);
    }
    exit;
}

if (!race_started) exit;

if (obstacles_delay > 0) {
    obstacles_delay -= 1;
    if (obstacles_delay == 0) {
        global.obstacles_moving = true;
    }
}

var left_key = keyboard_check(vk_left) || keyboard_check(ord("A"));
var right_key = keyboard_check(vk_right) || keyboard_check(ord("D"));
if (left_key) xspd -= acceleration;
else if (right_key) xspd += acceleration;
else {
    xspd = (xspd > 0) ? max(xspd - deceleration, 0) : min(xspd + deceleration, 0);
}
xspd = clamp(xspd, -max_spd, max_spd);
x += xspd;
x = clamp(x, 0, room_width - sprite_width);

if (invincible) {
    invincible_timer -= 1;
    if (invincible_timer <= 0) invincible = false;
    image_alpha = 0.5 + 0.5 * sin(current_time * 0.01);
} else {
    image_alpha = 1;
}

race_timer -= 1;
if (lives <= 0 || race_timer <= 0) {
    race_finished = true;
    global.sled_score = score;
    instance_create_layer(0, 0, "Instances", obj_post_race_menu);
    instance_destroy();
}
score += 1;

if (xspd > 0) face = RIGHT;
else if (xspd < 0) face = LEFT;
else face = DOWN;

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Create_0.gml
xspd = 0;
yspd = 0;

sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_slippery
File: Step_0.gml
if (place_meeting(x, y, obj_player) || place_meeting(x, y, obj_player_tube)) {
    if (!sliding) {
        sliding = true;
        
        // Get the player's last movement direction
        var player = instance_nearest(x, y, obj_player); // Get closest player
        if (!instance_exists(player)) player = instance_nearest(x, y, obj_player_tube);

        if (instance_exists(player)) {
            slide_dir_x = sign(player.xspd);
            slide_dir_y = sign(player.yspd);
            slide_speed = max(abs(player.xspd), abs(player.yspd)); // Carry over momentum
        }
    }
}

// **Sliding Deceleration Logic**
if (sliding) {
    x += slide_dir_x * slide_speed;
    y += slide_dir_y * slide_speed;

    // Reduce speed gradually
    slide_speed *= 0.95; 

    // Stop sliding when slow enough
    if (slide_speed < 0.1) {
        sliding = false;
        slide_speed = 0;
    }

    // **Collision Handling (Bounce Effect)**
    if (place_meeting(x + slide_dir_x * slide_speed, y, obj_wall)) {
        slide_dir_x = -slide_dir_x; // Reverse direction on X collision
        slide_speed *= 0.7; // Reduce speed slightly when bouncing
    }
    
    if (place_meeting(x, y + slide_dir_y * slide_speed, obj_wall)) {
        slide_dir_y = -slide_dir_y; // Reverse direction on Y collision
        slide_speed *= 0.7;
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_bushes
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_small_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_sml_boat
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Create_0.gml
direction = 0; // Set by player
speed = 0;     // Set by player
sprite_index = spr_snowball; // Placeholder; create a 16x16 sprite
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Draw_0.gml
draw_self();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowball
File: Step_0.gml
x += lengthdir_x(speed, direction);
y += lengthdir_y(speed, direction);
if (place_meeting(x, y, obj_wall) || x < 0 || x > room_width || y < 0 || y > room_height) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snowshovel_item
File: Create_0.gml
event_inherited();
item_name = "Snow Shovel";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_snow_item
File: Create_0.gml
event_inherited();
item_name = "Snow";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_spyphone_item
File: Create_0.gml
event_inherited();
item_name = "Spy Phone";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_stampbook_item
File: Create_0.gml
event_inherited();
item_name = "Stamp Book";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_starterdeck_item
File: Create_0.gml
event_inherited();
item_name = "Starter Deck";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_startpoles
File: Step_0.gml
if (global.game_started) {
    y -= global.scroll_speed;
    if (y < -sprite_height) {
        y = room_height + sprite_height;
        x = room_width / 2 - sprite_width / 2;
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_bush
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tall_trees
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Create_0.gml
item_name = "Toboggan";
face = DOWN;
is_savable = true;

// Define sprite positions for spr_toboggan_sheet
toboggan_sprites = array_create(8);
toboggan_sprites[DOWN] = [0, 0];
toboggan_sprites[UP] = [24, 0];
toboggan_sprites[DOWN_RIGHT] = [48, 0];
toboggan_sprites[UP_LEFT] = [72, 0];
toboggan_sprites[LEFT] = [96, 0];
toboggan_sprites[RIGHT] = [120, 0];
toboggan_sprites[UP_RIGHT] = [144, 0];
toboggan_sprites[DOWN_LEFT] = [168, 0];
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Draw_0.gml
// Get tube sprite position
var base_x = toboggan_sprites[face][0];
var base_y = toboggan_sprites[face][1];
draw_sprite_part(spr_toboggan_sheet, 0, base_x, base_y, 24, 24, x - 12, y - 12);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_toboggan
File: Step_0.gml
event_inherited();
item_name = "Toboggan";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tour_booth
File: Create_0.gml
//depth
depth = -bbox_bottom;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Create_0.gml
item_name = "Tube";

// Core variables
face = DOWN;

// Assign sprite sheet directions (indices for spr_tube_sheet)
tube_sprites = array_create(8);
tube_sprites[UP] = [0, 0];        // UP, LEFT
tube_sprites[LEFT] = [0, 0];
tube_sprites[DOWN] = [24, 0];     // DOWN, RIGHT
tube_sprites[RIGHT] = [24, 0];
tube_sprites[UP_LEFT] = [48, 0];  // UP_LEFT, DOWN_RIGHT
tube_sprites[DOWN_RIGHT] = [48, 0];
tube_sprites[DOWN_LEFT] = [72, 0]; // DOWN_LEFT, UP_RIGHT
tube_sprites[UP_RIGHT] = [72, 0];
is_savable = true;
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Destroy_0.gml
instance_destroy(); // Destroy the current ice truck instance
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Draw_0.gml
// Get tube sprite position
var tube_x = tube_sprites[face][0];
var tube_y = tube_sprites[face][1];

// Draw tube
draw_sprite_part(spr_tube_sheet, 0, tube_x, tube_y, 24, 24, x, y);

// Draw player sitting inside the tube
var sitting_sprites = array_create(8);
sitting_sprites[DOWN] = [0, 72];
sitting_sprites[DOWN_LEFT] = [24, 72];
sitting_sprites[LEFT] = [48, 72];
sitting_sprites[UP_LEFT] = [72, 72];
sitting_sprites[UP] = [96, 72];
sitting_sprites[UP_RIGHT] = [120, 72];
sitting_sprites[RIGHT] = [144, 72];
sitting_sprites[DOWN_RIGHT] = [168, 72];

var sit_x = sitting_sprites[face][0];
var sit_y = sitting_sprites[face][1];
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_tube
File: Step_0.gml
event_inherited();
item_name = "Tube";

set_depth();
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Create_0.gml
// obj_ui_create.txt
// Initialize variables
ui_elements = []; // Array to store UI elements

// Example: Add a button to the UI
var button = {
    x: 100,
    y: 100,
    width: 200,
    height: 50,
    text: "Click Me",
    action: function() {
        show_message("Button Clicked!");
    }
};
array_push(ui_elements, button);
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Draw_0.gml
// obj_ui_draw.txt
// Set font and alignment for UI text
draw_set_font(fnt_bumbastika_sml);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);

// Draw UI elements
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    draw_rectangle(elem.x, elem.y, elem.x + elem.width, elem.y + elem.height, false);
    draw_text(elem.x + elem.width / 2, elem.y + elem.height / 2, elem.text);
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_ui
File: Mouse_4.gml
// obj_ui_leftpressed.txt
// Get mouse position
var mouse_x_pos = device_mouse_x_to_gui(0);
var mouse_y_pos = device_mouse_y_to_gui(0);

// Check if any UI element is clicked
for (var i = 0; i < array_length(ui_elements); i++) {
    var elem = ui_elements[i];
    if (mouse_x_pos > elem.x && mouse_x_pos < elem.x + elem.width && mouse_y_pos > elem.y && mouse_y_pos < elem.y + elem.height) {
        // Execute the action associated with the UI element
        elem.action();
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wall
File: Step_0.gml
set_depth();

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Alarm_0.gml
/// Alarm[0] Event
global.warp_cooldown = false;
show_debug_message("DEBUG: Warp cooldown finished. Player can warp again.");

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Create_0.gml
// obj_warp: Create Event
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
target_instance = noone;

global.warp_cooldown = true;
alarm[0] = room_speed / 2;

show_debug_message("obj_warp initialized. Target Room: " + string(target_rm));

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Draw_0.gml
draw_sprite_tiled(sprite_index, image_index, 0, 0)
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Other_7.gml
/// Animation End Event for obj_warp
show_debug_message("DEBUG: obj_warp transition initiated. Moving player before room transition.");
global.player_instance = target_instance; // Update global instance
// Ensure the player moves before switching rooms
if (target_instance != noone) {
    target_instance.x = target_x;
    target_instance.y = target_y;
    target_instance.face = target_face;
    show_debug_message("Player successfully moved to new position.");
} else {
    show_debug_message("ERROR: Target instance not found during warp.");
}

// Perform the room transition
room_goto(target_rm);

// Restore camera settings
if (instance_exists(global.camera)) {
    view_set_camera(0, global.camera);
    camera_set_view_size(global.camera, 640, 480);
    show_debug_message("DEBUG: Camera viewport restored after room transition.");
}

show_debug_message("obj_warp reached Animation End, going to " + room_get_name(target_rm));
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp
File: Step_0.gml
// Step Event for obj_warp
if (room == target_rm && image_index < 1) {
    instance_destroy();
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Create_0.gml
target_rm = 0;
target_x = 0;
target_y = 0;
target_face = 0;
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}



Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Other_4.gml
// Check if a warp instance exists
if (instance_exists(obj_warp)) {
    var warp_inst = instance_find(obj_warp, 0);
    if (warp_inst != noone) {
        // Move the player instance to the target coordinates
        global.player_instance.x = warp_inst.target_x;
        global.player_instance.y = warp_inst.target_y;

        // Optional: Adjust the player's facing direction
        if (is_real(warp_inst.target_face)) {
            global.player_instance.face = warp_inst.target_face;
        }

        // Destroy the warp instance once used
        instance_destroy(warp_inst);
    }
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_block
File: Step_0.gml
/// Step Event for obj_warp_block
// Handle Player Warping
if (instance_exists(global.player_instance) && place_meeting(x, y, global.player_instance) && !instance_exists(obj_warp)) 
{
    show_debug_message("DEBUG: obj_player detected on obj_warp_block. Warping...");
    
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;   // Ensure correct target coordinates
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance; // Use global instance of player
	
}

// Handle NPC Warping
if (instance_exists(obj_npc_old) && place_meeting(x, y, obj_npc_old) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = obj_npc_old.face;
    inst.target_instance = instance_find(obj_npc_old, 0);

}

if (!global.warp_cooldown && instance_exists(global.player_instance) && place_meeting(global.player_instance.x, global.player_instance.y, id) && !instance_exists(obj_warp)) 
{
    var inst = instance_create_depth(0, 0, -9999, obj_warp);
    inst.target_x = self.target_x;
    inst.target_y = self.target_y;
    inst.target_rm = self.target_rm;
    inst.target_face = self.target_face;
    inst.target_instance = global.player_instance;
}


Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Create_0.gml
// obj_warp_map: Create Event
target_rm = noone;  // Set this in Creation Code
target_x = 0;  
target_y = 0;  
target_face = 0;  
depth = -9999;  // Ensure it's drawn on top
// Create Event for obj_warp
if (!variable_global_exists("warp_cooldown")) {
    global.warp_cooldown = false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_warp_map
File: Mouse_4.gml
// obj_warp_map: Left Pressed Event (Handles Click to Warp)
if (target_rm != noone) {
    show_debug_message("Warping to Room: " + string(target_rm) + " at (" + string(target_x) + ", " + string(target_y) + ")");
    
    // Store last room before warping
    global.last_room = room;  
    
    // Create warp instance to handle transition
    var warp_inst = instance_create_depth(0, 0, -9999, obj_warp);
    warp_inst.target_rm = target_rm;
    warp_inst.target_x = target_x;
    warp_inst.target_y = target_y;
    warp_inst.target_face = target_face;
    warp_inst.target_instance = global.player_instance;

	global.camera_reset = true; // Ensure camera resets correctly
    // Room transition handling
    room_goto(target_rm);

    // Improved handling to check if player instance exists after room transition
    alarm[0] = 2;  // Set alarm to delay camera setup and check for player existence
}

Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wood_item
File: Create_0.gml
event_inherited();
item_name = "Wood";
Folder: D:\PenguinIsleProject\Penguin Isles\objects\obj_wrench_item
File: Step_0.gml
event_inherited();
item_name = "Wrench";
