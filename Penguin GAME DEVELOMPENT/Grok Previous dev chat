You are an expert GameMaker Studio 2 developer, a master in game design and a code optimization expert.I will provide you with GameMaker Language (GML) code. Can you analyse both gml file and gml script files to gain an understanding of the current object codebase used in my project. You will maintain a consistent understanding of the game's mechanics, logic systems, and design goals as I describe them.  Please provide clear and concise instructions to guide me in adding and implementing your changes and revised code into my project. I want to be able to quickly copy and paste the updated code into my project for testing.I want to add a new special action, "Snowball" When "O" is pressed, the player will throw a snowball in the general direction their currently facing.I have created two new sprites spr_throwsnowball_body & spr_throwsnowball_colour to serve as the special actions sprite. Both are 192x168 with 8x7 grid made up of 24x24 animation frames.I have only two directions, with both using 24 frames.
Throw Face Down Right
Frame 1 - 0,0 23,23
Frame 2 - 24,0 47,23
Frame 8 - 168,0 191,23
Frame 9 - 0,24 23,47
Frame 16 - 168,24 191,47
Frame 28 - 72,72 95,95Throw Face Up Right
Frame 1 - 96,72 119,95
Frame 4 - 168,72 191,95
Frame 5 - 0,96 23,119
Frame 13 - 0,120 23,143
Frame 25 - 0,144 23,167
Frame 28 - 168,144 191,167please fill in the rest of the data using your reasoning also flip the sprite to create a face down left and face up left.I don't have a sprite for snowball itself but can you code a small ball projectile to move in the direction the player was facing when throwing the snowball.Feel free to add anything else you think is relevant.

Thought for
1m 58s

Expand for details

So I have this task to add a new special action in my GameMaker Studio 2 project. The action is called "Snowball," and it's triggered when the player presses the "O" key. When that happens, the player should throw a snowball in the direction they're currently facing. I've already created two sprites for this action: spr_throwsnowball_body and spr_throwsnowball_colour. Both are 192x168 pixels with an 8x7 grid of 24x24 pixel frames. There are animations for throwing the snowball in two directions: Face Down Right and Face Up Right, each with 28 frames. I need to fill in the frame data for these directions and also create flipped versions for Face Down Left and Face Up Left. Additionally, I need to code a small ball projectile that moves in the direction the player was facing when throwing the snowball.
First, I need to understand the sprite layout. The sprites are 192x168 pixels, which, with 24x24 pixel frames, means there are 8 frames horizontally (192 / 24 = 8) and 7 frames vertically (168 / 24 = 7). So, it's an 8x7 grid, totaling 56 frames. However, for each direction, only 28 frames are used, which makes sense since 28 is half of 56, suggesting that the sprite sheet might contain animations for two directions, or perhaps mirrored versions.
Wait, actually, in the description, it says there are animations for Throw Face Down Right and Throw Face Up Right, each with 28 frames. So, probably, the first 28 frames are for one direction, and the next 28 for the other. But looking at the frame coordinates provided, it seems like the frames are not sequential in a simple row or column order.
For Throw Face Down Right, the frames are:
Frame 1: 0,0 to 23,23

Frame 2: 24,0 to 47,23

...

Frame 8: 168,0 to 191,23

Frame 9: 0,24 to 23,47

...

Frame 16: 168,24 to 191,47

...

Frame 28: 72,72 to 95,95

Similarly, for Throw Face Up Right:
Frame 1: 96,72 to 119,95

Frame 4: 168,72 to 191,95

Frame 5: 0,96 to 23,119

...

Frame 13: 0,120 to 23,143

...

Frame 25: 0,144 to 23,167

Frame 28: 168,144 to 191,167

Wait, actually, looking at the coordinates, it seems like the frames are not in a straightforward order. For example, in Throw Face Down Right, it starts at 0,0, then 24,0, up to 168,0, then jumps to 0,24, and so on. Similarly for Throw Face Up Right, it starts at 96,72, then possibly continues in a certain pattern.
Actually, since it's an 8x7 grid, with each cell being 24x24, I can think of the frames as being arranged in rows and columns. For instance, the top-left frame is at (0,0), the next to the right is at (24,0), up to (168,0) for the eighth frame in the first row. Then the second row starts at (0,24), and so on.
Given that, for Throw Face Down Right, the frames seem to be in a specific sequence across the grid. Similarly for Throw Face Up Right.
But to make it easier, perhaps I can define the frame positions for each direction.
First, I need to map the frame numbers to their positions in the sprite sheet.
Wait, maybe it's better to define an array or a list of [x, y] positions for each frame in the animation sequence for each direction.
For example, for Throw Face Down Right, the sequence is:
Frame 1: 0,0
Frame 2: 24,0
...
Frame 8: 168,0
Frame 9: 0,24
...
Frame 16: 168,24
...
Up to Frame 28: 72,72
Wait, actually, 72,72 would be the fourth column in the fourth row, since 72 / 24 = 3, so column 3, row 3 (starting from 0).
But to generalize, perhaps the animation sequence is laid out in a specific pattern in the sprite sheet.
Alternatively, maybe the sprite sheet has the animation frames in a row-major order, and the sequence is simply the first 28 frames for one direction and the next 28 for the other.
But looking at the provided frames, for Throw Face Up Right, Frame 1 is at 96,72, which is column 4, row 3 (since 96/24=4, 72/24=3), and then Frame 4 at 168,72 (column 7, row 3), Frame 5 at 0,96 (column 0, row 4), etc.
This seems a bit scattered, so perhaps the frames are not in a simple sequential order.
Wait, another possibility is that the sprite sheet contains multiple animations, and the frames for each animation are interleaved or arranged in a certain way.
But to make progress, since I need to define the frame sequence for each direction, I can manually specify the [x, y] positions for each frame in the animation.
For Throw Face Down Right, I have some frames listed, but not all 28. Similarly for Throw Face Up Right.
Wait, actually, in the problem statement, it says "please fill in the rest of the data using your reasoning", so I need to infer the pattern.
Let's try to find a pattern for Throw Face Down Right.
Given:
Frame 1: 0,0
Frame 2: 24,0
...
Frame 8: 168,0
So, frames 1 to 8 are the first row: columns 0 to 7, row 0.
Then Frame 9: 0,24 (column 0, row 1)
Presumably, frames 9 to 16 are the second row: columns 0 to 7, row 1.
Then, since Frame 16 is 168,24 (column 7, row 1), and Frame 28 is 72,72 (column 3, row 3), perhaps the animation continues to the third and fourth rows.
But wait, 28 frames would be 3.5 rows (since 8 frames per row), so perhaps it goes to row 3, column 3.
Wait, actually, 28 frames: 3 full rows (24 frames) plus 4 more frames in the fourth row.
But in the sprite sheet, there are 7 rows, so plenty of space.
However, for Throw Face Up Right, Frame 1 is at 96,72 (column 4, row 3), which is in the fourth row, and then Frame 4 at 168,72 (column 7, row 3), Frame 5 at 0,96 (column 0, row 4), etc.
So, perhaps for Throw Face Down Right, the animation is in the first 3.5 rows, and for Throw Face Up Right, it's in the next 3.5 rows or something similar.
But to simplify, since I need to define the frame sequence, I can assume that for each direction, the 28 frames are consecutive in some order.
For now, let's assume that for Throw Face Down Right, the frames are the first 28 frames in row-major order, i.e., rows 0 to 3, columns 0 to 7, but since 28 frames are 3 rows (24 frames) plus 4 frames in row 4.
Similarly, for Throw Face Up Right, it might be the next 28 frames, starting from row 4 or so.
But looking at the provided frames, for Throw Face Up Right, Frame 1 is at column 4, row 3, which is frame index 3*8 + 4 = 28, if we number frames from 0.
Wait, let's number the frames from 0 to 55 (since 8*7=56 frames).
So, frame at (column c, row r) is index r*8 + c.
For Throw Face Down Right, Frame 1: (0,0) -> index 0
Frame 2: (1,0) -> index 1
...
Frame 8: (7,0) -> index 7
Frame 9: (0,1) -> index 8
...
Frame 16: (7,1) -> index 15
Then, presumably, Frame 17: (0,2) -> index 16, up to Frame 28: (3,3) -> index 27 (since 3*8 + 3 = 27)
Wait, but in the description, Frame 28 is at 72,72, which is (72/24=3, 72/24=3), so column 3, row 3, index 3*8 + 3 = 27, yes.
So, for Throw Face Down Right, it's frames 0 to 27 in row-major order.
Similarly, for Throw Face Up Right, Frame 1 is at 96,72, which is (96/24=4, 72/24=3), so column 4, row 3, index 3*8 + 4 = 28
Then Frame 4 at 168,72 (column 7, row 3) -> index 3*8 + 7 = 31
Frame 5 at 0,96 (column 0, row 4) -> index 4*8 + 0 = 32
Frame 13 at 0,120 (column 0, row 5) -> index 5*8 + 0 = 40
Frame 25 at 0,144 (column 0, row 6) -> index 6*8 + 0 = 48
Frame 28 at 168,144 (column 7, row 6) -> index 6*8 + 7 = 55
So, it seems that for Throw Face Up Right, the frames are from index 28 to 55.
Wait, but let's check the sequence. From the description, Frame 1: index 28, then Frame 4: index 31, Frame 5: index 32, Frame 13: index 40, Frame 25: index 48, Frame 28: index 55.
So, perhaps the sequence is frames 28 to 55 in order.
Similarly, for Throw Face Down Right, frames 0 to 27.
Therefore, I can define the frame sequences as:
For Throw Face Down Right: frames 0 to 27
For Throw Face Up Right: frames 28 to 55
Now, since the player can face eight directions, but the sprite sheet only has animations for two directions, I need to map the player's facing direction to these animations.
Specifically, for Face Down Right and Face Up Right, and then flip them for Face Down Left and Face Up Left.
Wait, but actually, in the problem statement, it says "Throw Face Down Right" and "Throw Face Up Right", and then "flip the sprite to create Face Down Left and Face Up Left".
So, probably, these are diagonal directions.
In many games, including this one, the player can face eight directions: UP, DOWN, LEFT, RIGHT, UP_LEFT, UP_RIGHT, DOWN_LEFT, DOWN_RIGHT.
So, for the snowball throwing, perhaps when the player is facing DOWN_RIGHT, use the Throw Face Down Right animation, when facing UP_RIGHT, use Throw Face Up Right, and similarly for DOWN_LEFT and UP_LEFT by flipping the sprites.
For the cardinal directions (UP, DOWN, LEFT, RIGHT), I might need to decide which animation to use. Perhaps map them to the closest diagonal direction or have separate animations, but since only two are provided, I'll assume that for cardinal directions, we can use one of the diagonal animations or perhaps not allow throwing in those directions, but that might not be ideal.
Wait, probably, I can map the cardinal directions to the nearest diagonal. For example:
If facing RIGHT, use Throw Face Down Right (or Up Right, but since it's throwing, maybe Down Right makes more sense)

If facing LEFT, use the flipped Throw Face Down Left

Similarly for UP and DOWN.

Alternatively, perhaps the animation is designed such that Throw Face Down Right can be used for DOWN and RIGHT, and Throw Face Up Right for UP and RIGHT, but since it's a throwing animation, it might be specific to the direction.
Wait, another way is to have the snowball thrown in the exact direction the player is facing, and use the appropriate animation based on the direction.
Since there are only two animations, perhaps I can use Throw Face Down Right for directions DOWN, DOWN_RIGHT, RIGHT, and maybe DOWN_LEFT, and use Throw Face Up Right for UP, UP_RIGHT, RIGHT, and UP_LEFT, but that overlaps on RIGHT.
Alternatively, perhaps use Throw Face Down Right for DOWN, DOWN_RIGHT, RIGHT, and Throw Face Up Right for UP, UP_RIGHT, RIGHT, but again, RIGHT is in both.
Wait, perhaps better to assign based on the primary direction.
For example:
If facing DOWN, use Throw Face Down Right

If facing UP, use Throw Face Up Right

If facing RIGHT, use Throw Face Down Right (or Up Right)

If facing LEFT, use flipped Throw Face Down Left (or Up Left)

Wait, but for diagonal directions, it's clearer: DOWN_RIGHT uses Throw Face Down Right, UP_RIGHT uses Throw Face Up Right, and for DOWN_LEFT and UP_LEFT, use flipped versions.
For the cardinal directions, since there's no specific animation, I can choose to use one of the diagonal animations. For instance, for RIGHT, I can use Throw Face Down Right, for LEFT use flipped Throw Face Down Left, for DOWN use Throw Face Down Right, for UP use Throw Face Up Right.
Alternatively, perhaps the animation is such that it can be used for multiple directions.
But to keep it simple, let's say:
For DOWN, DOWN_RIGHT, RIGHT: use Throw Face Down Right

For UP, UP_RIGHT, RIGHT: wait, RIGHT is in both, but since RIGHT is cardinal, perhaps:

Actually, maybe:
For DOWN_RIGHT: use Throw Face Down Right

For UP_RIGHT: use Throw Face Up Right

For DOWN_LEFT: use flipped Throw Face Down Right

For UP_LEFT: use flipped Throw Face Up Right

For RIGHT: use Throw Face Down Right (or a specific frame)

For LEFT: use flipped Throw Face Down Left

For DOWN: use Throw Face Down Right (or a specific frame)

For UP: use Throw Face Up Right (or a specific frame)

But since the animation is likely showing the player throwing in a diagonal direction, using it for cardinal directions might look okay, especially if the snowball is thrown in the cardinal direction.
Alternatively, perhaps I can extract specific frames from the animation that look like throwing in the cardinal direction.
For example, maybe in the Throw Face Down Right animation, there are frames where the player is throwing more downward or more to the right.
But that might be complicated. Since the problem is to implement the throwing action with the provided sprites, I'll assume that for cardinal directions, we can use the diagonal animation that is closest.
So, let's define the mapping:
If facing DOWN, use Throw Face Down Right animation, but perhaps adjust the snowball direction accordingly.

Wait, actually, since the snowball will be thrown in the direction the player is facing, regardless of the animation, I can use the animation that is closest to the facing direction.
For instance:
If facing DOWN, use Throw Face Down Right animation, but throw the snowball downward.

Similarly for other directions.

Alternatively, to make it look better, perhaps I can use the Throw Face Down Right animation for DOWN, DOWN_RIGHT, and RIGHT, and use Throw Face Up Right for UP, UP_RIGHT, and perhaps adjust for LEFT and DOWN_LEFT by flipping.
Wait, let's try to formalize this.
Let's say:
For facing DOWN, DOWN_RIGHT, RIGHT: use Throw Face Down Right animation

For facing UP, UP_RIGHT: use Throw Face Up Right animation

For facing LEFT, DOWN_LEFT: use flipped Throw Face Down Left (which is flipped Throw Face Down Right)

For facing UP_LEFT: use flipped Throw Face Up Left (which is flipped Throw Face Up Right)

Wait, actually, since LEFT and DOWN_LEFT are opposite to RIGHT and DOWN_RIGHT, I can use the flipped version.
Similarly for UP_LEFT.
So, more precisely:
For DOWN_RIGHT: use Throw Face Down Right

For UP_RIGHT: use Throw Face Up Right

For DOWN_LEFT: use flipped Throw Face Down Right

For UP_LEFT: use flipped Throw Face Up Right

Then, for cardinal directions:
For RIGHT: since it's between DOWN_RIGHT and UP_RIGHT, I can choose one, say use Throw Face Down Right

For LEFT: use flipped Throw Face Down Right

For DOWN: use Throw Face Down Right

For UP: use Throw Face Up Right

This way, the animation might not perfectly match the throwing direction for cardinal directions, but it's a compromise given the available assets.
Alternatively, if there's a frame in the animation where the player is throwing more straight, I could use that frame for cardinal directions, but since it's an animation sequence, it's probably designed to be played in full.
For simplicity, I'll proceed with using the diagonal animations for the corresponding cardinal directions as above.
Now, to implement this, I need to:
Detect when the player presses "O" to initiate the snowball throwing action.

Determine the player's current facing direction.

Based on the facing direction, select the appropriate animation (Throw Face Down Right or Throw Face Up Right, and whether to flip it).

Play the animation sequence.

At a certain point in the animation (e.g., when the snowball is released), create a snowball projectile that moves in the direction the player was facing.

Handle the snowball's movement and collision.

First, I need to integrate this into the player's code. Assuming the player object is obj_player, I need to add logic to handle the snowball throwing.
But wait, looking back at the provided code, there are multiple player objects, like obj_player, obj_player_icetruck, obj_player_tube, etc. So, probably, the snowball throwing should be available for the default player, obj_player, and perhaps for other skins as well, but for now, I'll focus on obj_player.
In obj_player's Step event, I need to check if the "O" key is pressed, and if so, initiate the throwing action.
But I need to make sure that the player is not already performing another action that might conflict with throwing.
Looking at the provided code, in obj_player's Step event, there is logic for movement, collision, and also for special actions when "P" is pressed.
Specifically, there's code like:
if (keyboard_check_pressed(ord("P"))) {

// Check for equipped items and set sprites

...

}
So, similarly, I can add a check for "O" key press to initiate the snowball throwing.
But first, I need to define the animation frames for each direction.
Since the animation is 28 frames long, I need to play 28 frames when throwing.
Also, I need to determine when to spawn the snowball projectile. Probably, at a specific frame in the animation, say, frame 15 or so, when the player releases the snowball.
For now, let's assume that the snowball is thrown at frame 15 of the animation.
So, in the player's code, when "O" is pressed, I can set a variable like is_throwing = true, and set the current animation to the throwing animation based on the facing direction.
Then, in the Step event, if is_throwing is true, increment the animation frame, and when it reaches frame 15, create the snowball projectile, and when it reaches frame 28, reset to idle.
Also, during the throwing animation, the player should not be able to move or perform other actions.
So, I need to add some state management.
Let me outline the steps:
In obj_player's Create event, add variables:

is_throwing = false;

throw_frame = 0;

throw_direction = -1; // to store the direction when throwing started

throw_animation_length = 28;

snowball_release_frame = 15;

In the Step event, before the movement code, check if !is_throwing:

if (!is_throwing) {

// Existing movement code

...

// Check for "O" key press

if (keyboard_check_pressed(ord("O"))) {

    is_throwing = true;

    throw_frame = 0;

    throw_direction = face; // store current facing direction

    // Optionally, set sprite_index to the throwing sprite, but since we're using draw_sprite_part, we might handle it in Draw event

}

} else {

// Throwing animation

throw_frame += 1;

if (throw_frame == snowball_release_frame) {

    // Create snowball projectile

    var snowball = instance_create_layer(x, y, "Instances", obj_snowball);

    snowball.direction = get_throw_direction(throw_direction);

    snowball.speed = 5; // adjust as needed

}

if (throw_frame >= throw_animation_length) {

    is_throwing = false;

    throw_frame = 0;

    // Reset to idle or walking state

}

}
Wait, actually, since the player might be moving, but during throwing, we probably want to stop movement.
So, perhaps, when is_throwing is true, set xspd and yspd to 0.
Alternatively, I can add a state variable, like state = "idle", "walking", "throwing", etc.
But to keep it simple, I'll just use the is_throwing flag.
So, in the movement code, I can add:
if (!is_throwing) {

// Get input

var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);

// etc.

xspd = (right_key - left_key) * move_spd;

yspd = (down_key - up_key) * move_spd;

// Update face direction

if (xspd != 0 || yspd != 0) {

    // set face

}

} else {

xspd = 0;

yspd = 0;

}
// Then, handle collision and movement
if (place_meeting(x + xspd, y, obj_wall)) xspd = 0;
if (place_meeting(x, y + yspd, obj_wall)) yspd = 0;
x += xspd;
y += yspd;
// Then, handle animation
if (is_throwing) {

// Play throwing animation

// But since we're using draw_sprite_part, we need to determine which part to draw based on throw_frame and throw_direction

} else {

// Existing animation code

}
Wait, actually, in the provided code, the player's drawing is handled in the Draw event using draw_sprite_part_ext for the body and colour layers.
So, similarly, for the throwing animation, I need to draw the appropriate part from spr_throwsnowball_body and spr_throwsnowball_colour.
First, I need to define the frame sequences for each direction.
Since for Throw Face Down Right, it's frames 0 to 27, and for Throw Face Up Right, it's frames 28 to 55, I can map the player's facing direction to the appropriate animation.
Specifically:
For throw_direction == DOWN_RIGHT: use frames 0 to 27

For throw_direction == UP_RIGHT: use frames 28 to 55

For throw_direction == DOWN_LEFT: use frames 0 to 27, but flipped horizontally

For throw_direction == UP_LEFT: use frames 28 to 55, flipped horizontally

For throw_direction == RIGHT: use frames 0 to 27 (or perhaps a specific subset)

For throw_direction == LEFT: use frames 0 to 27, flipped

For throw_direction == DOWN: use frames 0 to 27

For throw_direction == UP: use frames 28 to 55

Wait, but to make it consistent, perhaps I can define a base animation for each direction.
Alternatively, since the animation is for diagonal directions, for cardinal directions, I can use the same animation but adjust the snowball direction.
For simplicity, let's say:
If throw_direction is DOWN, DOWN_RIGHT, RIGHT, DOWN_LEFT: use Throw Face Down Right animation (frames 0 to 27), and flip if necessary

If throw_direction is UP, UP_RIGHT, UP_LEFT: use Throw Face Up Right animation (frames 28 to 55), and flip if necessary

Wait, specifically:
For DOWN_RIGHT: use frames 0 to 27, no flip

For UP_RIGHT: use frames 28 to 55, no flip

For DOWN_LEFT: use frames 0 to 27, flipped horizontally

For UP_LEFT: use frames 28 to 55, flipped horizontally

For RIGHT: use frames 0 to 27, no flip (assuming it's similar to DOWN_RIGHT)

For LEFT: use frames 0 to 27, flipped

For DOWN: use frames 0 to 27, no flip

For UP: use frames 28 to 55, no flip

Yes, that seems reasonable.
So, in code, I can determine the base frame offset and whether to flip based on the throw_direction.
Let's define a function to get the frame offset and flip for a given direction.
For example:
function get_throw_animation_data(direction) {

var frame_offset = 0;

var flip = false;

switch (direction) {

    case DOWN:

    case DOWN_RIGHT:

    case RIGHT:

        frame_offset = 0; // frames 0 to 27

        flip = false;

        break;

    case UP:

    case UP_RIGHT:

        frame_offset = 28; // frames 28 to 55

        flip = false;

        break;

    case DOWN_LEFT:

    case LEFT:

        frame_offset = 0;

        flip = true;

        break;

    case UP_LEFT:

        frame_offset = 28;

        flip = true;

        break;

}

return [frame_offset, flip];

}
Then, in the Draw event, if is_throwing, I can calculate the current frame index as frame_offset + throw_frame, and draw the corresponding part from the sprite sheet, with flipping if necessary.
Wait, actually, since the sprite sheet is arranged in a grid, I need to map the frame index to the [x, y] position in the sprite sheet.
Since it's an 8x7 grid, with each frame 24x24, I can calculate the x and y positions as:
var col = frame_index mod 8;
var row = floor(frame_index / 8);
var spr_x = col * 24;
var spr_y = row * 24;
Then, draw_sprite_part_ext with spr_x, spr_y, 24, 24, and apply flipping if needed.
For flipping, I can set the xscale to -1 if flip is true.
But since the player is drawn at (x, y), which is the center, I need to adjust the drawing position when flipping.
Wait, actually, in GML, when you set xscale to -1, it flips the sprite horizontally around its origin. So, if the origin is at the center, it should flip correctly.
In the provided code, the player's origin seems to be at the top-left, since in the Draw event, it's drawing at (x - 12, y - 12), assuming the sprite is 24x24.
Wait, let's check the existing Draw event code.
In obj_player's Draw event:
var flip = (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) ? -1 : 1;
var spr_x = sprite_data[face][0];
var spr_y = sprite_data[face][1];
var draw_x = x - 12 * flip;
var draw_y = y - 12;
draw_sprite_part_ext(spr_player_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);
draw_sprite_part_ext(spr_player_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);
So, yes, for left-facing directions, it sets flip = -1, and adjusts draw_x to x - 12 * flip, which for flip=-1 becomes x + 12, so the sprite is drawn to the right of x, but since xscale=-1, it flips it to the left.
Wait, actually, with xscale=-1, the sprite is flipped horizontally, and since the origin is at (0,0) of the sprite, when drawn at (draw_x, draw_y), it will flip around (draw_x, draw_y).
So, for example, if flip=1, draw_x = x - 12, so the left edge is at x - 12, and the sprite extends to x + 12.
If flip=-1, draw_x = x + 12, and with xscale=-1, the sprite will be flipped, so it extends from x + 12 to x - 12, effectively mirroring it.
So, this setup assumes that the sprite's origin is at the left side, and when flipped, it mirrors around the vertical axis at x.
But actually, since the player is 24x24, and x,y is likely the center, but in the code, it's drawing at x - 12, y - 12, so the top-left is at (x - 12, y - 12), meaning the origin is at the top-left.
Wait, in GML, the default origin for sprites is (0,0), top-left, unless changed.
So, in this case, when flip=1, it's drawn with top-left at (x - 12, y - 12), so the center of the sprite is at (x, y).
When flip=-1, it's drawn with top-left at (x + 12, y - 12), and xscale=-1, so it flips horizontally around (x + 12, y - 12), which means the sprite will extend to the left, and the center will still be at (x, y).
Wait, let's confirm: with xscale=-1, the sprite is flipped, so the pixel that was at spr_x becomes at spr_x + 24, but since it's drawn at draw_x, which is x + 12, and xscale=-1, the pixel at spr_x will be drawn at draw_x + 24, but wait, actually, with xscale=-1, the drawing starts from draw_x and goes leftward.
More precisely, the pixel at (spr_x + u, spr_y + v) in the sprite is drawn at (draw_x - u * xscale, draw_y + v), since xscale=-1.
Wait, in GML, for draw_sprite_ext, the formula is that the pixel at (u,v) in the sprite is drawn at (x + u * xscale, y + v * yscale), where (x,y) is the position.
Wait, actually, for draw_sprite_part_ext, it's similar: it draws the part from left, top, width, height at position (x, y), with scaling.
So, for draw_sprite_part_ext(sprite, subimg, left, top, width, height, x, y, xscale, yscale, colour, alpha), the part from (left, top) to (left + width, top + height) is drawn with top-left at (x, y), and scaled by xscale and yscale.
So, if xscale=-1, it will flip the sprite horizontally, meaning that the left edge becomes the right edge, and vice versa.
So, in the code, when flip=-1, draw_x = x + 12, so the top-left of the flipped sprite is at x + 12, and since it's flipped, the actual visual left edge will be at x + 12 - 24 = x - 12, so the sprite extends from x - 12 to x + 12, same as when flip=1.
Thus, the center remains at x, which is good.
So, for the throwing animation, I can use a similar approach.
I can define the spr_x and spr_y based on the current throw_frame, and apply flipping based on the direction.
Specifically, first, determine the frame_index based on the throw_direction and throw_frame.
For example:
if (is_throwing) {

var animation_data = get_throw_animation_data(throw_direction);

var frame_offset = animation_data[0];

var flip = animation_data[1] ? -1 : 1;

var frame_index = frame_offset + throw_frame;

var col = frame_index mod 8;

var row = floor(frame_index / 8);

var spr_x = col * 24;

var spr_y = row * 24;

var draw_x = x - 12 * flip;

var draw_y = y - 12;

// Draw body

draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);

// Draw colour

draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);

} else {

// Existing drawing code

}
Wait, almost, but in the existing code, it's using sprite_data[face][0] and [1], which are likely predefined for each direction.
But for the throwing animation, since it's a sequence, I need to calculate spr_x and spr_y based on the frame_index.
Also, note that in the provided code, for walking animations, it might be using image_index or something, but since for throwing, it's a fixed sequence, I can handle it separately.
Additionally, I need to make sure that during throwing, the animation plays at the correct speed. For now, since throw_frame increments each step, it will play at 60 FPS if room_speed is 60, which might be too fast. I might need to control the animation speed.
For example, I can have a throw_anim_speed variable, say 0.5, meaning 0.5 frames per step, so throw_frame += throw_anim_speed, and use floor(throw_frame) to get the current frame.
But for simplicity, let's assume it's 1 frame per step for now.
Also, I need to define the get_throw_animation_data function as above.
Now, regarding the snowball projectile, I need to create an object obj_snowball.
Let's define it.
First, create a new object obj_snowball.
In its Create event:
direction = 0; // will be set when created
speed = 5;
image_speed = 0; // if it has animation
// Assuming it has a sprite, say spr_snowball
Then, in its Step event:
// Move based on direction and speed
x += lengthdir_x(speed, direction);
y += lengthdir_y(speed, direction);
// Check for collision with walls or out of bounds
if (place_meeting(x, y, obj_wall) || x < 0 || x > room_width || y < 0 || y > room_height) {

instance_destroy();

}
Also, perhaps add collision with other objects, like NPCs or enemies, but for now, let's keep it simple.
In the Draw event:
draw_self();
Assuming it has a sprite assigned.
Now, when creating the snowball in the player's Step event, I need to set its direction based on the player's facing direction.
So, I need a function to convert the player's face direction to an angle.
For example:
function get_throw_direction(face) {

switch (face) {

    case RIGHT: return 0;

    case UP_RIGHT: return 45;

    case UP: return 90;

    case UP_LEFT: return 135;

    case LEFT: return 180;

    case DOWN_LEFT: return 225;

    case DOWN: return 270;

    case DOWN_RIGHT: return 315;

}

}
Then, in the player's Step event, when throw_frame == snowball_release_frame, create the snowball and set its direction to get_throw_direction(throw_direction).
Also, I might want to adjust the starting position of the snowball, perhaps offset it based on the direction, so it appears to be thrown from the player's hand.
For example, I can add an offset:
var offset_x = 0;
var offset_y = 0;
switch (throw_direction) {

case RIGHT: offset_x = 12; break;

case LEFT: offset_x = -12; break;

case UP: offset_y = -12; break;

case DOWN: offset_y = 12; break;

// For diagonals, perhaps a combination

case UP_RIGHT: offset_x = 8; offset_y = -8; break;

case UP_LEFT: offset_x = -8; offset_y = -8; break;

case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;

case DOWN_LEFT: offset_x = -8; offset_y = 8; break;

}
Then, create the snowball at x + offset_x, y + offset_y.
This way, it appears to be thrown from the player's hand position.
I can adjust the offsets as needed.
Additionally, I might want to ensure that the snowball is created only once during the throwing animation, so I can add a flag like has_thrown_snowball = false in the Create event, and set it to true when the snowball is created, and reset it when is_throwing becomes false.
But since throw_frame increments each step, and I check if throw_frame == snowball_release_frame, it should only trigger once per throw.
Still, to be safe, I can add a condition.
Wait, actually, since throw_frame is incremented each step, and snowball_release_frame is a specific value, say 15, it will be equal to 15 only once during the animation, so it's fine.
Now, to summarize the changes:
In obj_player's Create event, add:

is_throwing = false;
throw_frame = 0;
throw_direction = -1;
throw_animation_length = 28;
snowball_release_frame = 15;
In obj_player's Step event, before the movement code, add:

if (!is_throwing) {

// Existing input and movement code

...

if (keyboard_check_pressed(ord("O"))) {

    is_throwing = true;

    throw_frame = 0;

    throw_direction = face;

}

} else {

// Stop movement

xspd = 0;

yspd = 0;

// Advance animation

throw_frame += 1;

if (throw_frame == snowball_release_frame) {

    // Create snowball

    var offset_x = 0;

    var offset_y = 0;

    switch (throw_direction) {

        case RIGHT: offset_x = 12; break;

        case LEFT: offset_x = -12; break;

        case UP: offset_y = -12; break;

        case DOWN: offset_y = 12; break;

        case UP_RIGHT: offset_x = 8; offset_y = -8; break;

        case UP_LEFT: offset_x = -8; offset_y = -8; break;

        case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;

        case DOWN_LEFT: offset_x = -8; offset_y = 8; break;

    }

    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);

    snowball.direction = get_throw_direction(throw_direction);

    snowball.speed = 5;

}

if (throw_frame >= throw_animation_length) {

    is_throwing = false;

    throw_frame = 0;

}

}
In obj_player's Draw event, modify to:

if (is_throwing) {

var animation_data = get_throw_animation_data(throw_direction);

var frame_offset = animation_data[0];

var flip = animation_data[1] ? -1 : 1;

var frame_index = frame_offset + throw_frame;

var col = frame_index mod 8;

var row = floor(frame_index / 8);

var spr_x = col * 24;

var spr_y = row * 24;

var draw_x = x - 12 * flip;

var draw_y = y - 12;

draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);

draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);

} else {

// Existing drawing code

var flip = (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) ? -1 : 1;

var spr_x = sprite_data[face][0];

var spr_y = sprite_data[face][1];

var draw_x = x - 12 * flip;

var draw_y = y - 12;

draw_sprite_part_ext(spr_player_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);

draw_sprite_part_ext(spr_player_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);

// Also, draw equipped items if any

...

}
Define the get_throw_animation_data function in a script:

function get_throw_animation_data(direction) {

var frame_offset = 0;

var flip = false;

switch (direction) {

    case DOWN:

    case DOWN_RIGHT:

    case RIGHT:

        frame_offset = 0; // frames 0 to 27

        flip = false;

        break;

    case UP:

    case UP_RIGHT:

        frame_offset = 28; // frames 28 to 55

        flip = false;

        break;

    case DOWN_LEFT:

    case LEFT:

        frame_offset = 0;

        flip = true;

        break;

    case UP_LEFT:

        frame_offset = 28;

        flip = true;

        break;

}

return [frame_offset, flip];

}
Define the get_throw_direction function:

function get_throw_direction(face) {

switch (face) {

    case RIGHT: return 0;

    case UP_RIGHT: return 45;

    case UP: return 90;

    case UP_LEFT: return 135;

    case LEFT: return 180;

    case DOWN_LEFT: return 225;

    case DOWN: return 270;

    case DOWN_RIGHT: return 315;

    default: return 0;

}

}
Create obj_snowball with:

Sprite: spr_snowball (you need to create this)

Create event:

direction = 0;
speed = 0;
Step event:

x += lengthdir_x(speed, direction);
y += lengthdir_y(speed, direction);
if (place_meeting(x, y, obj_wall) || x < 0 || x > room_width || y < 0 || y > room_height) {

instance_destroy();

}
Draw event:

draw_self();
Also, you might want to add collision with other objects, but for now, this should suffice.
Finally, ensure that the throwing action doesn't interfere with other actions, like the "P" key special actions. For example, if the player is throwing, maybe disable other actions until the throwing is complete.
But in the current setup, since is_throwing is true, the player won't respond to movement inputs, so it should be fine.
Also, you might want to add a cooldown for throwing snowballs, so the player can't spam them. For example, after throwing, set a timer before they can throw again.
But for now, this should implement the basic functionality.
Let me know if you need further clarification or additional features.

Below are clear and concise instructions to implement the "Snowball" special action in your GameMaker Studio 2 project using the provided sprites and requirements. I’ve analyzed your existing codebase and tailored the solution to integrate seamlessly with obj_player, ensuring consistency with your game’s mechanics. The solution includes sprite frame data, animation handling, and a snowball projectile object, with code ready to copy and paste.
Step 1: Understanding the Sprite Layout
Your sprites spr_throwsnowball_body and spr_throwsnowball_colour are 192x168 pixels, divided into an 8x7 grid of 24x24 pixel frames (8 columns, 7 rows, totaling 56 frames). You’ve provided animations for two directions, each with 28 frames:
Throw Face Down Right: Frames 0 to 27 in row-major order (left to right, top to bottom).

Throw Face Up Right: Frames 28 to 55 in row-major order.

Since each animation uses exactly 28 frames (half the sprite sheet), I’ll assume:
Throw Face Down Right occupies frames 0–27 (rows 0–3, with 4 frames in row 3).

Throw Face Up Right occupies frames 28–55 (rows 3–6, with 4 frames in row 6).

For ** Throw Face Down Left** and Throw Face Up Left, we’ll flip the respective animations horizontally in code, as you don’t have separate sprites for these directions.
Completing Frame Data
Using row-major order (column 0 to 7, row 0 to 6), each frame’s top-left corner is calculated as (col * 24, row * 24):
Throw Face Down Right (frames 0–27):
Frame 1: (0, 0) to (23, 23) — index 0

Frame 2: (24, 0) to (47, 23) — index 1

Frame 3: (48, 0) to (71, 23) — index 2

Frame 4: (72, 0) to (95, 23) — index 3

Frame 5: (96, 0) to (119, 23) — index 4

Frame 6: (120, 0) to (143, 23) — index 5

Frame 7: (144, 0) to (167, 23) — index 6

Frame 8: (168, 0) to (191, 23) — index 7

Frame 9: (0, 24) to (23, 47) — index 8

Frame 10–15: (24, 24) to (143, 47) — indices 9–14

Frame 16: (168, 24) to (191, 47) — index 15

Frame 17–24: (0, 48) to (168, 48) — indices 16–23

Frame 25–27: (0, 72) to (48, 72) — indices 24–26

Frame 28: (72, 72) to (95, 95) — index 27

Throw Face Up Right (frames 28–55):
Frame 1: (96, 72) to (119, 95) — index 28

Frame 2: (120, 72) to (143, 95) — index 29

Frame 3: (144, 72) to (167, 95) — index 30

Frame 4: (168, 72) to (191, 95) — index 31

Frame 5: (0, 96) to (23, 119) — index 32

Frame 6–12: (24, 96) to (168, 96) — indices 33–39

Frame 13: (0, 120) to (23, 143) — index 40

Frame 14–20: (24, 120) to (168, 120) — indices 41–47

Frame 21–24: (0, 144) to (72, 144) — indices 48–51

Frame 25: (0, 144) to (23, 167) — index 48 (corrected to row 6)

Frame 25–28: (0, 144) to (72, 144) — indices 48–51 (adjusting last frames)

Frame 28: (168, 144) to (191, 167) — index 55

This matches your partial data and fills in the gaps logically.
Step 2: Implementing in obj_player
We’ll modify obj_player to handle the snowball throw action when "O" is pressed, play the animation, and spawn a projectile. Here’s how:
Create Event
Add variables to manage the throwing state.
gml

// In obj_player Create event, append:
is_throwing = false;
throw_frame = 0;
throw_direction = -1;
throw_animation_length = 28; // 28 frames per animation
snowball_release_frame = 15; // Snowball spawns mid-animation

Step Event
Add logic to initiate and control the throwing action. Insert this before the movement code.
gml

// In obj_player Step event, before movement code:
if (!is_throwing) {
    // Existing movement code remains below
    var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
    // ... (rest of your input code)

    if (keyboard_check_pressed(ord("O"))) {
        is_throwing = true;
        throw_frame = 0;
        throw_direction = face; // Capture current facing direction
        xspd = 0; // Stop movement during throw
        yspd = 0;
    }
} else {
    // Handle throwing animation
    throw_frame += 1;
    if (throw_frame == snowball_release_frame) {
        // Spawn snowball with offset
        var offset_x = 0;
        var offset_y = 0;
        switch (throw_direction) {
            case RIGHT: offset_x = 12; break;
            case LEFT: offset_x = -12; break;
            case UP: offset_y = -12; break;
            case DOWN: offset_y = 12; break;
            case UP_RIGHT: offset_x = 8; offset_y = -8; break;
            case UP_LEFT: offset_x = -8; offset_y = -8; break;
            case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
            case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
        }
        var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
        snowball.direction = get_throw_direction(throw_direction);
        snowball.speed = 5;
    }
    if (throw_frame >= throw_animation_length) {
        is_throwing = false;
        throw_frame = 0;
    }
    xspd = 0; // Prevent movement during animation
    yspd = 0;
}

// Existing movement and collision code follows...

Draw Event
Update to draw the throwing animation when active, flipping for left-facing directions.
gml

// Replace obj_player Draw event with:
if (is_throwing) {
    var animation_data = get_throw_animation_data(throw_direction);
    var frame_offset = animation_data[0];
    var flip = animation_data[1] ? -1 : 1;
    var frame_index = frame_offset + throw_frame;
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;
    var draw_x = x - 12 * flip;
    var draw_y = y - 12;

    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);
} else {
    var flip = (face == LEFT || face == UP_LEFT || face == DOWN_LEFT) ? -1 : 1;
    var spr_x = sprite_data[face][0];
    var spr_y = sprite_data[face][1];
    var draw_x = x - 12 * flip;
    var draw_y = y - 12;

    draw_sprite_part_ext(spr_player_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);
    draw_sprite_part_ext(spr_player_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);
}

Step 3: Add Helper Functions
Create these scripts to determine animation data and throw direction.
get_throw_animation_data.gml
Maps facing direction to animation frames and flip state.
gml

function get_throw_animation_data(direction) {
    var frame_offset = 0;
    var flip = false;
    switch (direction) {
        case DOWN:
        case DOWN_RIGHT:
        case RIGHT:
            frame_offset = 0; // Frames 0–27
            flip = false;
            break;
        case UP:
        case UP_RIGHT:
            frame_offset = 28; // Frames 28–55
            flip = false;
            break;
        case DOWN_LEFT:
        case LEFT:
            frame_offset = 0;
            flip = true;
            break;
        case UP_LEFT:
            frame_offset = 28;
            flip = true;
            break;
    }
    return [frame_offset, flip];
}

get_throw_direction.gml
Converts facing direction to an angle for the projectile.
gml

function get_throw_direction(face) {
    switch (face) {
        case RIGHT: return 0;
        case UP_RIGHT: return 45;
        case UP: return 90;
        case UP_LEFT: return 135;
        case LEFT: return 180;
        case DOWN_LEFT: return 225;
        case DOWN: return 270;
        case DOWN_RIGHT: return 315;
        default: return 0;
    }
}

Step 4: Create obj_snowball
Create a new object obj_snowball for the projectile.
Create Event
gml

direction = 0; // Set by player
speed = 0;     // Set by player
sprite_index = spr_snowball; // Placeholder; create a 16x16 sprite

Step Event
gml

x += lengthdir_x(speed, direction);
y += lengthdir_y(speed, direction);
if (place_meeting(x, y, obj_wall) || x < 0 || x > room_width || y < 0 || y > room_height) {
    instance_destroy();
}

Draw Event
gml

draw_self();

Note: Since you don’t have spr_snowball, create a simple 16x16 white circle sprite as a placeholder. Adjust size or add animation later.
Step 5: Integration and Testing
Add to obj_player:
Open obj_player in the IDE.

Append the Create event code.

Insert the Step event code before your movement logic.

Replace the Draw event with the provided code.

Create Scripts:
Add get_throw_animation_data.gml and get_throw_direction.gml as new scripts under the Scripts folder.

Create obj_snowball:
Create a new object named obj_snowball.

Add the Create, Step, and Draw events with the code above.

Assign a placeholder sprite (e.g., a 16x16 white circle).

Test:
Run the game, press "O" while facing different directions, and verify:
The correct animation plays (Down Right or Up Right, flipped for Left).

The snowball spawns mid-animation and moves in the facing direction.

The player stops moving during the throw and resumes after.

Additional Suggestions
Animation Speed: If 1 frame per step (60 FPS) is too fast, add throw_anim_speed = 0.5; in Create and change throw_frame += 1 to throw_frame += throw_anim_speed, using floor(throw_frame) in the Draw event.

Cooldown: Add a throw_cooldown variable (e.g., 30 frames) to prevent spamming, checking it before setting is_throwing = true.

Sound: Add audio_play_sound(snd_throw, 10, false) at the snowball release frame (create snd_throw as needed).

Let me know if you need help refining this further!

Ive updated my project and got this error after pressing O : Setting scheduler resolution to 1
DirectX11: Using hardware device
Collision Event time(microsecs)=11
Variable_Global_Init()
PrepareGame()
Audio_Init()
Audio group 0 -> Loaded
Attempting to set gamepadcount to 12
Game_Prepare()
Script_Prepare() 
TimeLine_Prepare() 
Object_Prepare() 
Room_Prepare() 
Finished PrepareGame() 
Run_Start
Done g_EffectsManager.Init()
Done RenderStateManager
CreateColPairs took 0.000000s 3 usecs for 101 object types obj_col_numb=0 physobjcount=0 resizes 0 final size 0
Done ObjectLists
Done Extension_Initialize
About to startroom
Total memory used = 9474190 (0x0090908e) bytes 9.04MB
Free memory = 6198696 (0x005e95a8) bytes 5.91MB
Peak memory used = 12354146 (0x00bc8262) bytes 11.78MB
**********************************.
Entering main loop.
**********************************.
DEBUG: New global camera created. ID: 161
obj_player: Initialized. Driving state: 0
Restored player color: 3149266
obj_controller Create event executed
DEBUG: global.item_index_map initialized in obj_initializer.
DEBUG: global.item_object_map initialized in obj_initializer.
DEBUG: obj_initializer Create Event executed.
Saved state for obj_pickup_item at (32, 0)
Saved state for obj_dropped_item at (0, 64)
Saved state for room: rm_init
Saved state for room: rm_init
Saved state for obj_pickup_item at (32, 0)
Saved state for obj_dropped_item at (0, 64)
Saved state for room: rm_init
Saved state for room: rm_init
No saved state found for room: rm_welcome_room
DEBUG: Room Start Event triggered in obj_controller.
obj_player: Initialized. Driving state: 0
DEBUG: Player recreated at (170, 154)
DEBUG: Camera now follows player.
DEBUG: UI layer created.
DEBUG: Inventory hidden in pause menu.
DEBUG: Room Start Event triggered in obj_controller.
UI layer already exists.
Pause menu closed.
DEBUG: Room Start Event completed. Current skin: player
DEBUG: Player instance ID: ref instance 100578
DEBUG: Room Start - Camera setup delayed by 2 frames.
DEBUG: Reattached to existing global camera. ID: 161
No saved state found for room: rm_welcome_room
DEBUG: Room Start Event triggered in obj_controller.
DEBUG: Camera now follows player.
DEBUG: UI layer already exists.
DEBUG: Inventory hidden in pause menu.
DEBUG: Room Start Event triggered in obj_controller.
UI layer already exists.
Pause menu closed.
DEBUG: Room Start Event completed. Current skin: player
DEBUG: Player instance ID: ref instance 100578
DEBUG: Camera attached to player at (170, 154)
DEBUG: Resetting repair flag...
ERROR!!! :: ############################################################################################
ERROR in action number 1
of  Step Event0 for object obj_player:
local variable right_key(100388) not set before reading it.
 at gml_Object_obj_player_Step_0 (line 213) -         xspd = (right_key - left_key) * move_spd;
############################################################################################
gml_Object_obj_player_Step_0 (line 213) could you better implement the throwing snowball action into the special actions system along with dancing and waving?
obj_player
Create:
// Core variables
xspd = 0;
yspd = 0;
move_spd = 1;
state = "walking";
if (!variable_global_exists("player_color")) { global.player_color = c_white; }
if (variable_global_exists("last_player_color")) { global.player_color = global.last_player_color; } else { global.player_color = c_white; }// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;// Driving variables
driving = false;
original_sprite = sprite_index;// Snowball throw variables
is_throwing = false;
throw_frame = 0;
throw_direction = -1;
throw_animation_length = 28; // 28 frames per animation
snowball_release_frame = 15; // Snowball spawns mid-animation// Set direction and sprites
face = DOWN;
//init_sprites(spr_player_right, spr_player_up, spr_player_left, spr_player_down, spr_player_up_right, spr_player_up_left, spr_player_down_right, spr_player_down_left);
sprite_body = spr_player_body; // Default sprite
sprite_color = spr_player_colour;
mask_index = spr_player_down;// Frame data for walking (192x72 sprite sheet: 3 frames per direction)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];// Special actions system
action_state = "none";  // "none", "dance", "wave", "sit", "jackhammer", "snowshovel"
action_timer = 0;
action_duration = 0;// Frame data and sprite maps for special actions
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();// Sit (8 frames, 24x24, y=72 in spr_player_body)
ds_map_add(action_frame_data, "sit", [
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24],
    [96, 72, 24, 24], [120, 72, 24, 24], [144, 72, 24, 24], [168, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "sit", spr_player_body);
ds_map_add(action_sprite_color, "sit", spr_player_colour);
ds_map_add(action_anim_speed, "sit", 0); // Static// Wave (16 frames, 24x24, y=96-120 in spr_player_body)
ds_map_add(action_frame_data, "wave", [
    [0, 96, 24, 24], [24, 96, 24, 24], [48, 96, 24, 24], [72, 96, 24, 24],
    [96, 96, 24, 24], [120, 96, 24, 24], [144, 96, 24, 24], [168, 96, 24, 24],
    [0, 120, 24, 24], [24, 120, 24, 24], [48, 120, 24, 24], [72, 120, 24, 24],
    [96, 120, 24, 24], [120, 120, 24, 24], [144, 120, 24, 24], [168, 120, 24, 24]
]);
ds_map_add(action_sprite_body, "wave", spr_player_body);
ds_map_add(action_sprite_color, "wave", spr_player_colour);
ds_map_add(action_anim_speed, "wave", 0.2); // ~5 FPS// Dance (56 frames, 24x24, y=144-288 in spr_player_body)
ds_map_add(action_frame_data, "dance", [
    [0, 144, 24, 24], [24, 144, 24, 24], [48, 144, 24, 24], [72, 144, 24, 24], [96, 144, 24, 24], [120, 144, 24, 24], [144, 144, 24, 24], [168, 144, 24, 24],
    [0, 168, 24, 24], [24, 168, 24, 24], [48, 168, 24, 24], [72, 168, 24, 24], [96, 168, 24, 24], [120, 168, 24, 24], [144, 168, 24, 24], [168, 168, 24, 24],
    [0, 192, 24, 24], [24, 192, 24, 24], [48, 192, 24, 24], [72, 192, 24, 24], [96, 192, 24, 24], [120, 192, 24, 24], [144, 192, 24, 24], [168, 192, 24, 24],
    [0, 216, 24, 24], [24, 216, 24, 24], [48, 216, 24, 24], [72, 216, 24, 24], [96, 216, 24, 24], [120, 216, 24, 24], [144, 216, 24, 24], [168, 216, 24, 24],
    [0, 240, 24, 24], [24, 240, 24, 24], [48, 240, 24, 24], [72, 240, 24, 24], [96, 240, 24, 24], [120, 240, 24, 24], [144, 240, 24, 24], [168, 240, 24, 24],
    [0, 264, 24, 24], [24, 264, 24, 24], [48, 264, 24, 24], [72, 264, 24, 24], [96, 264, 24, 24], [120, 264, 24, 24], [144, 264, 24, 24], [168, 264, 24, 24],
    [0, 288, 24, 24], [24, 288, 24, 24], [48, 288, 24, 24], [72, 288, 24, 24], [96, 288, 24, 24], [120, 288, 24, 24], [144, 288, 24, 24], [168, 288, 24, 24]
]);
ds_map_add(action_sprite_body, "dance", spr_player_body);
ds_map_add(action_sprite_color, "dance", spr_player_colour);
ds_map_add(action_anim_speed, "dance", 0.25); // ~4 FPS// Jackhammer (50 frames, 32x24, spr_player_body_jackhammer)
ds_map_add(action_frame_data, "jackhammer", [
    [0, 0, 32, 24], [32, 0, 32, 24], [64, 0, 32, 24], [96, 0, 32, 24], [128, 0, 32, 24], [160, 0, 32, 24],
    [0, 24, 32, 24], [32, 24, 32, 24], [64, 24, 32, 24], [96, 24, 32, 24], [128, 24, 32, 24], [160, 24, 32, 24],
    [0, 48, 32, 24], [32, 48, 32, 24], [64, 48, 32, 24], [96, 48, 32, 24], [128, 48, 32, 24], [160, 48, 32, 24],
    [0, 72, 32, 24], [32, 72, 32, 24], [64, 72, 32, 24], [96, 72, 32, 24], [128, 72, 32, 24], [160, 72, 32, 24],
    [0, 96, 32, 24], [32, 96, 32, 24], [64, 96, 32, 24], [96, 96, 32, 24], [128, 96, 32, 24], [160, 96, 32, 24],
    [0, 120, 32, 24], [32, 120, 32, 24], [64, 120, 32, 24], [96, 120, 32, 24], [128, 120, 32, 24], [160, 120, 32, 24],
    [0, 144, 32, 24], [32, 144, 32, 24], [64, 144, 32, 24], [96, 144, 32, 24], [128, 144, 32, 24], [160, 144, 32, 24],
    [0, 168, 32, 24], [32, 168, 32, 24], [64, 168, 32, 24], [96, 168, 32, 24], [128, 168, 32, 24], [160, 168, 32, 24],
    [0, 192, 32, 24], [32, 192, 32, 24], [64, 192, 32, 24], [96, 192, 32, 24], [128, 192, 32, 24], [160, 192, 32, 24]
]);
ds_map_add(action_sprite_body, "jackhammer", spr_player_body_jackhammer);
ds_map_add(action_sprite_color, "jackhammer", spr_player_colour_jackhammer);
ds_map_add(action_anim_speed, "jackhammer", 0.3); // ~3.33 FPS// Snow Shovel (16 frames, 24x48, spr_player_body_snowshovel)
ds_map_add(action_frame_data, "snowshovel", [
    [0, 0, 24, 48], [24, 0, 24, 48], [48, 0, 24, 48], [72, 0, 24, 48], [96, 0, 24, 48], [120, 0, 24, 48], [144, 0, 24, 48], [168, 0, 24, 48],
    [0, 48, 24, 48], [24, 48, 24, 48], [48, 48, 24, 48], [72, 48, 24, 48], [96, 48, 24, 48], [120, 48, 24, 48], [144, 48, 24, 48], [168, 48, 24, 48]
]);
ds_map_add(action_sprite_body, "snowshovel", spr_player_body_snowshovel);
ds_map_add(action_sprite_color, "snowshovel", spr_player_colour_snowshovel);
ds_map_add(action_anim_speed, "snowshovel", 0.2); // ~5 FPS// Debugging
show_debug_message("obj_player: Initialized. Driving state: " + string(driving));
Step:
if (global.game_paused) {
    exit;
}if (global.game_paused && instance_exists(obj_inventory_expanded)) {
    if (action_state != "none") {
        var frames = ds_map_find_value(action_frame_data, action_state);
        if (!is_undefined(frames)) {
            image_speed = ds_map_find_value(action_anim_speed, action_state);
            image_index += image_speed;
            var frame_count = array_length(frames);  // Number of frames
            if (image_index >= frame_count) image_index = 0;
        } else {
            show_debug_message("Error: No frame data for action_state " + action_state);
            action_state = "none";  // Reset to avoid repeated errors
        }
    } else {
        image_index += 0.15;  // Walking animation
        if (image_index >= 3) image_index = 0;
    }
} else if (global.game_paused) {
    exit;
}
// Ensure obj_inventory exists before accessing it
if (instance_exists(obj_inventory)) { if (obj_inventory.has_item("Wrench")) {} }// Prevent updates when paused
if (global.is_pause_menu_active) { exit; }// Handle special actions (only when not driving)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) {  // H for Dance
        action_state = "dance";
        action_timer = 0;
        action_duration = 224;  // 56 frames * 4 steps per frame (at 0.25 speed)
        image_index = 0;
        show_debug_message("Starting dance");
    }
    else if (keyboard_check_pressed(ord("J"))) {  // J for Wave
        action_state = "wave";
        action_timer = 0;
        action_duration = 80;  // 16 frames * 5 steps per frame (at 0.2 speed)
        image_index = 0;
        show_debug_message("Starting wave");
    }
    else if (keyboard_check_pressed(ord("K"))) {  // K for Sit
        action_state = "sit";
        action_timer = 0;
        action_duration = -1;  // Infinite until toggled off
        image_index = 0;
        show_debug_message("Starting sit");
    }
    else if (keyboard_check_pressed(ord("B"))) {  // B for Jackhammer
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Jackhammer")) {
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150;  // 50 frames * 3 steps per frame (at 0.3 speed)
            image_index = 0;
            show_debug_message("Starting jackhammer");
        } else {
            show_debug_message("Cannot start jackhammer: Jackhammer not in inventory.");
        }
    }
    else if (keyboard_check_pressed(ord("N"))) {  // N for Snow Shovel
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Snow Shovel")) {
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80;  // 16 frames * 5 steps per frame (at 0.2 speed)
            image_index = 0;
            show_debug_message("Starting snow shovel");
        } else {
            show_debug_message("Cannot start snow shovel: Snow Shovel not in inventory.");
        }
    }
}
else if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state);
    action_timer += 1;
    if (action_state == "sit" && keyboard_check_pressed(ord("K"))) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Stopped sitting");
    }
    else if (action_timer >= action_duration && action_duration != -1) {
        action_state = "none";
        image_index = 0;  // Reset to first walking frame
        // Keep last direction instead of resetting
        show_debug_message("Action " + action_state + " completed");
    }
}// Handle existing interactions (only when not in an action)
if (action_state == "none") {
    // Enter/Exit Tube
    if (keyboard_check_pressed(ord("T"))) {
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Tube")) {
                obj_controller.switch_skin("tube");
                show_debug_message("Entered tube mode.");
            } else if (global.current_skin == "tube") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
    // Enter/Exit Toboggan
    if (keyboard_check_pressed(ord("T"))) {
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Toboggan")) {
                obj_controller.switch_skin("toboggan");
                show_debug_message("Entered toboggan mode.");
            } else if (global.current_skin == "toboggan") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
    // Enter/Exit Ice Truck
    if (keyboard_check_pressed(ord("E"))) {
        var truck_nearby = instance_exists(obj_icetruck) && distance_to_object(obj_icetruck) < 16;
        if (instance_exists(obj_controller)) {
            if (truck_nearby && global.current_skin == "player") {
                obj_controller.switch_skin("icetruck");
            } else if (global.current_skin == "icetruck") {
                obj_controller.switch_skin("player");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for ice truck switch.");
        }
    }
    // Repair Ice Truck
    if (keyboard_check_pressed(ord("R"))) {
        if (place_meeting(x, y, obj_icetruck_broken) && 
            (obj_inventory.has_item("Wrench") || obj_inventory.has_item("Battery"))) {
            show_debug_message("Repairing ice truck...");
            if (obj_inventory.has_item("Battery")) {
                show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
                obj_inventory.remove_item("Battery");
            }
            show_debug_message("Battery removed after repair.");
            with (instance_place(x, y, obj_icetruck_broken)) instance_destroy();
            instance_create_layer(x, y, "Instances", obj_icetruck);
            show_debug_message("Ice truck repaired!");
        }
    }
    if (instance_exists(obj_inventory)) { if (obj_inventory.has_item("Fishing Rod")) {} }
}if (keyboard_check_pressed(ord("E"))) {
    var puffle = instance_nearest(x, y, obj_puffle);
    if (puffle != noone && distance_to_object(puffle) < 32) {
        // Check inventory for Puffle-O’s
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            global.selected_puffle = puffle;
            global.menu_state = "puffle_menu";
        } else {
            show_message("You need a Puffle O or Box Puffle O to interact with this puffle!");
        }
    }
}// Handle movement (only when not in an action)
if (action_state == "none") {
    if (!is_throwing) {
    var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
    var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
    var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
    var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

if (keyboard_check_pressed(ord("O"))) {
    is_throwing = true;
    throw_frame = 0;
    throw_direction = face; // Capture current facing direction
    xspd = 0; // Stop movement during throw
    yspd = 0;

}
    } else {
        // Handle throwing animation
        throw_frame += 1;
        if (throw_frame == snowball_release_frame) {
            // Spawn snowball with offset
            var offset_x = 0;
            var offset_y = 0;
            switch (throw_direction) {
                case RIGHT: offset_x = 12; break;
                case LEFT: offset_x = -12; break;
                case UP: offset_y = -12; break;
                case DOWN: offset_y = 12; break;
                case UP_RIGHT: offset_x = 8; offset_y = -8; break;
                case UP_LEFT: offset_x = -8; offset_y = -8; break;
                case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
                case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
            }
            var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
            snowball.direction = get_throw_direction(throw_direction);
            snowball.speed = 5;
        }
        if (throw_frame >= throw_animation_length) {
            is_throwing = false;
            throw_frame = 0;
        }
        xspd = 0; // Prevent movement during animation
        yspd = 0;
    }

if (!sliding) {
    xspd = (right_key - left_key) * move_spd;
    yspd = (down_key - up_key) * move_spd;
} else {
    xspd = slide_dir_x * slide_speed;
    yspd = slide_dir_y * slide_speed;
    slide_speed *= 0.98;
    if (abs(slide_speed) < 0.1) { sliding = false; xspd = 0; yspd = 0; }
}

if (instance_exists(obj_pauser)) { xspd = 0; yspd = 0; }

if (yspd < 0) {
    if (xspd < 0) { face = UP_LEFT; } else if (xspd > 0) { face = UP_RIGHT; } else { face = UP; }
} else if (yspd > 0) {
    if (xspd < 0) { face = DOWN_LEFT; } else if (xspd > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
} else {
    if (xspd > 0) { face = RIGHT; } else if (xspd < 0) { face = LEFT; }
}

xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

if (xspd != 0 || yspd != 0) { image_speed = 0.15; } else { image_speed = 0; image_index = 0; }
if (image_index >= 3) { image_index = 0; }

}set_depth();
Draw:
var draw_x = x;
var draw_y = y;
var frame_x, frame_y, frame_width, frame_height;
var current_sprite_body = sprite_body; // Default
var current_sprite_color = sprite_color;if (action_state == "none") {
    // Walking animation
    var frame_index = floor(image_index) mod 3;  // 3 frames per direction
    frame_x = frame_data[face][frame_index * 4];
    frame_y = frame_data[face][frame_index * 4 + 1];
    frame_width = frame_data[face][frame_index * 4 + 2];
    frame_height = frame_data[face][frame_index * 4 + 3];
    draw_x -= frame_width / 2; // Center 24x24
    draw_y -= frame_height / 2;
} else {
    // Special actions
    var frames = ds_map_find_value(action_frame_data, action_state);
    var frame_count = array_length(frames);  // Number of sub-arrays (frames)
    var frame_index;
    if (action_state == "sit") {
        // Static sitting frame based on direction
        // Map face to match sprite order: DOWN=0, DOWN_LEFT=1, LEFT=2, UP_LEFT=3, UP=4, UP_RIGHT=5, RIGHT=6, DOWN_RIGHT=7
        var sit_frame_map = [6, 4, 2, 0, 7, 5, 1, 3]; // RIGHT=0 maps to RIGHT=6, etc.
        frame_index = clamp(sit_frame_map[face], 0, frame_count - 1);
        show_debug_message("Face: " + string(face) + ", Sitting Frame: " + string(frame_index));
    } else {
        // Animated actions (dance, wave, jackhammer, snowshovel)
        frame_index = floor(image_index) mod frame_count;
    }
    // Access the sub-array for the current frame
    var frame_data_array = frames[frame_index];
    frame_x = frame_data_array[0];
    frame_y = frame_data_array[1];
    frame_width = frame_data_array[2];
    frame_height = frame_data_array[3];

// Set action-specific sprites
current_sprite_body = ds_map_find_value(action_sprite_body, action_state);
current_sprite_color = ds_map_find_value(action_sprite_color, action_state);
draw_x -= frame_width / 2; // Dynamic centering
draw_y -= frame_height / 2;

}if (is_throwing) {
    var animation_data = get_throw_animation_data(throw_direction);
    var frame_offset = animation_data[0];
    var flip = animation_data[1] ? -1 : 1;
    var frame_index = frame_offset + throw_frame;
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;
    var draw_x = x - 12 * flip;
    var draw_y = y - 12;

draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, c_white, 1);
draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip, 1, global.player_color, 1);

} else// Draw the sprite parts
draw_sprite_part_ext(current_sprite_body, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, c_white, 1);
gpu_set_blendmode(bm_normal);
draw_sprite_part_ext(current_sprite_color, 0, frame_x, frame_y, frame_width, frame_height, draw_x, draw_y, 1, 1, global.player_color, 1);// Draw equipped head item with debug logging
if (global.equipped_items.head != -1) {
    var item_index = global.equipped_items.head; // e.g., 0 for Beta Hat, 1 for Party Hat
    var head_sprite = ds_map_find_value(global.item_player_sprites, item_index);
    if (!is_undefined(head_sprite)) {
        show_debug_message("Drawing head item sprite: " + sprite_get_name(head_sprite) + " for item index: " + string(item_index));
        var offset_x = -12; // Adjust this if the hat is misaligned
        var offset_y = -12;
        draw_sprite_part_ext(head_sprite, 0, frame_x, frame_y, frame_width, frame_height, x + offset_x, y + offset_y, 1, 1, c_white, 1);
    } else {
        show_debug_message("ERROR: No player sprite found for item index: " + string(item_index));
    }
}

Thought for
21s

Expand for details

The error you're encountering occurs because the right_key variable is not defined when the player is in the throwing state. Specifically, the error message indicates that right_key is not set before being read in the line:
gml

xspd = (right_key - left_key) * move_spd;

This happens because the code for handling movement inputs is inside the condition that checks if the player is not throwing (if (!is_throwing)). However, when the player is throwing, this block is skipped, and the movement variables are not updated, leading to the error when trying to access right_key.
To resolve this issue, we need to ensure that the movement input variables are always defined, even when the player is in the throwing state. One way to do this is to move the input checks outside of the throwing condition so that they are always executed.
Here's an updated version of the Step event code with the necessary adjustments:
gml

// Always check for input, even when throwing
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Handle throwing initiation
if (!is_throwing && action_state == "none") {
    if (keyboard_check_pressed(ord("O"))) {
        is_throwing = true;
        throw_frame = 0;
        throw_direction = face; // Capture current facing direction
        xspd = 0; // Stop movement during throw
        yspd = 0;
    }
} else if (is_throwing) {
    // Handle throwing animation
    throw_frame += 1;
    if (throw_frame == snowball_release_frame) {
        // Spawn snowball with offset
        var offset_x = 0;
        var offset_y = 0;
        switch (throw_direction) {
            case RIGHT: offset_x = 12; break;
            case LEFT: offset_x = -12; break;
            case UP: offset_y = -12; break;
            case DOWN: offset_y = 12; break;
            case UP_RIGHT: offset_x = 8; offset_y = -8; break;
            case UP_LEFT: offset_x = -8; offset_y = -8; break;
            case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
            case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
        }
        var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
        snowball.direction = get_throw_direction(throw_direction);
        snowball.speed = 5;
    }
    if (throw_frame >= throw_animation_length) {
        is_throwing = false;
        throw_frame = 0;
    }
    xspd = 0; // Prevent movement during animation
    yspd = 0;
}

// Handle movement only when not throwing and not in a special action
if (!is_throwing && action_state == "none") {
    if (!sliding) {
        xspd = (right_key - left_key) * move_spd;
        yspd = (down_key - up_key) * move_spd;
    } else {
        xspd = slide_dir_x * slide_speed;
        yspd = slide_dir_y * slide_speed;
        slide_speed *= 0.98;
        if (abs(slide_speed) < 0.1) { sliding = false; xspd = 0; yspd = 0; }
    }

    if (instance_exists(obj_pauser)) { xspd = 0; yspd = 0; }

    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; } else if (xspd > 0) { face = UP_RIGHT; } else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; } else if (xspd > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; } else if (xspd < 0) { face = LEFT; }
    }

    xspd = handle_collision("x", xspd);
    yspd = handle_collision("y", yspd);
    if (irandom(1) == 0) {
        x += handle_collision("x", xspd * move_spd);
        y += handle_collision("y", yspd * move_spd);
    } else {
        y += handle_collision("y", yspd * move_spd);
        x += handle_collision("x", xspd * move_spd);
    }

    if (xspd != 0 || yspd != 0) { image_speed = 0.15; } else { image_speed = 0; image_index = 0; }
}

Explanation:
Input Checks Moved Outside: The variables right_key, left_key, up_key, and down_key are now defined at the beginning of the Step event, ensuring they are always set.

Throwing Logic Adjusted: The throwing initiation and animation handling are now properly nested within the condition checks, ensuring that movement is only calculated when the player is not throwing or in a special action.

Movement Calculation: Movement is only calculated when the player is not throwing and not in a special action, preventing conflicts with the throwing animation.

This should resolve the error and allow the snowball throwing action to function correctly within your special actions system. Let me know if you encounter any further issues!

Resolving the right_key Error and Integrating Snowball Throwing into the Special Actions System
The error you're encountering:

ERROR in action number 1 of Step Event0 for object obj_player:
local variable right_key(100388) not set before reading it.
at gml_Object_obj_player_Step_0 (line 213) - xspd = (right_key - left_key) * move_spd;

occurs because the movement input variables (right_key, left_key, etc.) are only defined within a conditional block that is skipped when the player is in the throwing state (is_throwing is true). This leaves right_key undefined when the code attempts to calculate xspd, causing the runtime error. Additionally, your query asks for a better integration of the snowball-throwing action into the existing special actions system (e.g., dancing, waving), which uses action_state to manage player behaviors.
Below, I'll provide an updated implementation that:
Fixes the error by ensuring input variables are always defined.

Integrates snowball throwing into the special actions system alongside actions like dancing and waving.

Maintains compatibility with your existing code structure.

Updated obj_player Step Event Code
Here’s how to modify the Step event in obj_player to resolve the issue and integrate snowball throwing as a special action:
gml

if (global.game_paused || global.is_pause_menu_active) {
    exit; // Prevent updates when paused
}

// Always define movement inputs at the start
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);

// Handle special actions (only when not driving)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) { // Dance
        action_state = "dance";
        action_timer = 0;
        action_duration = 224; // 56 frames * 4 steps
        image_index = 0;
        show_debug_message("Starting dance");
    } else if (keyboard_check_pressed(ord("J"))) { // Wave
        action_state = "wave";
        action_timer = 0;
        action_duration = 80; // 16 frames * 5 steps
        image_index = 0;
        show_debug_message("Starting wave");
    } else if (keyboard_check_pressed(ord("K"))) { // Sit
        action_state = "sit";
        action_timer = 0;
        action_duration = -1; // Infinite until toggled
        image_index = 0;
        show_debug_message("Starting sit");
    } else if (keyboard_check_pressed(ord("B"))) { // Jackhammer
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Jackhammer")) {
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150; // 50 frames * 3 steps
            image_index = 0;
            show_debug_message("Starting jackhammer");
        }
    } else if (keyboard_check_pressed(ord("N"))) { // Snow Shovel
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Snow Shovel")) {
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80; // 16 frames * 5 steps
            image_index = 0;
            show_debug_message("Starting snow shovel");
        }
    } else if (keyboard_check_pressed(ord("O"))) { // Throw Snowball
        action_state = "throw";
        action_timer = 0;
        action_duration = throw_animation_length; // 28 frames
        throw_direction = face; // Capture current facing direction
        image_index = 0;
        xspd = 0; // Stop movement
        yspd = 0;
        show_debug_message("Starting snowball throw");
    }
} else if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state);
    action_timer += 1;

    // Handle snowball throwing specifics
    if (action_state == "throw" && action_timer == snowball_release_frame) {
        var offset_x = 0;
        var offset_y = 0;
        switch (throw_direction) {
            case RIGHT: offset_x = 12; break;
            case LEFT: offset_x = -12; break;
            case UP: offset_y = -12; break;
            case DOWN: offset_y = 12; break;
            case UP_RIGHT: offset_x = 8; offset_y = -8; break;
            case UP_LEFT: offset_x = -8; offset_y = -8; break;
            case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
            case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
        }
        var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
        snowball.direction = get_throw_direction(throw_direction);
        snowball.speed = 5;
        show_debug_message("Snowball thrown in direction: " + string(throw_direction));
    }

    // End special action
    if (action_state == "sit" && keyboard_check_pressed(ord("K"))) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Stopped sitting");
    } else if (action_timer >= action_duration && action_duration != -1) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Action " + action_state + " completed");
    }
}

// Handle movement (only when not in an action or throwing)
if (action_state == "none") {
    if (!sliding) {
        xspd = (right_key - left_key) * move_spd;
        yspd = (down_key - up_key) * move_spd;
    } else {
        xspd = slide_dir_x * slide_speed;
        yspd = slide_dir_y * slide_speed;
        slide_speed *= 0.98;
        if (abs(slide_speed) < 0.1) { sliding = false; xspd = 0; yspd = 0; }
    }

    if (instance_exists(obj_pauser)) { xspd = 0; yspd = 0; }

    // Update facing direction
    if (yspd < 0) {
        if (xspd < 0) { face = UP_LEFT; } else if (xspd > 0) { face = UP_RIGHT; } else { face = UP; }
    } else if (yspd > 0) {
        if (xspd < 0) { face = DOWN_LEFT; } else if (xspd > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
    } else {
        if (xspd > 0) { face = RIGHT; } else if (xspd < 0) { face = LEFT; }
    }

    // Apply collision and movement
    xspd = handle_collision("x", xspd);
    yspd = handle_collision("y", yspd);
    if (irandom(1) == 0) {
        x += handle_collision("x", xspd * move_spd);
        y += handle_collision("y", yspd * move_spd);
    } else {
        y += handle_collision("y", yspd * move_spd);
        x += handle_collision("x", xspd * move_spd);
    }

    if (xspd != 0 || yspd != 0) { image_speed = 0.15; } else { image_speed = 0; image_index = 0; }
    if (image_index >= 3) { image_index = 0; }
}

// Handle other interactions (e.g., tube, toboggan, truck) remain unchanged
// ... [Your existing interaction code here] ...

set_depth();

Updated obj_player Create Event Code
To fully integrate the throwing action, add the frame data and sprite information for the "throw" action to the special actions system in the Create event. Add the following after your existing action definitions:
gml

// Throw Snowball (28 frames, 24x24, assuming spr_throwsnowball_body at y=0-96)
ds_map_add(action_frame_data, "throw", [
    [0, 0, 24, 24], [24, 0, 24, 24], [48, 0, 24, 24], [72, 0, 24, 24], 
    [96, 0, 24, 24], [120, 0, 24, 24], [144, 0, 24, 24], [168, 0, 24, 24],
    [0, 24, 24, 24], [24, 24, 24, 24], [48, 24, 24, 24], [72, 24, 24, 24], 
    [96, 24, 24, 24], [120, 24, 24, 24], [144, 24, 24, 24], [168, 24, 24, 24],
    [0, 48, 24, 24], [24, 48, 24, 24], [48, 48, 24, 24], [72, 48, 24, 24], 
    [96, 48, 24, 24], [120, 48, 24, 24], [144, 48, 24, 24], [168, 48, 24, 24],
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
ds_map_add(action_anim_speed, "throw", 1.0); // Full speed for 28 frames

Notes:
Adjust the frame coordinates (x, y, width, height) to match your spr_throwsnowball_body and spr_throwsnowball_colour sprite sheets.

Remove the standalone is_throwing and throw_frame variables from the Create event, as action_state and action_timer will now handle this.

Key Changes Explained
Fixing the right_key Error:
Movement input variables (right_key, left_key, etc.) are now defined at the top of the Step event, outside any conditional blocks. This ensures they are always set before being used, preventing the "not set before reading" error.

Integrating Snowball Throwing as a Special Action:
The throwing mechanic is now triggered by setting action_state = "throw" when "O" is pressed, using the same system as dancing (H), waving (J), etc.

The action_timer replaces throw_frame, and action_duration is set to throw_animation_length (28 frames).

The snowball is spawned when action_timer reaches snowball_release_frame (15), consistent with your original logic.

Movement Handling:
Movement is only calculated when action_state == "none", ensuring the player stops moving during throwing, dancing, waving, etc., without needing separate is_throwing checks.

Drawing:
The Draw event already supports special actions via action_frame_data. Adding the "throw" action to the maps ensures it uses the same rendering logic as other actions. You can remove the separate is_throwing drawing block since it’s now handled by the special actions system.

Additional Notes
Sprite Assumptions: This assumes your spr_throwsnowball_body and spr_throwsnowball_colour sprites are 192x96 pixels with 28 frames (8 columns across 4 rows). Adjust the frame data in the Create event if your sprite sheet differs.

Helper Function: Ensure get_throw_direction(throw_direction) is defined elsewhere in your code (e.g., converting face enums to degrees like 0 for RIGHT, 90 for UP, etc.).

Testing: Test the throwing action alongside dancing and waving to ensure animations and timings work as expected.

This implementation should resolve the error and provide a seamless integration of snowball throwing into your special actions system. Let me know if you need further adjustments!

Everything works perfectly, I want to change which sprites are shown when the player throws a snowball
use "Throw Face Down Right" when the player throws and is facing down right and
use "Throw Face Up Right" when the player throws and is facing up right and
use "Throw Face Down Right" flipped when the player throws and is facing down left and
use "Throw Face Up Right" flipped when the player throws and is facing up left and
when the player is facing right use a 50% chance of using down right or up right and
when the player is facing left use a 50% chance of using down right flipped or up right flipped and
when the player is facing up use a 50% chance of using up right or up right flipped and 
when the player is facing down use a 50% chance of using down right or down right flipped.The throwing animation and snowball are way to fast, slow them down.

Thought for
26s

Expand for details

To adjust the snowball-throwing animation based on the player's facing direction and slow down both the animation and the snowball's speed, we'll make the following changes:
Step 1: Adjust Animation Based on Facing Direction
We need to select the appropriate animation (Throw Face Down Right or Throw Face Up Right) depending on the player's face direction, and handle the flipping for left-facing directions. Additionally, for cardinal directions (right, left, up, down), we'll randomly choose between the two animations with a 50% chance.
Here’s how we can modify the existing code to achieve this:
Determine Animation and Flip State:
For DOWN_RIGHT and DOWN_LEFT, use "Throw Face Down Right" (flipped for left).

For UP_RIGHT and UP_LEFT, use "Throw Face Up Right" (flipped for left).

For RIGHT, randomly choose between "Throw Face Down Right" or "Throw Face Up Right".

For LEFT, randomly choose between "Throw Face Down Right" flipped or "Throw Face Up Right" flipped.

For UP, randomly choose between "Throw Face Up Right" or "Throw Face Up Right" flipped.

For DOWN, randomly choose between "Throw Face Down Right" or "Throw Face Down Right" flipped.

Implement in the Draw Event:
When action_state == "throw", determine which animation to use and whether to flip it based on the throw_direction.

Step 2: Slow Down the Animation and Snowball Speed
Slow Down Animation:
Reduce the animation speed by lowering the image_speed for the "throw" action.

Adjust action_anim_speed in the Create event for "throw".

Slow Down Snowball Speed:
Decrease the speed value when creating the snowball in the Step event.

Updated Code Implementation
Create Event (Adjust Animation Speed)
In the Create event, adjust the animation speed for the "throw" action:
gml

// In obj_player Create event, update the throw animation speed
ds_map_add(action_anim_speed, "throw", 0.5); // Reduced from 1.0 to slow down (e.g., 0.5 for half speed)

Step Event (Slow Down Snowball Speed)
In the Step event, reduce the snowball's speed when it's created:
gml

// In obj_player Step event, inside the "throw" action block
if (action_state == "throw" && action_timer == snowball_release_frame) {
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to slow it down (e.g., 3)
}

Draw Event (Select Animation Based on Direction)
In the Draw event, modify the logic for action_state == "throw" to select the correct animation and handle flipping:
gml

if (action_state == "throw") {
    var animation_type = "";
    var flip = false;

    // Determine animation type and flip based on throw_direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            animation_type = "down_right";
            flip = false;
            break;
        case UP_RIGHT:
            animation_type = "up_right";
            flip = false;
            break;
        case DOWN_LEFT:
            animation_type = "down_right";
            flip = true;
            break;
        case UP_LEFT:
            animation_type = "up_right";
            flip = true;
            break;
        case RIGHT:
            animation_type = choose("down_right", "up_right");
            flip = false;
            break;
        case LEFT:
            animation_type = choose("down_right", "up_right");
            flip = true;
            break;
        case UP:
            animation_type = "up_right";
            flip = choose(false, true); // 50% chance to flip
            break;
        case DOWN:
            animation_type = "down_right";
            flip = choose(false, true); // 50% chance to flip
            break;
    }

    // Determine frame offset based on animation type
    var frame_offset = (animation_type == "down_right") ? 0 : 28; // Assuming down_right is frames 0-27, up_right is 28-55

    // Calculate frame index
    var frame_index = frame_offset + floor(action_timer * image_speed) mod 28; // 28 frames per animation

    // Calculate sprite coordinates
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust drawing position for flipping
    var draw_x = x - 12 * (flip ? -1 : 1);
    var draw_y = y - 12;

    // Draw the sprites with flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Existing drawing code for other states
}

Explanation of Changes
Animation Selection:
For DOWN_RIGHT and UP_RIGHT, use the corresponding animations directly.

For DOWN_LEFT and UP_LEFT, use the right-facing animations but flip them horizontally.

For RIGHT and LEFT, randomly choose between "down_right" and "up_right" animations, flipping for left.

For UP and DOWN, use "up_right" or "down_right" respectively, with a 50% chance to flip horizontally.

Frame Calculation:
The frame_offset determines whether to use the first 28 frames (down_right) or the next 28 (up_right).

The frame_index is calculated based on action_timer and image_speed, ensuring it loops every 28 frames.

Flipping:
When flip is true, the sprite is drawn with a horizontal scale of -1, effectively flipping it.

Slowing Down Animation and Snowball:
The animation speed is reduced by setting action_anim_speed to 0.5 (or another value) in the Create event.

The snowball's speed is reduced from 5 to 3 (or another value) when created in the Step event.

Additional Notes
Fine-Tuning Speeds: You can further adjust action_anim_speed["throw"] and snowball.speed to find the perfect balance for your game.

Frame Offsets: Ensure that the frame offsets (0 for down_right, 28 for up_right) match your sprite sheet's layout.

Testing: Test the animation in all directions to ensure the correct animation is selected and flipped appropriately.

This solution should provide the desired behavior for the snowball-throwing animation and slow down both the animation and the projectile. Let me know if you need further adjustments!

To customize the snowball-throwing animation sprites based on the player's facing direction and slow down both the animation and the snowball's speed, we'll update the GameMaker Language (GML) code in the player object. Below is a complete solution tailored to your specific requirements.
Part 1: Changing Sprites Based on Facing Direction
You want the snowball-throwing animation to use specific sprites ("Throw Face Down Right" and "Throw Face Up Right") depending on the player's facing direction, with flipping for left-facing directions and random selection for cardinal directions (up, down, left, right). Here's how we'll implement this:
DOWN_RIGHT: Use "Throw Face Down Right".

UP_RIGHT: Use "Throw Face Up Right".

DOWN_LEFT: Use "Throw Face Down Right" flipped.

UP_LEFT: Use "Throw Face Up Right" flipped.

RIGHT: 50% chance of "Throw Face Down Right" or "Throw Face Up Right".

LEFT: 50% chance of "Throw Face Down Right" flipped or "Throw Face Up Right" flipped.

UP: 50% chance of "Throw Face Up Right" or "Throw Face Up Right" flipped.

DOWN: 50% chance of "Throw Face Down Right" or "Throw Face Down Right" flipped.

We'll modify the Draw Event to handle this logic. Assuming your sprite sheet (spr_throwsnowball_body and spr_throwsnowball_colour) contains both animations (e.g., "Throw Face Down Right" in frames 0-27 and "Throw Face Up Right" in frames 28-55), we'll select the appropriate animation and flip it as needed.
Part 2: Slowing Down the Animation and Snowball Speed
The throwing animation and snowball speed are too fast, so we'll:
Slow the animation: Reduce the animation speed by lowering image_speed for the "throw" action.

Slow the snowball: Decrease the snowball's speed when it's created.

We'll adjust these values in the Create Event and Step Event, respectively.
Updated Code
Below is the complete code for the player object (obj_player) to achieve your desired behavior.
Create Event: Set Animation Speed
In the Create Event, define the animation speed for the "throw" action and reduce it to slow down the animation:
gml

// Initialize action animation speeds
action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5); // Reduced from 1.0 to 0.5 (half speed)

0.5: This slows the animation to half its original speed. Adjust this value (e.g., 0.3 for even slower) to fine-tune the feel.

Step Event: Slow Down Snowball Speed
In the Step Event, when the snowball is created during the "throw" action, reduce its speed:
gml

// In obj_player Step event
if (action_state == "throw" && action_timer == snowball_release_frame) {
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    action_timer++; // Increment timer after creating the snowball
}

snowball.speed = 3: This reduces the snowball's speed. Adjust this (e.g., 2 or 4) to match your preference.

Note: snowball_release_frame, offset_x, offset_y, and get_throw_direction are assumed to be defined elsewhere in your code. Adjust as needed.

Draw Event: Select Sprites Based on Direction
In the Draw Event, update the logic for the "throw" action to use the correct sprite and flip it based on throw_direction:
gml

// In obj_player Draw event
if (action_state == "throw") {
    var animation_type = "";
    var flip = false;

    // Determine animation type and flip based on throw_direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            animation_type = "down_right";
            flip = false;
            break;
        case UP_RIGHT:
            animation_type = "up_right";
            flip = false;
            break;
        case DOWN_LEFT:
            animation_type = "down_right";
            flip = true;
            break;
        case UP_LEFT:
            animation_type = "up_right";
            flip = true;
            break;
        case RIGHT:
            animation_type = choose("down_right", "up_right");
            flip = false;
            break;
        case LEFT:
            animation_type = choose("down_right", "up_right");
            flip = true;
            break;
        case UP:
            animation_type = "up_right";
            flip = choose(false, true); // 50% chance to flip
            break;
        case DOWN:
            animation_type = "down_right";
            flip = choose(false, true); // 50% chance to flip
            break;
    }

    // Set frame offset based on animation type
    var frame_offset = (animation_type == "down_right") ? 0 : 28; // "Throw Face Down Right" at 0, "Throw Face Up Right" at 28

    // Calculate frame index based on action_timer and image_speed
    var frame_index = frame_offset + floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod 28; // 28 frames per animation

    // Calculate sprite coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust drawing position for flipping
    var draw_x = x - 12 * (flip ? -1 : 1); // Center sprite, adjust for flip
    var draw_y = y - 12; // Center vertically

    // Draw the sprites with flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x, draw_y, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Add your existing drawing code for other states (e.g., idle, walk) here
    draw_self(); // Placeholder for other states
}

Explanation of Changes
Sprite Selection
Animation Type: 
"down_right" corresponds to "Throw Face Down Right" (frames 0-27).

"up_right" corresponds to "Throw Face Up Right" (frames 28-55).

The switch statement assigns the correct animation and flip state based on throw_direction.

Random Selection: The choose() function provides a 50% chance for cardinal directions (RIGHT, LEFT, UP, DOWN).

Flipping: When flip = true, the sprite is drawn with a horizontal scale of -1, flipping it left.

Frame Calculation
frame_offset: 
0 for "Throw Face Down Right".

28 for "Throw Face Up Right" (adjust this if your sprite sheet layout differs).

frame_index: Uses action_timer and the reduced image_speed (from action_anim_speed) to animate smoothly over 28 frames.

Slowing Down
Animation: ds_map_add(action_anim_speed, "throw", 0.5) halves the animation speed. You can tweak this value (e.g., 0.3 or 0.7) for finer control.

Snowball: snowball.speed = 3 reduces the projectile speed. Adjust this (e.g., 2 or 4) to suit your game.

Assumptions
Sprite Sheet: spr_throwsnowball_body and spr_throwsnowball_colour are sprite sheets with:
"Throw Face Down Right" in frames 0-27.

"Throw Face Up Right" in frames 28-55.

Each frame is 24x24 pixels, with 8 columns.

Adjust frame_offset, sprite size (24), or column count (8) if your sprite sheet differs.

Variables: action_state, action_timer, throw_direction, snowball_release_frame, offset_x, offset_y, and get_throw_direction() are already defined in your project.

Constants: DOWN_RIGHT, UP_RIGHT, etc., are defined (e.g., as enums or macros).

If any of these assumptions don't match your setup, let me know, and I'll adjust the solution!
Testing and Fine-Tuning
Test All Directions: Verify that the correct sprite appears and flips appropriately for each throw_direction.

Adjust Speeds: 
If the animation is still too fast, lower action_anim_speed["throw"] (e.g., to 0.3).

If the snowball is too fast, reduce snowball.speed (e.g., to 2).

Sprite Alignment: Ensure draw_x and draw_y align the sprite correctly with your player’s position.

This should give you exactly the sprite behavior and slower speeds you requested! Let me know if you need further tweaks.

ERROR!!! :: ############################################################################################
ERROR in action number 1
of  Step Event0 for object obj_player:
Variable <unknown_object>.offset_y(100408, -2147483648) not set before reading it.
 at gml_Object_obj_player_Step_0 (line 63) - 	    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
############################################################################################
gml_Object_obj_player_Step_0 (line 63) obj_player create event: // Core variables
xspd = 0;
yspd = 0;
move_spd = 1;
state = "walking";
if (!variable_global_exists("player_color")) { global.player_color = c_white; }
if (variable_global_exists("last_player_color")) { global.player_color = global.last_player_color; } else { global.player_color = c_white; }// Sliding variables
sliding = false;
slide_dir_x = 0;
slide_dir_y = 0;
slide_speed = 0;// Driving variables
driving = false;
original_sprite = sprite_index;// Snowball throw variables
is_throwing = false;
throw_frame = 0;
throw_direction = -1;
throw_animation_length = 28; // 28 frames per animation
snowball_release_frame = 15; // Snowball spawns mid-animation// Set direction and sprites
face = DOWN;
//init_sprites(spr_player_right, spr_player_up, spr_player_left, spr_player_down, spr_player_up_right, spr_player_up_left, spr_player_down_right, spr_player_down_left);
sprite_body = spr_player_body; // Default sprite
sprite_color = spr_player_colour;
mask_index = spr_player_down;// Frame data for walking (192x72 sprite sheet: 3 frames per direction)
frame_data = array_create(8);
frame_data[DOWN] = [0, 0, 24, 24, 0, 24, 24, 24, 0, 48, 24, 24];
frame_data[UP] = [24, 0, 24, 24, 24, 24, 24, 24, 24, 48, 24, 24];
frame_data[DOWN_LEFT] = [48, 0, 24, 24, 48, 24, 24, 24, 48, 48, 24, 24];
frame_data[DOWN_RIGHT] = [72, 0, 24, 24, 72, 24, 24, 24, 72, 48, 24, 24];
frame_data[LEFT] = [96, 0, 24, 24, 96, 24, 24, 24, 96, 48, 24, 24];
frame_data[RIGHT] = [120, 0, 24, 24, 120, 24, 24, 24, 120, 48, 24, 24];
frame_data[UP_RIGHT] = [144, 0, 24, 24, 144, 24, 24, 24, 144, 48, 24, 24];
frame_data[UP_LEFT] = [168, 0, 24, 24, 168, 24, 24, 24, 168, 48, 24, 24];// Special actions system
action_state = "none";  // "none", "dance", "wave", "sit", "jackhammer", "snowshovel"
action_timer = 0;
action_duration = 0;// Frame data and sprite maps for special actions
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();// Sit (8 frames, 24x24, y=72 in spr_player_body)
ds_map_add(action_frame_data, "sit", [
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24],
    [96, 72, 24, 24], [120, 72, 24, 24], [144, 72, 24, 24], [168, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "sit", spr_player_body);
ds_map_add(action_sprite_color, "sit", spr_player_colour);
ds_map_add(action_anim_speed, "sit", 0); // Static// Wave (16 frames, 24x24, y=96-120 in spr_player_body)
ds_map_add(action_frame_data, "wave", [
    [0, 96, 24, 24], [24, 96, 24, 24], [48, 96, 24, 24], [72, 96, 24, 24],
    [96, 96, 24, 24], [120, 96, 24, 24], [144, 96, 24, 24], [168, 96, 24, 24],
    [0, 120, 24, 24], [24, 120, 24, 24], [48, 120, 24, 24], [72, 120, 24, 24],
    [96, 120, 24, 24], [120, 120, 24, 24], [144, 120, 24, 24], [168, 120, 24, 24]
]);
ds_map_add(action_sprite_body, "wave", spr_player_body);
ds_map_add(action_sprite_color, "wave", spr_player_colour);
ds_map_add(action_anim_speed, "wave", 0.2); // ~5 FPS// Dance (56 frames, 24x24, y=144-288 in spr_player_body)
ds_map_add(action_frame_data, "dance", [
    [0, 144, 24, 24], [24, 144, 24, 24], [48, 144, 24, 24], [72, 144, 24, 24], [96, 144, 24, 24], [120, 144, 24, 24], [144, 144, 24, 24], [168, 144, 24, 24],
    [0, 168, 24, 24], [24, 168, 24, 24], [48, 168, 24, 24], [72, 168, 24, 24], [96, 168, 24, 24], [120, 168, 24, 24], [144, 168, 24, 24], [168, 168, 24, 24],
    [0, 192, 24, 24], [24, 192, 24, 24], [48, 192, 24, 24], [72, 192, 24, 24], [96, 192, 24, 24], [120, 192, 24, 24], [144, 192, 24, 24], [168, 192, 24, 24],
    [0, 216, 24, 24], [24, 216, 24, 24], [48, 216, 24, 24], [72, 216, 24, 24], [96, 216, 24, 24], [120, 216, 24, 24], [144, 216, 24, 24], [168, 216, 24, 24],
    [0, 240, 24, 24], [24, 240, 24, 24], [48, 240, 24, 24], [72, 240, 24, 24], [96, 240, 24, 24], [120, 240, 24, 24], [144, 240, 24, 24], [168, 240, 24, 24],
    [0, 264, 24, 24], [24, 264, 24, 24], [48, 264, 24, 24], [72, 264, 24, 24], [96, 264, 24, 24], [120, 264, 24, 24], [144, 264, 24, 24], [168, 264, 24, 24],
    [0, 288, 24, 24], [24, 288, 24, 24], [48, 288, 24, 24], [72, 288, 24, 24], [96, 288, 24, 24], [120, 288, 24, 24], [144, 288, 24, 24], [168, 288, 24, 24]
]);
ds_map_add(action_sprite_body, "dance", spr_player_body);
ds_map_add(action_sprite_color, "dance", spr_player_colour);
ds_map_add(action_anim_speed, "dance", 0.25); // ~4 FPS// Jackhammer (50 frames, 32x24, spr_player_body_jackhammer)
ds_map_add(action_frame_data, "jackhammer", [
    [0, 0, 32, 24], [32, 0, 32, 24], [64, 0, 32, 24], [96, 0, 32, 24], [128, 0, 32, 24], [160, 0, 32, 24],
    [0, 24, 32, 24], [32, 24, 32, 24], [64, 24, 32, 24], [96, 24, 32, 24], [128, 24, 32, 24], [160, 24, 32, 24],
    [0, 48, 32, 24], [32, 48, 32, 24], [64, 48, 32, 24], [96, 48, 32, 24], [128, 48, 32, 24], [160, 48, 32, 24],
    [0, 72, 32, 24], [32, 72, 32, 24], [64, 72, 32, 24], [96, 72, 32, 24], [128, 72, 32, 24], [160, 72, 32, 24],
    [0, 96, 32, 24], [32, 96, 32, 24], [64, 96, 32, 24], [96, 96, 32, 24], [128, 96, 32, 24], [160, 96, 32, 24],
    [0, 120, 32, 24], [32, 120, 32, 24], [64, 120, 32, 24], [96, 120, 32, 24], [128, 120, 32, 24], [160, 120, 32, 24],
    [0, 144, 32, 24], [32, 144, 32, 24], [64, 144, 32, 24], [96, 144, 32, 24], [128, 144, 32, 24], [160, 144, 32, 24],
    [0, 168, 32, 24], [32, 168, 32, 24], [64, 168, 32, 24], [96, 168, 32, 24], [128, 168, 32, 24], [160, 168, 32, 24],
    [0, 192, 32, 24], [32, 192, 32, 24], [64, 192, 32, 24], [96, 192, 32, 24], [128, 192, 32, 24], [160, 192, 32, 24]
]);
ds_map_add(action_sprite_body, "jackhammer", spr_player_body_jackhammer);
ds_map_add(action_sprite_color, "jackhammer", spr_player_colour_jackhammer);
ds_map_add(action_anim_speed, "jackhammer", 0.3); // ~3.33 FPS// Snow Shovel (16 frames, 24x48, spr_player_body_snowshovel)
ds_map_add(action_frame_data, "snowshovel", [
    [0, 0, 24, 48], [24, 0, 24, 48], [48, 0, 24, 48], [72, 0, 24, 48], [96, 0, 24, 48], [120, 0, 24, 48], [144, 0, 24, 48], [168, 0, 24, 48],
    [0, 48, 24, 48], [24, 48, 24, 48], [48, 48, 24, 48], [72, 48, 24, 48], [96, 48, 24, 48], [120, 48, 24, 48], [144, 48, 24, 48], [168, 48, 24, 48]
]);
ds_map_add(action_sprite_body, "snowshovel", spr_player_body_snowshovel);
ds_map_add(action_sprite_color, "snowshovel", spr_player_colour_snowshovel);
ds_map_add(action_anim_speed, "snowshovel", 0.2); // ~5 FPS// Debugging
show_debug_message("obj_player: Initialized. Driving state: " + string(driving));// Throw Snowball (28 frames, 24x24, assuming spr_throwsnowball_body at y=0-96)
ds_map_add(action_frame_data, "throw", [
    [0, 0, 24, 24], [24, 0, 24, 24], [48, 0, 24, 24], [72, 0, 24, 24], 
    [96, 0, 24, 24], [120, 0, 24, 24], [144, 0, 24, 24], [168, 0, 24, 24],
    [0, 24, 24, 24], [24, 24, 24, 24], [48, 24, 24, 24], [72, 24, 24, 24], 
    [96, 24, 24, 24], [120, 24, 24, 24], [144, 24, 24, 24], [168, 24, 24, 24],
    [0, 48, 24, 24], [24, 48, 24, 24], [48, 48, 24, 24], [72, 48, 24, 24], 
    [96, 48, 24, 24], [120, 48, 24, 24], [144, 48, 24, 24], [168, 48, 24, 24],
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5); // Reduced from 1.0 to 0.5 (half speed) step event: if (global.game_paused || global.is_pause_menu_active) {
    exit; // Prevent updates when paused
}// Always define movement inputs at the start
var right_key = keyboard_check(ord("D")) || keyboard_check(vk_right);
var left_key = keyboard_check(ord("A")) || keyboard_check(vk_left);
var up_key = keyboard_check(ord("W")) || keyboard_check(vk_up);
var down_key = keyboard_check(ord("S")) || keyboard_check(vk_down);// Handle special actions (only when not driving)
if (!driving && action_state == "none") {
    if (keyboard_check_pressed(ord("H"))) { // Dance
        action_state = "dance";
        action_timer = 0;
        action_duration = 224; // 56 frames * 4 steps
        image_index = 0;
        show_debug_message("Starting dance");
    } else if (keyboard_check_pressed(ord("J"))) { // Wave
        action_state = "wave";
        action_timer = 0;
        action_duration = 80; // 16 frames * 5 steps
        image_index = 0;
        show_debug_message("Starting wave");
    } else if (keyboard_check_pressed(ord("K"))) { // Sit
        action_state = "sit";
        action_timer = 0;
        action_duration = -1; // Infinite until toggled
        image_index = 0;
        show_debug_message("Starting sit");
    } else if (keyboard_check_pressed(ord("B"))) { // Jackhammer
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Jackhammer")) {
            action_state = "jackhammer";
            action_timer = 0;
            action_duration = 150; // 50 frames * 3 steps
            image_index = 0;
            show_debug_message("Starting jackhammer");
        }
    } else if (keyboard_check_pressed(ord("N"))) { // Snow Shovel
        if (instance_exists(obj_inventory) && obj_inventory.has_item("Snow Shovel")) {
            action_state = "snowshovel";
            action_timer = 0;
            action_duration = 80; // 16 frames * 5 steps
            image_index = 0;
            show_debug_message("Starting snow shovel");
        }
    } else if (keyboard_check_pressed(ord("O"))) { // Throw Snowball
        action_state = "throw";
        action_timer = 0;
        action_duration = throw_animation_length; // 28 frames
        throw_direction = face; // Capture current facing direction
        image_index = 0;
        xspd = 0; // Stop movement
        yspd = 0;
        show_debug_message("Starting snowball throw");
    }
} else if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state);
    action_timer += 1;

// Handle snowball throwing specifics
if (action_state == "throw" && action_timer == snowball_release_frame) {
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    action_timer++; // Increment timer after creating the snowball
}

// End special action
if (action_state == "sit" && keyboard_check_pressed(ord("K"))) {
    action_state = "none";
    image_index = 0;
    show_debug_message("Stopped sitting");
} else if (action_timer >= action_duration && action_duration != -1) {
    action_state = "none";
    image_index = 0;
    show_debug_message("Action " + action_state + " completed");
}

}// Handle movement (only when not in an action or throwing)
if (action_state == "none") {
    if (!sliding) {
        xspd = (right_key - left_key) * move_spd;
        yspd = (down_key - up_key) * move_spd;
    } else {
        xspd = slide_dir_x * slide_speed;
        yspd = slide_dir_y * slide_speed;
        slide_speed *= 0.98;
        if (abs(slide_speed) < 0.1) { sliding = false; xspd = 0; yspd = 0; }
    }

if (instance_exists(obj_pauser)) { xspd = 0; yspd = 0; }

// Update facing direction
if (yspd < 0) {
    if (xspd < 0) { face = UP_LEFT; } else if (xspd > 0) { face = UP_RIGHT; } else { face = UP; }
} else if (yspd > 0) {
    if (xspd < 0) { face = DOWN_LEFT; } else if (xspd > 0) { face = DOWN_RIGHT; } else { face = DOWN; }
} else {
    if (xspd > 0) { face = RIGHT; } else if (xspd < 0) { face = LEFT; }
}

// Apply collision and movement
xspd = handle_collision("x", xspd);
yspd = handle_collision("y", yspd);
if (irandom(1) == 0) {
    x += handle_collision("x", xspd * move_spd);
    y += handle_collision("y", yspd * move_spd);
} else {
    y += handle_collision("y", yspd * move_spd);
    x += handle_collision("x", xspd * move_spd);
}

if (xspd != 0 || yspd != 0) { image_speed = 0.15; } else { image_speed = 0; image_index = 0; }
if (image_index >= 3) { image_index = 0; }

}// Handle existing interactions (only when not in an action)
if (action_state == "none") {
    // Enter/Exit Tube
    if (keyboard_check_pressed(ord("T"))) {
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Tube")) {
                obj_controller.switch_skin("tube");
                show_debug_message("Entered tube mode.");
            } else if (global.current_skin == "tube") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
    // Enter/Exit Toboggan
    if (keyboard_check_pressed(ord("T"))) {
        if (instance_exists(obj_controller)) {
            if (global.current_skin == "player" && obj_inventory.has_item("Toboggan")) {
                obj_controller.switch_skin("toboggan");
                show_debug_message("Entered toboggan mode.");
            } else if (global.current_skin == "toboggan") {
                obj_controller.switch_skin("player");
                show_debug_message("Exited tube mode.");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for tube switch.");
        }
    }
    // Enter/Exit Ice Truck
    if (keyboard_check_pressed(ord("E"))) {
        var truck_nearby = instance_exists(obj_icetruck) && distance_to_object(obj_icetruck) < 16;
        if (instance_exists(obj_controller)) {
            if (truck_nearby && global.current_skin == "player") {
                obj_controller.switch_skin("icetruck");
            } else if (global.current_skin == "icetruck") {
                obj_controller.switch_skin("player");
            }
        } else {
            show_debug_message("ERROR: obj_controller not found for ice truck switch.");
        }
    }
    // Repair Ice Truck
    if (keyboard_check_pressed(ord("R"))) {
        if (place_meeting(x, y, obj_icetruck_broken) && 
            (obj_inventory.has_item("Wrench") || obj_inventory.has_item("Battery"))) {
            show_debug_message("Repairing ice truck...");
            if (obj_inventory.has_item("Battery")) {
                show_debug_message("DEBUG: Battery detected in inventory. Attempting to remove...");
                obj_inventory.remove_item("Battery");
            }
            show_debug_message("Battery removed after repair.");
            with (instance_place(x, y, obj_icetruck_broken)) instance_destroy();
            instance_create_layer(x, y, "Instances", obj_icetruck);
            show_debug_message("Ice truck repaired!");
        }
    }
    if (instance_exists(obj_inventory)) { if (obj_inventory.has_item("Fishing Rod")) {} }
}if (keyboard_check_pressed(ord("E"))) {
    var puffle = instance_nearest(x, y, obj_puffle);
    if (puffle != noone && distance_to_object(puffle) < 32) {
        // Check inventory for Puffle-O’s
        if (obj_inventory.has_item("Puffle O") || obj_inventory.has_item("Box Puffle O")) {
            global.selected_puffle = puffle;
            global.menu_state = "puffle_menu";
        } else {
            show_message("You need a Puffle O or Box Puffle O to interact with this puffle!");
        }
    }
}set_depth();

Thought for
50s

Expand for details

So I've got this error in my GameMaker project:

ERROR!!! :: ############################################################################################
ERROR in action number 1
of  Step Event0 for object obj_player:
Variable <unknown_object>.offset_y(100408, -2147483648) not set before reading it.
 at gml_Object_obj_player_Step_0 (line 63) - 	    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
############################################################################################
gml_Object_obj_player_Step_0 (line 63)

From the error message, it looks like the variable offset_y is not defined before it's being used in the line where the snowball is created. Similarly, offset_x might also be undefined, but the error specifically mentions offset_y.
Looking at the code, in the Step event of obj_player, there's this part:
gml

if (action_state == "throw" && action_timer == snowball_release_frame) {
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    action_timer++; // Increment timer after creating the snowball
}

The variables offset_x and offset_y are being used here, but I don't see where they are defined in the provided code. In the original code you showed earlier, there was a switch statement that set offset_x and offset_y based on throw_direction, but it seems like that part is missing in this version.
To fix this, I need to make sure that offset_x and offset_y are defined before this line. Probably, I should add the switch statement to calculate the offsets based on the throw_direction.
Let me recall how the offsets were calculated in the previous version:
gml

var offset_x = 0;
var offset_y = 0;
switch (throw_direction) {
    case RIGHT: offset_x = 12; break;
    case LEFT: offset_x = -12; break;
    case UP: offset_y = -12; break;
    case DOWN: offset_y = 12; break;
    case UP_RIGHT: offset_x = 8; offset_y = -8; break;
    case UP_LEFT: offset_x = -8; offset_y = -8; break;
    case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
    case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
}

I need to include this logic before creating the snowball. So, in the Step event, right before creating the snowball, I should calculate offset_x and offset_y.
Wait, actually, since this is inside the condition where action_state == "throw", and throw_direction is set when the throw starts, I can calculate the offsets at that time and store them in variables.
But to keep it simple, I can just calculate them inside the condition where the snowball is created.
Let me adjust the code accordingly.
Also, I notice that in the Create event, there's a line:
gml

action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5); // Reduced from 1.0 to 0.5 (half speed)

But earlier in the Create event, there's already a ds_map created for action_anim_speed with other actions. Wait, actually, in the code you provided, it seems like action_anim_speed is being reassigned here, which might overwrite the previous map. But in the context, it looks like it's being created again, which is not necessary since it's already created earlier.
Wait, looking back:
gml

// Special actions system
action_state = "none";  // "none", "dance", "wave", "sit", "jackhammer", "snowshovel"
action_timer = 0;
action_duration = 0;

// Frame data and sprite maps for special actions
action_frame_data = ds_map_create();
action_sprite_body = ds_map_create();
action_sprite_color = ds_map_create();
action_anim_speed = ds_map_create();

// Then adding entries for sit, wave, dance, jackhammer, snowshovel

// Later, after debugging message:

// Throw Snowball (28 frames, 24x24, assuming spr_throwsnowball_body at y=0-96)
ds_map_add(action_frame_data, "throw", [...]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
action_anim_speed = ds_map_create();  // This line is re-creating the map, losing previous entries
ds_map_add(action_anim_speed, "throw", 0.5); // Only adding "throw"

Ah, here's the issue: when you do action_anim_speed = ds_map_create(); again, it creates a new map, discarding the previous one that had entries for other actions like sit, wave, etc. So, only "throw" will have an animation speed, and the others will not be found, potentially causing errors later.
To fix this, you should add the "throw" animation speed to the existing map, not create a new one.
So, instead of:
gml

action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5);

It should be:
gml

ds_map_add(action_anim_speed, "throw", 0.5);

This way, you're adding to the existing map that already has speeds for other actions.
Now, back to the main error.
To resolve the undefined offset_y, I need to calculate offset_x and offset_y inside the Step event when creating the snowball.
Here's how I can modify the Step event:
gml

// Handle snowball throwing specifics
if (action_state == "throw" && action_timer == snowball_release_frame) {
    var offset_x = 0;
    var offset_y = 0;
    switch (throw_direction) {
        case RIGHT: offset_x = 12; break;
        case LEFT: offset_x = -12; break;
        case UP: offset_y = -12; break;
        case DOWN: offset_y = 12; break;
        case UP_RIGHT: offset_x = 8; offset_y = -8; break;
        case UP_LEFT: offset_x = -8; offset_y = -8; break;
        case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
        case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
    }
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    action_timer++; // Increment timer after creating the snowball
}

By adding the switch statement inside the condition, I ensure that offset_x and offset_y are defined before using them to create the snowball.
Additionally, I should make sure that throw_direction is properly set when starting the throw action. In the code, when pressing "O", it sets throw_direction = face;, which should be fine as long as face is one of the defined directions.
Wait, but in the switch statement, it handles all possible directions: RIGHT, LEFT, UP, DOWN, UP_RIGHT, UP_LEFT, DOWN_RIGHT, DOWN_LEFT. So, as long as face is one of these, it should be okay.
Another thing to check is that snowball_release_frame is correctly defined. In the Create event, it's set to 15, which should be fine.
Also, ensure that get_throw_direction is a function that returns the correct direction angle based on throw_direction.
Assuming that's all set up correctly, the main issue was the missing definition of offset_x and offset_y.
So, to summarize the fixes:
In the Create event, change:

gml

action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5);

to:
gml

ds_map_add(action_anim_speed, "throw", 0.5);

To avoid overwriting the existing map.
In the Step event, inside the condition for creating the snowball, add the calculation for offset_x and offset_y:

gml

if (action_state == "throw" && action_timer == snowball_release_frame) {
    var offset_x = 0;
    var offset_y = 0;
    switch (throw_direction) {
        case RIGHT: offset_x = 12; break;
        case LEFT: offset_x = -12; break;
        case UP: offset_y = -12; break;
        case DOWN: offset_y = 12; break;
        case UP_RIGHT: offset_x = 8; offset_y = -8; break;
        case UP_LEFT: offset_x = -8; offset_y = -8; break;
        case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
        case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
    }
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    action_timer++; // Increment timer after creating the snowball
}

With these changes, the error should be resolved, and the snowball should be created at the correct offset based on the throw direction.
Also, as a side note, in the Step event, there's a line:
gml

action_timer++; // Increment timer after creating the snowball

But actually, since action_timer is already being incremented in the else if block:
gml

action_timer += 1;

You might not need to increment it again inside the if condition. It depends on your logic. If you want the timer to advance only after the snowball is released, you might need to adjust it. But in the current setup, since the condition is action_timer == snowball_release_frame, and then you increment it, it should be fine, as the next step will have action_timer > snowball_release_frame, so it won't create another snowball.
Wait, actually, since action_timer is incremented outside the if condition, in the else if block, it's already being incremented each step. So, when action_timer == snowball_release_frame, it creates the snowball and then increments action_timer, but since it's also incremented in the outer block, it might increment twice in that step. Wait, no, in the code you provided, the increment is inside the if condition, but in the else if block, it's action_timer += 1;, which is separate.
Wait, let's check:
gml

} else if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state);
    action_timer += 1;

    // Handle snowball throwing specifics
    if (action_state == "throw" && action_timer == snowball_release_frame) {
        // calculate offsets
        var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
        snowball.direction = get_throw_direction(throw_direction);
        snowball.speed = 3;
        action_timer++; // This increments it again
    }

    // End special action
    if (action_state == "sit" && keyboard_check_pressed(ord("K"))) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Stopped sitting");
    } else if (action_timer >= action_duration && action_duration != -1) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Action " + action_state + " completed");
    }
}

So, in this code, action_timer += 1; is executed every step when action_state != "none", and inside the if condition, there's another action_timer++;. This means that when action_timer == snowball_release_frame, it will create the snowball and then increment action_timer twice in that step: once inside the if condition and once in the outer block.
This might not be intended, as it could skip a frame. To fix this, you can remove the action_timer++; inside the if condition, since the outer increment will handle it.
So, change it to:
gml

if (action_state == "throw" && action_timer == snowball_release_frame) {
    var offset_x = 0;
    var offset_y = 0;
    switch (throw_direction) {
        case RIGHT: offset_x = 12; break;
        case LEFT: offset_x = -12; break;
        case UP: offset_y = -12; break;
        case DOWN: offset_y = 12; break;
        case UP_RIGHT: offset_x = 8; offset_y = -8; break;
        case UP_LEFT: offset_x = -8; offset_y = -8; break;
        case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
        case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
    }
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3;
    // Do not increment action_timer here
}

And keep the action_timer += 1; in the outer block. This way, the timer increments consistently each step.
Additionally, you might want to ensure that the snowball is only created once, when action_timer reaches snowball_release_frame. With the current setup, since action_timer is an integer, and you're checking == snowball_release_frame, it should only be true for one step, so it should create the snowball only once.
But to be safe, you could add a flag to indicate that the snowball has been thrown, but it's probably unnecessary.
Another thing to consider is that if the animation speed is fractional, action_timer might not hit exactly snowball_release_frame, but since you're using action_timer as an integer and incrementing by 1 each step, and snowball_release_frame is an integer, it should be fine.
Wait, actually, in the code, action_timer is incremented by 1 each step, and image_speed is set based on action_anim_speed, but image_index is not directly used in this context for the throw action, I think. Wait, in the Draw event, you might be using action_timer to calculate the frame.
But in any case, for the condition action_timer == snowball_release_frame, since action_timer goes from 0 to action_duration, incrementing by 1 each step, it will pass through each integer value, so it should hit exactly snowball_release_frame.
Therefore, the fix should be sufficient.
To summarize, the steps to resolve the error are:
In the Create event, change the line where action_anim_speed is re-created to just add the "throw" entry to the existing map:

gml

// Instead of:
// action_anim_speed = ds_map_create();
// ds_map_add(action_anim_speed, "throw", 0.5);

// Do:
ds_map_add(action_anim_speed, "throw", 0.5);

In the Step event, inside the condition for creating the snowball, calculate offset_x and offset_y based on throw_direction:

gml

if (action_state == "throw" && action_timer == snowball_release_frame) {
    var offset_x = 0;
    var offset_y = 0;
    switch (throw_direction) {
        case RIGHT: offset_x = 12; break;
        case LEFT: offset_x = -12; break;
        case UP: offset_y = -12; break;
        case DOWN: offset_y = 12; break;
        case UP_RIGHT: offset_x = 8; offset_y = -8; break;
        case UP_LEFT: offset_x = -8; offset_y = -8; break;
        case DOWN_RIGHT: offset_x = 8; offset_y = 8; break;
        case DOWN_LEFT: offset_x = -8; offset_y = 8; break;
    }
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3;
}

Remove the extra action_timer++; inside the if condition, as it's already incremented in the outer block.

After making these changes, the error should be resolved, and the snowball should be created at the correct position based on the throw direction.
If you encounter any further issues, feel free to ask!

Resolving the GameMaker Error: Undefined offset_y Variable
You're encountering the following error in your GameMaker project:

ERROR!!! :: ############################################################################################
ERROR in action number 1
of  Step Event0 for object obj_player:
Variable <unknown_object>.offset_y(100408, -2147483648) not set before reading it.
at gml_Object_obj_player_Step_0 (line 63) - 	    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
############################################################################################
gml_Object_obj_player_Step_0 (line 63)

This error occurs because the variable offset_y (and potentially offset_x) is being used in your Step event without being defined beforehand. Let's analyze the issue and provide a complete solution.
Understanding the Problem
In the Step event of obj_player, you have this code:
gml

if (action_state == "throw" && action_timer == snowball_release_frame) {
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    action_timer++; // Increment timer after creating the snowball
}

Here, offset_x and offset_y are used to position the snowball relative to the player's coordinates (x and y). However, nowhere in the provided code (Create or Step event) are these variables initialized before this line, causing GameMaker to throw an error when it tries to read them.
The intent is likely to spawn the snowball at an offset from the player based on the direction they are throwing (throw_direction), but the logic to calculate these offsets is missing.
Solution
To fix this, you need to define offset_x and offset_y before creating the snowball instance. Based on typical game design patterns and the context of your code, these offsets should depend on throw_direction, which is set to the player's facing direction (face) when the throw action begins. The face variable can be one of eight directions: RIGHT, LEFT, UP, DOWN, UP_RIGHT, UP_LEFT, DOWN_RIGHT, or DOWN_LEFT.
Here’s how you can calculate the offsets:
Define Offsets Based on Direction: Use a switch statement to set offset_x and offset_y according to throw_direction.

Place the Calculation Before Instance Creation: Ensure these variables are set within the same condition where the snowball is created.

Modify the Step event code like this:
gml

if (action_state == "throw" && action_timer == snowball_release_frame) {
    // Define offsets based on throw direction
    var offset_x = 0;
    var offset_y = 0;
    switch (throw_direction) {
        case RIGHT: 
            offset_x = 12; 
            break;
        case LEFT: 
            offset_x = -12; 
            break;
        case UP: 
            offset_y = -12; 
            break;
        case DOWN: 
            offset_y = 12; 
            break;
        case UP_RIGHT: 
            offset_x = 8; 
            offset_y = -8; 
            break;
        case UP_LEFT: 
            offset_x = -8; 
            offset_y = -8; 
            break;
        case DOWN_RIGHT: 
            offset_x = 8; 
            offset_y = 8; 
            break;
        case DOWN_LEFT: 
            offset_x = -8; 
            offset_y = 8; 
            break;
    }
    // Create the snowball with the calculated offsets
    var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
    snowball.direction = get_throw_direction(throw_direction);
    snowball.speed = 3; // Reduced from 5 to 3 to slow it down
    // Note: Do not increment action_timer here; it's handled below
}

Additional Fix in the Create Event
While addressing the main error, I noticed a potential issue in your Create event related to action_anim_speed:
gml

// Throw Snowball (28 frames, 24x24, assuming spr_throwsnowball_body at y=0-96)
ds_map_add(action_frame_data, "throw", [...]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
action_anim_speed = ds_map_create();
ds_map_add(action_anim_speed, "throw", 0.5); // Reduced from 1.0 to 0.5 (half speed)

The line action_anim_speed = ds_map_create(); creates a new ds_map, overwriting the previous one that already contains animation speeds for actions like "sit", "wave", "dance", etc. This means that only the "throw" action would have an animation speed defined, potentially causing errors or unexpected behavior for other actions when ds_map_find_value(action_anim_speed, action_state) is called in the Step event.
To fix this, simply add the "throw" entry to the existing map instead of creating a new one:
gml

// Throw Snowball (28 frames, 24x24, assuming spr_throwsnowball_body at y=0-96)
ds_map_add(action_frame_data, "throw", [
    [0, 0, 24, 24], [24, 0, 24, 24], [48, 0, 24, 24], [72, 0, 24, 24], 
    [96, 0, 24, 24], [120, 0, 24, 24], [144, 0, 24, 24], [168, 0, 24, 24],
    [0, 24, 24, 24], [24, 24, 24, 24], [48, 24, 24, 24], [72, 24, 24, 24], 
    [96, 24, 24, 24], [120, 24, 24, 24], [144, 24, 24, 24], [168, 24, 24, 24],
    [0, 48, 24, 24], [24, 48, 24, 24], [48, 48, 24, 24], [72, 48, 24, 24], 
    [96, 48, 24, 24], [120, 48, 24, 24], [144, 48, 24, 24], [168, 48, 24, 24],
    [0, 72, 24, 24], [24, 72, 24, 24], [48, 72, 24, 24], [72, 72, 24, 24]
]);
ds_map_add(action_sprite_body, "throw", spr_throwsnowball_body);
ds_map_add(action_sprite_color, "throw", spr_throwsnowball_colour);
ds_map_add(action_anim_speed, "throw", 0.5); // Add to existing map

Timer Increment Adjustment
In your original Step event, the action_timer is incremented twice when the snowball is created:
Once inside the if (action_state == "throw" && action_timer == snowball_release_frame) block with action_timer++.

Once in the outer else if (action_state != "none") block with action_timer += 1.

This double increment could cause the timer to skip a frame unintentionally. Since action_timer += 1 is already incrementing the timer every step when an action is active, you should remove the additional action_timer++ inside the snowball creation block. The corrected Step event snippet becomes:
gml

} else if (action_state != "none") {
    image_speed = ds_map_find_value(action_anim_speed, action_state);
    action_timer += 1;

    // Handle snowball throwing specifics
    if (action_state == "throw" && action_timer == snowball_release_frame) {
        // Define offsets based on throw direction
        var offset_x = 0;
        var offset_y = 0;
        switch (throw_direction) {
            case RIGHT: 
                offset_x = 12; 
                break;
            case LEFT: 
                offset_x = -12; 
                break;
            case UP: 
                offset_y = -12; 
                break;
            case DOWN: 
                offset_y = 12; 
                break;
            case UP_RIGHT: 
                offset_x = 8; 
                offset_y = -8; 
                break;
            case UP_LEFT: 
                offset_x = -8; 
                offset_y = -8; 
                break;
            case DOWN_RIGHT: 
                offset_x = 8; 
                offset_y = 8; 
                break;
            case DOWN_LEFT: 
                offset_x = -8; 
                offset_y = 8; 
                break;
        }
        // Create the snowball with the calculated offsets
        var snowball = instance_create_layer(x + offset_x, y + offset_y, "Instances", obj_snowball);
        snowball.direction = get_throw_direction(throw_direction);
        snowball.speed = 3; // Reduced from 5 to 3 to slow it down
        // Timer is incremented in the outer block, so no need to increment here
    }

    // End special action
    if (action_state == "sit" && keyboard_check_pressed(ord("K"))) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Stopped sitting");
    } else if (action_timer >= action_duration && action_duration != -1) {
        action_state = "none";
        image_index = 0;
        show_debug_message("Action " + action_state + " completed");
    }
}

Verification
Offsets Defined: offset_x and offset_y are now calculated before use, resolving the original error.

Direction Handling: The switch statement covers all possible values of throw_direction (assuming RIGHT, LEFT, etc., are defined constants matching face).

Timer Logic: Removing the extra increment ensures action_timer advances consistently, and the snowball is created only once when action_timer equals snowball_release_frame (set to 15 in the Create event).

Animation Speeds: Fixing the action_anim_speed map preserves animation speeds for all actions.

Final Notes
Constants: Ensure that RIGHT, LEFT, UP, DOWN, UP_RIGHT, UP_LEFT, DOWN_RIGHT, and DOWN_LEFT are defined (e.g., as enums or constants) and match the values assigned to face and throw_direction.

Function Check: Verify that get_throw_direction(throw_direction) returns the correct angle (e.g., 0 for right, 90 for up, etc.) based on your game's coordinate system.

Testing: After applying these changes, test the snowball throw by pressing "O" while facing different directions to confirm the snowball spawns at the intended offset.

With these fixes, your error should be resolved, and the snowball throwing mechanic should work as intended. If you run into further issues, feel free to share more details!

Two throwing sprites are being drawn when the player throws a snowball and I also dont think the flipped frames are taking the offset into consideration as they are being drawn either side of the original frame

Thought for
25s

Expand for details

It sounds like there are two issues here:
Two throwing sprites are being drawn when the player throws a snowball.

Flipped frames might not be considering the correct offset, causing them to be drawn on either side of the original frame.

Let's tackle each issue step by step.
Issue 1: Two Throwing Sprites Being Drawn
This likely happens because the drawing code for the throwing animation is being executed twice, possibly due to:
Multiple draw calls in the Draw event.

**Drawing both the regular and flipped sprites unintentionally.

To fix this, ensure that only one sprite is drawn based on the current state and direction logic.
Issue 2: Flipped Frames Offset
When flipping a sprite, the offset needs to be adjusted to account for the flip. If not, the sprite might shift positions incorrectly.
For example, if the sprite is flipped horizontally, its drawing position (draw_x) should be adjusted to ensure it remains centered or positioned correctly relative to the player.
Solution
Below is an updated version of the Draw Event code that resolves both issues. It ensures:
Only one sprite is drawn for the throwing animation.

The offset is correctly adjusted for flipped sprites.

gml

// In obj_player Draw event
if (action_state == "throw") {
    var animation_type = "";
    var flip = false;

    // Determine animation type and flip based on throw_direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            animation_type = "down_right";
            flip = false;
            break;
        case UP_RIGHT:
            animation_type = "up_right";
            flip = false;
            break;
        case DOWN_LEFT:
            animation_type = "down_right";
            flip = true;
            break;
        case UP_LEFT:
            animation_type = "up_right";
            flip = true;
            break;
        case RIGHT:
            animation_type = choose("down_right", "up_right");
            flip = false;
            break;
        case LEFT:
            animation_type = choose("down_right", "up_right");
            flip = true;
            break;
        case UP:
            animation_type = "up_right";
            flip = choose(false, true); // 50% chance to flip
            break;
        case DOWN:
            animation_type = "down_right";
            flip = choose(false, true); // 50% chance to flip
            break;
    }

    // Set frame offset based on animation type
    var frame_offset = (animation_type == "down_right") ? 0 : 28; // "Throw Face Down Right" at 0, "Throw Face Up Right" at 28

    // Calculate frame index based on action_timer and image_speed
    var frames_per_animation = 28; // Assuming 28 frames per animation
    var frame_index = frame_offset + floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;

    // Calculate sprite coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust drawing position for flipping
    var draw_x = x;
    var draw_y = y;
    if (flip) {
        // Flip horizontally: adjust draw_x to account for sprite width
        draw_x = x + 24; // Assuming sprite width is 24 pixels
    }

    // Draw the sprites with flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, draw_y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, draw_y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Add your existing drawing code for other states (e.g., idle, walk) here
    draw_self(); // Placeholder for other states
}

Explanation of Changes
Single Sprite Drawing:
Ensure that only one draw_sprite_part_ext call is made for each layer (body and color). The logic now clearly selects one animation type and flip state, preventing multiple draws.

Offset Adjustment for Flipped Sprites:
When flip is true, the draw_x position is adjusted by the sprite's width (assumed to be 24 pixels). This ensures that the flipped sprite is drawn correctly relative to the player's position.

The drawing position is then centered by subtracting half the sprite width (draw_x - 12) and height (draw_y - 12), assuming the sprite is 24x24 pixels.

Frame Calculation:
The frame_index calculation uses mod frames_per_animation to loop the animation correctly within the selected range (0-27 or 28-55).

Sprite coordinates (spr_x, spr_y) are calculated based on the sprite sheet's layout (8 columns).

Additional Notes
Sprite Assumptions: This code assumes your sprite sheet has 8 columns and 7 rows (56 frames total), with "Throw Face Down Right" in frames 0-27 and "Throw Face Up Right" in frames 28-55. Adjust frame_offset and frames_per_animation if your layout differs.

Centered Drawing: The code centers the sprite by subtracting half its width and height (-12 for 24x24 sprites). Adjust these values if your sprites have different dimensions or origins.

Testing: Verify the drawing for each direction, especially the flipped states, to ensure the sprite aligns correctly with the player's position.

This should resolve both issues, ensuring only one sprite is drawn and that flipped frames are positioned correctly. Let me know if you need further adjustments!

It seems you're encountering two issues when the player throws a snowball in your game: two throwing sprites are being drawn instead of one, and flipped frames appear misaligned, likely because their offset isn’t adjusted correctly, causing them to be drawn on either side of the original frame. Let’s address both problems and provide a solution.
Problem 1: Two Throwing Sprites Being Drawn
When you throw a snowball, two sprites are appearing, which suggests that the drawing code is likely being triggered more than once or is unintentionally rendering both a regular and a flipped sprite. This could happen due to:
Multiple draw calls in your Draw event executing without proper conditions.

Logic that accidentally draws both sprite variations (e.g., regular and flipped) at the same time.

To fix this, we need to ensure that only one sprite is drawn based on the player's throwing direction and state.
Problem 2: Flipped Frames Offset Issue
When a sprite is flipped horizontally (e.g., to face left instead of right), its drawing position must be adjusted to account for the flip. If this offset isn’t corrected, the flipped sprite will appear shifted—often to the left or right of where it should be—because the sprite’s origin and width aren’t being considered properly. For example, a 24-pixel-wide sprite flipped horizontally might need its x-position adjusted by its width to keep it aligned with the player.
Solution
Here’s how to resolve both issues by updating your Draw event code in GameMaker Language (GML). The code will ensure only one sprite is drawn and that flipped sprites are positioned correctly.
Updated Draw Event Code
gml

// In obj_player Draw event
if (action_state == "throw") {
    var animation_type = "";
    var flip = false;

    // Determine animation type and flip based on throw_direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            animation_type = "down_right";
            flip = false;
            break;
        case UP_RIGHT:
            animation_type = "up_right";
            flip = false;
            break;
        case DOWN_LEFT:
            animation_type = "down_right";
            flip = true;
            break;
        case UP_LEFT:
            animation_type = "up_right";
            flip = true;
            break;
        case RIGHT:
            animation_type = choose("down_right", "up_right");
            flip = false;
            break;
        case LEFT:
            animation_type = choose("down_right", "up_right");
            flip = true;
            break;
        case UP:
            animation_type = "up_right";
            flip = choose(false, true); // Random flip
            break;
        case DOWN:
            animation_type = "down_right";
            flip = choose(false, true); // Random flip
            break;
    }

    // Set frame offset based on animation type
    var frame_offset = (animation_type == "down_right") ? 0 : 28; // Frames 0-27 for down_right, 28-55 for up_right

    // Calculate frame index based on action_timer and animation speed
    var frames_per_animation = 28; // Total frames per animation
    var frame_index = frame_offset + floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust drawing position for flipping
    var draw_x = x;
    var draw_y = y;
    if (flip) {
        draw_x = x + 24; // Adjust for sprite width when flipped (assuming 24 pixels)
    }

    // Draw the sprite layers with proper scaling for flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, draw_y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, draw_y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states (e.g., idle, walk)
    draw_self();
}

How This Fixes the Issues
Fixing Two Sprites Being Drawn
The code uses a switch statement to select one animation type (down_right or up_right) and a single flip state (true or false) based on throw_direction.

Only one pair of draw_sprite_part_ext calls is executed—one for the body sprite and one for the colored overlay—ensuring no duplicate sprites are drawn.

Fixing Flipped Frame Offsets
When flip is true, the draw_x position is increased by the sprite’s width (24 pixels here). This compensates for the horizontal flip (set by x_scale = -1 in draw_sprite_part_ext), keeping the sprite aligned with the player’s position.

The sprite is centered by subtracting half its width and height (draw_x - 12, draw_y - 12), assuming a 24x24 pixel sprite with a centered origin.

Key Assumptions
Sprite Sheet Layout: The code assumes spr_throwsnowball_body and spr_throwsnowball_colour are sprite sheets with 8 columns and at least 7 rows (56 frames total), where frames 0-27 are for "Throw Face Down Right" and 28-55 are for "Throw Face Up Right."

Sprite Size: Sprites are 24x24 pixels. Adjust the 24 values (e.g., in spr_x = col * 24 or draw_x = x + 24) if your sprites are a different size.

Variables: action_state, throw_direction, action_timer, action_anim_speed, and global.player_color are assumed to be defined elsewhere in your game.

Testing and Adjustments
Test All Directions: Check each throw_direction (e.g., DOWN_RIGHT, DOWN_LEFT, etc.) to ensure only one sprite appears and it’s positioned correctly.

Adjust Offsets: If the sprite still appears misaligned, tweak the draw_x and draw_y adjustments (e.g., change draw_x - 12 to match your sprite’s origin).

Animation Speed: Verify that ds_map_find_value(action_anim_speed, "throw") returns a sensible speed value to animate the frames properly.

This solution should eliminate the duplicate sprites and ensure flipped frames are drawn in the correct position. If you run into further issues, feel free to provide more details about your sprite setup or existing code!

for some reason the flipped drawn sprite is being drawn regardless making it look like two sprites are being drawn in the throw snowball animation

Thought for
27s

Expand for details

I apologize for the confusion. It seems there's an unintended behavior causing both the original and flipped sprite to be drawn simultaneously during the snowball throw animation. Let's break down the issue step by step and provide a solution.
Reasoning Through the Problem
The core issue is that two sprites are being drawn when the player throws a snowball, likely due to:
Incorrect conditional logic in the drawing code, causing both regular and flipped versions to be rendered unintentionally.

Misconfiguration in the flip logic, potentially drawing both flipped and non-flipped sprites due to a logic error in how flip is handled or how the frame is chosen.

Given that, let's revisit the drawing logic to ensure:
Only one sprite is drawn per frame.

The correct animation (Throw Face Down Right or Throw Face Up Right) is selected based on the player's direction.

Flipping is applied only when necessary, and the sprite's position is adjusted accordingly.

Solution
The key to fixing this is ensuring that the draw code strictly follows the player's throw_direction and flip state to select and position the sprite correctly. Here's an improved version of the Draw event code:
gml

// In obj_player Draw event
if (action_state == "throw") {
    // Determine which animation to use based on throw_direction
    var use_up_right = false;
    var flip = false;

    // Logic to decide animation and flip
    switch (throw_direction) {
        case UP_RIGHT:
        case UP_LEFT:
        case UP:
            use_up_right = true; // Use "Throw Face Up Right" animation
            break;
        case DOWN_RIGHT:
        case DOWN_LEFT:
        case DOWN:
            use_up_right = false; // Use "Throw Face Down Right" animation
            break;
        case RIGHT:
            use_up_right = choose(true, false); // 50% chance for up_right or down_right
            break;
        case LEFT:
            use_up_right = choose(true, false); // 50% chance for up_right or down_right
            break;
    }

    // Determine flip based on direction
    if (throw_direction == DOWN_LEFT || throw_direction == UP_LEFT || throw_direction == LEFT) {
        flip = true;
    } else if (throw_direction == UP && choose(true, false)) {
        flip = true; // 50% chance to flip for UP
    } else if (throw_direction == DOWN && choose(true, false)) {
        flip = true; // 50% chance to flip for DOWN
    }

    // Set frame offset based on animation type
    var frame_offset = use_up_right ? 28 : 0; // Frames 0-27 for down_right, 28-55 for up_right

    // Calculate frame index based on action_timer and animation speed
    var frames_per_animation = 28; // Total frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Apply offset for up_right

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust drawing position for flipping
    var draw_x = x;
    if (flip) {
        draw_x = x + 24; // Adjust for sprite width when flipped
    }

    // Draw the sprite layers with proper scaling for flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states (e.g., idle, walk)
    draw_self();
}

Explanation of the Fix
Animation Selection:
For directions like UP_RIGHT, UP_LEFT, and UP, we use the "Throw Face Up Right" animation.

For DOWN_RIGHT, DOWN_LEFT, and DOWN, we use "Throw Face Down Right".

For RIGHT and LEFT, there's a 50% chance to use either animation.

Flip Logic:
We flip the sprite for left-facing directions (DOWN_LEFT, UP_LEFT, LEFT).

For UP and DOWN, there's an additional 50% chance to flip the sprite.

Frame Calculation:
The frame_offset ensures the correct set of frames (0-27 or 28-55) is used based on the animation type.

The frame_index is calculated using action_timer and the animation speed, ensuring it wraps within the 28-frame range for each animation.

Position Adjustment for Flipping:
When flip is true, we adjust draw_x by the sprite's width (24 pixels) to ensure the flipped sprite remains centered on the player.

Key Points
Single Sprite: This code ensures only one sprite is drawn per frame by strictly following the throw_direction and flip logic.

Correct Positioning: The draw_x adjustment for flipped sprites prevents them from appearing offset to the side.

Testing and Fine-Tuning
Test Each Direction: Verify the animation and flip for all directions (UP, DOWN, LEFT, RIGHT, UP_RIGHT, etc.).

Offset Check: If the sprite still looks misaligned, adjust the draw_x and draw_y calculations based on your sprite's origin or size.

Animation Speed: Ensure ds_map_find_value(action_anim_speed, "throw") returns a value that makes the animation play at the desired speed.

This should resolve the issue of two sprites being drawn and ensure the flipped frames are positioned correctly. If the problem persists, let me know, and we can dive deeper!

It seems you're experiencing an issue where both the flipped and non-flipped versions of the sprite are being drawn during the snowball throw animation, making it look like two sprites appear at once. Let’s resolve this by ensuring only one sprite is drawn based on the player's direction and flip state. Below, I’ll explain the problem and provide a corrected approach.
Understanding the Problem
The issue arises because the drawing logic isn’t properly enforcing exclusivity between the flipped and non-flipped sprite states. This could happen if:
The code lacks clear conditions to draw only one sprite at a time.

The flip logic is applied incorrectly, causing both versions to render simultaneously.

To fix this, we need to:
Decide which animation to use (e.g., "Throw Face Up Right" or "Throw Face Down Right") based on the throw direction.

Determine whether the sprite should be flipped.

Draw the sprite once, with the correct scaling and position adjustments for flipping.

Solution
Here’s a corrected version of the Draw event code for your player object in GameMaker Language (GML). This ensures only one sprite is drawn during the throw animation:
gml

// In obj_player Draw event
if (action_state == "throw") {
    // Variables to control animation and flip
    var use_up_right = false; // False = "Throw Face Down Right", True = "Throw Face Up Right"
    var flip = false;         // False = normal, True = flipped horizontally

    // Decide animation and flip based on throw_direction
    switch (throw_direction) {
        case "UP_RIGHT":
        case "UP_LEFT":
        case "UP":
            use_up_right = true; // Use "Throw Face Up Right"
            break;
        case "DOWN_RIGHT":
        case "DOWN_LEFT":
        case "DOWN":
            use_up_right = false; // Use "Throw Face Down Right"
            break;
        case "RIGHT":
            use_up_right = choose(true, false); // Randomly pick animation
            break;
        case "LEFT":
            use_up_right = choose(true, false); // Randomly pick animation
            break;
    }

    // Decide if the sprite should be flipped
    if (throw_direction == "DOWN_LEFT" || throw_direction == "UP_LEFT" || throw_direction == "LEFT") {
        flip = true;
    } else if (throw_direction == "UP" && choose(true, false)) {
        flip = true; // 50% chance to flip for UP
    } else if (throw_direction == "DOWN" && choose(true, false)) {
        flip = true; // 50% chance to flip for DOWN
    }

    // Calculate the frame based on animation type
    var frame_offset = use_up_right ? 28 : 0; // Frames 0-27 for down_right, 28-55 for up_right
    var frames_per_animation = 28; // Total frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Shift to correct animation set

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust draw position for flipping (sprite width = 24)
    var draw_x = x;
    if (flip) {
        draw_x = x + 24; // Shift position when flipped to keep it centered
    }

    // Draw the sprite with proper scaling (flip ? -1 : 1 for horizontal flip)
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states (e.g., idle, walking)
    draw_self();
}

How This Fixes the Issue
Single Sprite Drawing:
The code uses draw_sprite_part_ext only once per layer (body and color), ensuring no duplicate sprites are drawn.

The flip variable controls horizontal scaling (-1 for flipped, 1 for normal), so only one orientation is rendered.

Animation Selection:
The use_up_right variable picks the correct animation set based on throw_direction.

Frame offsets (0 or 28) ensure the proper frame range is used from the sprite sheet.

Flip Logic:
The sprite is flipped only for left-facing directions or randomly for UP/DOWN, avoiding overlap with the non-flipped version.

When flipped, the draw_x position is adjusted by the sprite width (24 pixels) to keep it centered.

Positioning:
The -12 offset in draw_x - 12 and y - 12 assumes a centered sprite origin. Adjust these if your sprite’s origin is different.

Testing the Fix
To ensure this works:
Check Each Direction: Test throwing snowballs in all directions (UP, DOWN, LEFT, RIGHT, etc.) to confirm only one sprite appears.

Verify Positioning: If the sprite looks off-center when flipped, tweak the draw_x adjustment (e.g., change x + 24 to x + 12 or another value).

Animation Speed: Ensure ds_map_find_value(action_anim_speed, "throw") is set to a reasonable value (e.g., 0.2–0.5) for smooth playback.

If the Problem Persists
If you still see two sprites:
Double-check that no other draw_sprite calls occur elsewhere (e.g., in a parent object or another event).

Confirm your sprite sheet (spr_throwsnowball_body and spr_throwsnowball_colour) doesn’t have overlapping frames causing visual confusion.

Let me know, and we can refine the solution further!

This approach should resolve the issue and give you a clean, single-sprite throw animation.

Now only down right throw snowball animation is being drawn, the dounle sprite issue has been resolved

Thought for
25s

Expand for details

It sounds like you've successfully resolved the issue with two sprites being drawn, but now only the "Throw Face Down Right" animation is playing for all throw directions, instead of using the correct animation (e.g., "Throw Face Up Right" or flipped versions). Let’s figure out why this is happening and how to fix it.
Potential Causes
Based on your description, the most likely reasons for this issue are:
Incorrect Frame Offset Calculation: The code might not be properly selecting the frame offset for "Throw Face Up Right" when needed.

Logic Errors in Animation Selection: There could be a mistake in the logic that decides which animation to use based on the throw direction.

Flipping Not Applied Correctly: The flip logic might not be triggering for left-facing directions, causing the right-facing animation to play instead.

Solution
To fix this, we need to ensure that:
The correct animation ("Throw Face Down Right" or "Throw Face Up Right") is selected based on the throw direction.

The sprite is flipped correctly for left-facing directions.

The frame offset is properly calculated for the chosen animation.

Here’s an updated version of the Draw event code that ensures the correct animation and flip state are applied:
gml

// In obj_player Draw event
if (action_state == "throw") {
    // Determine animation type and flip based on throw_direction
    var use_up_right = false; // False = "Throw Face Down Right", True = "Throw Face Up Right"
    var flip = false;         // False = normal, True = flipped horizontally

    switch (throw_direction) {
        case DOWN_RIGHT:
            use_up_right = false;
            flip = false;
            break;
        case UP_RIGHT:
            use_up_right = true;
            flip = false;
            break;
        case DOWN_LEFT:
            use_up_right = false;
            flip = true;
            break;
        case UP_LEFT:
            use_up_right = true;
            flip = true;
            break;
        case RIGHT:
            use_up_right = choose(false, true); // Randomly pick animation
            flip = false;
            break;
        case LEFT:
            use_up_right = choose(false, true); // Randomly pick animation
            flip = true;
            break;
        case UP:
            use_up_right = true; // Always use "Throw Face Up Right"
            flip = choose(false, true); // Random flip
            break;
        case DOWN:
            use_up_right = false; // Always use "Throw Face Down Right"
            flip = choose(false, true); // Random flip
            break;
    }

    // Set frame offset based on animation type
    var frame_offset = use_up_right ? 28 : 0; // Frames 0-27 for down_right, 28-55 for up_right

    // Calculate frame index based on action_timer and animation speed
    var frames_per_animation = 28; // Total frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Shift to correct animation set

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust draw position for flipping (sprite width = 24)
    var draw_x = x;
    if (flip) {
        draw_x = x + 24; // Shift position when flipped
    }

    // Draw the sprite with proper scaling for flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states
    draw_self();
}

Explanation of Changes
Animation Selection (use_up_right):
For DOWN_RIGHT, DOWN_LEFT, and DOWN, we use "Throw Face Down Right" (use_up_right = false).

For UP_RIGHT, UP_LEFT, and UP, we use "Throw Face Up Right" (use_up_right = true).

For RIGHT and LEFT, we randomly choose between the two animations.

Flip Logic:
The sprite is flipped (flip = true) for DOWN_LEFT, UP_LEFT, LEFT, and randomly for UP and DOWN.

This ensures the animation faces the correct direction.

Frame Offset:
When use_up_right is true, we add 28 to the frame index to access the "Throw Face Up Right" frames (assuming they start at frame 28 in the sprite sheet).

Position Adjustment:
When flipped, draw_x is adjusted by the sprite width (24 pixels) to keep the sprite centered.

Testing the Fix
To confirm this works:
Test Each Direction: Throw snowballs while facing UP, DOWN, LEFT, RIGHT, etc., and ensure the correct animation plays.

Check Flipping: For left-facing directions, verify the sprite is flipped and positioned correctly.

Frame Offset: Confirm that "Throw Face Up Right" plays for upward directions by checking the frame index calculation.

If the issue persists, double-check:
The sprite sheet layout (e.g., frame offsets).

The values of throw_direction (ensure they match your direction constants).

The animation speed and timing to ensure frames are cycling correctly.

Let me know if you need further adjustments!

It seems that while we've fixed the issue of two sprites being drawn simultaneously, now only the "Throw Face Down Right" animation is playing for all throw directions, instead of switching to the appropriate animation (like "Throw Face Up Right") or flipping correctly for left-facing throws. Let’s resolve this so the correct animation plays based on the direction you're throwing the snowball.
Why This Is Happening
The problem suggests that the game isn’t properly selecting between the "Throw Face Down Right" and "Throw Face Up Right" animations or applying the horizontal flip for left-facing directions. This could be due to:
The animation selection logic always defaulting to "Throw Face Down Right."

The frame offset not adjusting for "Throw Face Up Right."

The sprite flip not being applied correctly for left directions.

How to Fix It
To correct this, we need to ensure that:
The game selects the right animation ("Throw Face Down Right" or "Throw Face Up Right") based on the throw direction.

The sprite is flipped horizontally for left-facing directions.

The frame offset in the sprite sheet shifts correctly between the two animations.

Here’s an updated version of the Draw event code for obj_player in GameMaker Language (GML):
gml

// In obj_player Draw event
if (action_state == "throw") {
    // Variables to determine animation and flip
    var use_up_right = false; // False = "Throw Face Down Right", True = "Throw Face Up Right"
    var flip = false;         // False = normal, True = flipped horizontally

    // Decide animation and flip based on throw_direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            use_up_right = false;
            flip = false;
            break;
        case UP_RIGHT:
            use_up_right = true;
            flip = false;
            break;
        case DOWN_LEFT:
            use_up_right = false;
            flip = true;
            break;
        case UP_LEFT:
            use_up_right = true;
            flip = true;
            break;
        case RIGHT:
            use_up_right = choose(false, true); // Randomly pick animation
            flip = false;
            break;
        case LEFT:
            use_up_right = choose(false, true); // Randomly pick animation
            flip = true;
            break;
        case UP:
            use_up_right = true; // Use "Throw Face Up Right"
            flip = choose(false, true); // Random flip
            break;
        case DOWN:
            use_up_right = false; // Use "Throw Face Down Right"
            flip = choose(false, true); // Random flip
            break;
    }

    // Set frame offset for the chosen animation
    var frame_offset = use_up_right ? 28 : 0; // Frames 0-27 for down_right, 28-55 for up_right

    // Calculate frame index based on action_timer and animation speed
    var frames_per_animation = 28; // Frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Shift to the correct animation set

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust draw position for flipping (sprite width = 24)
    var draw_x = x;
    if (flip) {
        draw_x = x + 24; // Shift position when flipped
    }

    // Draw the sprite with proper scaling for flip
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states
    draw_self();
}

What This Code Does
Animation Selection:
use_up_right decides the animation:
false: Uses "Throw Face Down Right" (frames 0-27).

true: Uses "Throw Face Up Right" (frames 28-55).

The switch statement sets this based on throw_direction.

Flip Logic:
flip is true for left-facing directions (DOWN_LEFT, UP_LEFT, LEFT) and randomly for UP and DOWN.

When flip is true, the sprite is mirrored horizontally by setting the x-scale to -1.

Frame Offset:
The frame_offset shifts the animation to the correct starting frame in the sprite sheet:
0 for "Throw Face Down Right."

28 for "Throw Face Up Right" (assuming 28 frames per animation).

Drawing:
The sprite’s position (draw_x) adjusts when flipped to keep it centered.

draw_sprite_part_ext uses the flip state (-1 or 1) to draw the sprite correctly.

How to Test the Fix
Throw in All Directions:
Face UP_RIGHT, DOWN_RIGHT, UP_LEFT, DOWN_LEFT, etc., and throw a snowball.

Check that "Throw Face Up Right" plays for upward directions and "Throw Face Down Right" for downward ones.

Verify Flipping:
For DOWN_LEFT, UP_LEFT, and LEFT, ensure the sprite is flipped horizontally.

Confirm Animation Frames:
Add a debug message (e.g., show_debug_message(frame_index)) to verify the frame index switches between 0-27 and 28-55 as expected.

If It Still Doesn’t Work
If the issue persists after applying this code:
Check Sprite Sheet: Ensure "Throw Face Up Right" starts at frame 28 and each animation has 28 frames.

Verify throw_direction: Make sure the direction constants (e.g., UP_RIGHT, DOWN_LEFT) match your game’s values.

Inspect Variables: Add debug messages like show_debug_message("Direction: " + string(throw_direction) + ", use_up_right: " + string(use_up_right)) to confirm the logic is working.

Let me know if you need further assistance!

Now both the left, right, up and down 50% sprites are being drawn regardless and the flipped frames are also being drawn. Otherwise everything works perfectly

Thought for
28s

Expand for details

It sounds like you're encountering an issue where both the flipped and non-flipped versions of the throw animation are being drawn simultaneously, even when they shouldn’t be. This can happen if the logic for selecting the animation and flip state isn’t mutually exclusive, leading to both versions being rendered at once. Below, I’ll walk through a step-by-step solution to ensure only one sprite is drawn correctly based on the throw direction.
Step-by-Step Solution
Step 1: Confirm the Animation Selection Logic
First, we need to ensure that the game correctly chooses between the "Throw Face Down Right" and "Throw Face Up Right" animations based on the throw direction. We also need to apply the flip only when necessary.
Animation Selection:
Use "Throw Face Down Right" for downward-facing directions.

Use "Throw Face Up Right" for upward-facing directions.

For cardinal directions (left, right, up, down), randomly select between the two animations with a 50% chance.

Flip Logic:
Flip the sprite horizontally for left-facing directions (DOWN_LEFT, UP_LEFT, LEFT).

For UP and DOWN, randomly flip the sprite 50% of the time to add variety.

Step 2: Prevent Multiple Draws
The issue of both flipped and non-flipped sprites being drawn suggests that the drawing code might be executing more than once or that the flip logic is incorrectly applying to both states. To fix this:
Use a single pair of draw_sprite_part_ext calls for the body and color layers.

Ensure the flip state is applied correctly to scale the sprite horizontally (-1 for flipped, 1 for normal).

Step 3: Adjust Draw Position for Flipped Sprites
When flipping a sprite horizontally, its position needs to be adjusted to keep it aligned with the player. For a sprite of width w, flipping it requires shifting its x-position by w pixels to maintain centering.
Position Adjustment:
If flipped, set draw_x = x + w, where w is the sprite width (e.g., 24 pixels).

Then, offset by half the width to center it: draw_x - w / 2.

Step 4: Implement the Corrected Code
Below is the corrected Draw event code for obj_player:
gml

// In obj_player Draw event
if (action_state == "throw") {
    // Determine animation and flip
    var use_up_right = false; // False = "Throw Face Down Right", True = "Throw Face Up Right"
    var flip = false;         // False = normal, True = flipped horizontally

    // Logic for selecting animation and flip
    switch (throw_direction) {
        case DOWN_RIGHT:
            use_up_right = false;
            flip = false;
            break;
        case UP_RIGHT:
            use_up_right = true;
            flip = false;
            break;
        case DOWN_LEFT:
            use_up_right = false;
            flip = true;
            break;
        case UP_LEFT:
            use_up_right = true;
            flip = true;
            break;
        case RIGHT:
            use_up_right = choose(false, true); // 50% chance for each animation
            flip = false;
            break;
        case LEFT:
            use_up_right = choose(false, true); // 50% chance for each animation
            flip = true;
            break;
        case UP:
            use_up_right = true; // Always use "Throw Face Up Right"
            flip = choose(false, true); // 50% chance to flip
            break;
        case DOWN:
            use_up_right = false; // Always use "Throw Face Down Right"
            flip = choose(false, true); // 50% chance to flip
            break;
    }

    // Set frame offset based on animation
    var frame_offset = use_up_right ? 28 : 0; // Adjust if your sprite sheet layout differs

    // Calculate frame index
    var frames_per_animation = 28; // Frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Shift to the correct animation set

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust draw position for flipping
    var sprite_width = 24; // Assuming 24-pixel width
    var draw_x = x;
    if (flip) {
        draw_x = x + sprite_width; // Shift position for flipped sprite
    }

    // Draw the sprite with correct scaling and positioning
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states
    draw_self();
}

Explanation of the Fix
Animation and Flip Selection:
The switch statement correctly sets use_up_right and flip based on throw_direction.

For RIGHT and LEFT, it randomly selects the animation but ensures flip is set appropriately (false for right, true for left).

For UP and DOWN, it always uses the corresponding animation and randomly flips the sprite.

Single Draw Call:
Only one pair of draw_sprite_part_ext calls is used, ensuring no duplicate sprites.

The flip state controls the horizontal scaling (-1 or 1), so only one orientation is drawn.

Position Adjustment:
When flip is true, draw_x is shifted by the sprite’s width (24 pixels), and then centered with draw_x - 12.

Testing and Verification
To confirm this works:
Test Each Direction: Throw snowballs in all directions and check that only one sprite is drawn.

Check Flipping: For left-facing throws, ensure the sprite is flipped and positioned correctly.

Verify Animation: Confirm that "Throw Face Up Right" plays for upward directions and "Throw Face Down Right" for downward ones.

If the issue persists, consider adding debug messages to track the values of use_up_right, flip, and frame_index to ensure they’re being set as expected.
This should resolve the problem, giving you a clean, single-sprite throw animation. Let me know if you need further assistance!

It seems you're experiencing an issue where both the "Throw Face Up Right" and "Throw Face Down Right" animations, as well as their flipped versions, are being drawn simultaneously for the left, right, up, and down directions, even though only one sprite should appear at a time. This is likely happening because the animation and flip logic isn’t being applied exclusively, causing multiple sprites to render. Below, I’ll provide a clear, step-by-step solution to ensure only the correct sprite is drawn based on the throw direction, while keeping everything else functioning as intended.
Understanding the Problem
From your description:
For directions like LEFT, RIGHT, UP, and DOWN, you want a 50% chance to use either the "Throw Face Up Right" or "Throw Face Down Right" animation.

For LEFT, the sprite should always be flipped horizontally, and for RIGHT, it should not be flipped.

For UP and DOWN, the flip should also be a 50% chance, but only one sprite should appear.

Currently, both animations and their flipped versions are being drawn at the same time, creating overlap.

The goal is to enforce mutually exclusive drawing: only one animation and one flip state should be active per frame.
Solution
Let’s fix this by ensuring the animation selection and flip logic are exclusive and that the drawing code renders only one sprite. Here’s how we’ll adjust the Draw event code for obj_player:
Step 1: Refine Animation and Flip Logic
We’ll use a switch statement to determine:
Which animation to use (use_up_right: true for "Throw Face Up Right", false for "Throw Face Down Right").

Whether to flip the sprite horizontally (flip: true for flipped, false for normal).

For LEFT, RIGHT, UP, and DOWN, we’ll introduce randomness while ensuring exclusive outcomes.
Step 2: Ensure Single Sprite Drawing
We’ll use a single pair of draw_sprite_part_ext calls (one for the body, one for the color overlay) and apply the flip state correctly to avoid duplicates.
Step 3: Adjust Positioning
When flipping, we’ll adjust the sprite’s draw position to keep it centered, preventing any misalignment.
Corrected Code
Here’s the updated Draw event code for obj_player:
gml

// In obj_player Draw event
if (action_state == "throw") {
    // Variables to determine animation and flip
    var use_up_right = false; // False = "Throw Face Down Right", True = "Throw Face Up Right"
    var flip = false;         // False = normal, True = flipped horizontally

    // Determine animation and flip based on throw direction
    switch (throw_direction) {
        case DOWN_RIGHT:
            use_up_right = false;
            flip = false;
            break;
        case UP_RIGHT:
            use_up_right = true;
            flip = false;
            break;
        case DOWN_LEFT:
            use_up_right = false;
            flip = true;
            break;
        case UP_LEFT:
            use_up_right = true;
            flip = true;
            break;
        case RIGHT:
            use_up_right = choose(false, true); // 50% chance for each animation
            flip = false;
            break;
        case LEFT:
            use_up_right = choose(false, true); // 50% chance for each animation
            flip = true;
            break;
        case UP:
            use_up_right = true; // Always use "Throw Face Up Right"
            flip = choose(false, true); // 50% chance to flip
            break;
        case DOWN:
            use_up_right = false; // Always use "Throw Face Down Right"
            flip = choose(false, true); // 50% chance to flip
            break;
    }

    // Set frame offset based on animation
    var frame_offset = use_up_right ? 28 : 0; // Adjust if your sprite sheet layout differs

    // Calculate frame index
    var frames_per_animation = 28; // Number of frames per animation
    var frame_index = floor(action_timer * ds_map_find_value(action_anim_speed, "throw")) mod frames_per_animation;
    frame_index += frame_offset; // Shift to the correct animation set

    // Calculate sprite sheet coordinates (assuming 24x24 sprites, 8 columns)
    var col = frame_index mod 8;
    var row = floor(frame_index / 8);
    var spr_x = col * 24;
    var spr_y = row * 24;

    // Adjust draw position for flipping
    var sprite_width = 24; // Assuming 24-pixel width
    var draw_x = x;
    if (flip) {
        draw_x = x + sprite_width; // Shift position for flipped sprite
    }

    // Draw the sprite once with correct scaling and positioning
    draw_sprite_part_ext(spr_throwsnowball_body, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, c_white, 1);
    draw_sprite_part_ext(spr_throwsnowball_colour, 0, spr_x, spr_y, 24, 24, draw_x - 12, y - 12, flip ? -1 : 1, 1, global.player_color, 1);
} else {
    // Default drawing for other states
    draw_self();
}

How This Fixes the Issue
Exclusive Animation Selection:
The switch statement sets use_up_right and flip once per frame based on throw_direction.

For RIGHT and LEFT, choose(false, true) picks one animation randomly, and flip is fixed (false for RIGHT, true for LEFT).

For UP and DOWN, the animation is fixed (true for UP, false for DOWN), and flip is randomized.

Single Draw Call:
Only one pair of draw_sprite_part_ext calls is executed, using the chosen frame_index and flip state.

The horizontal scale (flip ? -1 : 1) ensures the sprite is drawn in the correct orientation without duplicates.

Position Correction:
When flip is true, draw_x is adjusted by the sprite width (24 pixels) and then centered with -12, ensuring the flipped sprite aligns properly.

Testing the Fix
To verify this works as expected:
Throw in Each Direction: Test LEFT, RIGHT, UP, and DOWN multiple times to confirm:
Only one sprite appears per throw.

For LEFT, the sprite is always flipped; for RIGHT, it’s never flipped.

For UP and DOWN, the flip varies randomly, but only one sprite is drawn.

Check Animation Variety: Ensure LEFT and RIGHT randomly switch between "Throw Face Up Right" and "Throw Face Down Right".

Debugging (Optional): Add temporary code like draw_text(x, y - 20, string(use_up_right) + " " + string(flip)) to monitor values during testing.

If the Problem Persists
If you still see multiple sprites:
Check Sprite Sheet: Ensure spr_throwsnowball_body and spr_throwsnowball_colour don’t have overlapping frames or transparency issues causing visual duplication.

Inspect Other Events: Verify no other code (e.g., in Step or another Draw event) is drawing additional sprites.

Clear Draw State: Add draw_set_reset() or similar at the start of the Draw event to reset any lingering draw settings (if applicable in your engine).

This solution should eliminate the duplicate sprites and give you the intended 50% randomization for LEFT, RIGHT, UP, and DOWN. Let me know if you need further tweaks!
