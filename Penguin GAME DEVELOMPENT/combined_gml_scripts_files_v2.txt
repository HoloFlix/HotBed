Folder: D:\PenguinIsleProject\Penguin Isles\scripts\draw_item_card
File: draw_item_card.gml
/// @function draw_item_card(item, x, y)
/// @description Draws an item card with sprite, name, price, and description
/// @param {struct} item The item data to draw
/// @param {real} x The x position to draw at
/// @param {real} y The y position to draw at

function draw_item_card(item, card_x, card_y) {
    // Draw card background
    draw_set_color(c_dkgray);
    draw_rectangle(card_x, card_y, card_x + item_width, card_y + item_height, false);
    
    // Draw item sprite
    var sprite_scale = min((item_width - 20) / sprite_get_width(item.sprite),
                          (item_height * 0.6) / sprite_get_height(item.sprite));
    
    var sprite_x = card_x + item_width/2;
    var sprite_y = card_y + (item_height * 0.3);
    
    draw_sprite_ext(item.sprite, 0,
                   sprite_x, sprite_y,
                   sprite_scale, sprite_scale,
                   0, c_white, 1);
    
    // Draw item name
    draw_set_color(c_white);
    draw_set_halign(fa_center);
    draw_set_valign(fa_top);
    draw_set_font(fnt_shop_item);
    draw_text(card_x + item_width/2, card_y + item_height * 0.65, item.name);
    
    // Draw price
    var price_color = global.player_coins >= item.price ? c_lime : c_red;
    draw_set_color(price_color);
    draw_text(card_x + item_width/2, card_y + item_height * 0.8,
             string(item.price) + " coins");
    
    // Draw stock info if limited
    if (variable_struct_exists(item, "stock") && item.stock >= 0) {
        draw_set_color(c_yellow);
        draw_text(card_x + item_width/2, card_y + item_height * 0.9,
                 "Stock: " + string(item.stock));
    }
    
    // Draw seasonal tag if applicable
    if (variable_struct_exists(item, "seasonal") && item.seasonal) {
        draw_set_color(c_aqua);
        draw_text(card_x + item_width/2, card_y + 10, "Seasonal!");
    }
    
    // Reset draw properties
    draw_set_color(c_white);
    draw_set_halign(fa_left);
    draw_set_valign(fa_top);
    draw_set_font(-1);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_apply_equipped_items
File: scr_apply_equipped_items.gml
function apply_equipped_items() {
    if (!ds_exists(global.equipped_items, ds_type_map)) {
        show_debug_message("WARNING: global.equipped_items not initialized.");
        return;
    }

    var head_item = ds_map_find_value(global.equipped_items, "head");
    if (head_item != -1 && head_item != undefined) {
        skeleton_attachment_set("head_slot", ds_map_find_value(global.item_index_map, head_item));
        show_debug_message("Equipped head item: " + string(head_item));
    } else {
        skeleton_attachment_set("head_slot", -1); // Remove head item
        show_debug_message("No head item equipped.");
    }

    // Repeat for other item slots as needed...
}

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_camera_easing
File: scr_camera_easing.gml
/// Easing function for smooth camera transitions
function easing_out_quad(t) {
    return t * (2 - t);
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_collision_system
File: scr_collision_system.gml
/// @description Standardized Collision System
/// @function CollisionSystem
function CollisionSystem() constructor {
    // Handle basic collision checking and resolution
    static handle_collision = function(instance, axis, speed) {
        var original_pos = (axis == "x") ? instance.x : instance.y;
        var test_pos = original_pos + speed;
        
        if (place_meeting(
            (axis == "x") ? test_pos : instance.x,
            (axis == "x") ? instance.y : test_pos,
            obj_wall
        )) {
            while (!place_meeting(
                (axis == "x") ? original_pos + sign(speed) : instance.x,
                (axis == "x") ? instance.y : original_pos + sign(speed),
                obj_wall
            )) {
                original_pos += sign(speed);
            }
            return 0;
        }
        return speed;
    }
    
    // Handle sliding collision (for ice/slippery surfaces)
    static handle_sliding_collision = function(instance, xspd, yspd) {
        // Handle X collision first
        if (place_meeting(instance.x + xspd, instance.y, obj_wall)) {
            while (!place_meeting(instance.x + sign(xspd), instance.y, obj_wall)) {
                instance.x += sign(xspd);
            }
            xspd = 0;
        }
        
        // Then handle Y collision
        if (place_meeting(instance.x, instance.y + yspd, obj_wall)) {
            while (!place_meeting(instance.x, instance.y + sign(yspd), obj_wall)) {
                instance.y += sign(yspd);
            }
            yspd = 0;
        }
        
        return { xspd: xspd, yspd: yspd };
    }
    
    // Check if movement is possible
    static can_move = function(instance, x_offset, y_offset) {
        return !place_meeting(
            instance.x + x_offset,
            instance.y + y_offset,
            obj_wall
        );
    }
    
    // Find nearest free position
    static find_nearest_free_position = function(instance, max_distance) {
        var start_x = instance.x;
        var start_y = instance.y;
        
        for (var dist = 0; dist <= max_distance; dist++) {
            for (var angle = 0; angle < 360; angle += 45) {
                var test_x = start_x + lengthdir_x(dist, angle);
                var test_y = start_y + lengthdir_y(dist, angle);
                
                if (!place_meeting(test_x, test_y, obj_wall)) {
                    return { x: test_x, y: test_y };
                }
            }
        }
        
        return { x: start_x, y: start_y }; // Return original position if no free spot found
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_convert_gui_to_world
File: scr_convert_gui_to_world.gml
/// scr_convert_gui_to_world()
/// Converts GUI mouse coordinates to world coordinates
var world_x = camera_get_view_x(view_camera[0]) + (mouse_x / display_get_gui_width()) * camera_get_view_width(view_camera[0]);
var world_y = camera_get_view_y(view_camera[0]) + (mouse_y / display_get_gui_height()) * camera_get_view_height(view_camera[0]);

return [world_x, world_y];

Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_debug_actions
File: scr_debug_actions.gml
/// @function handle_action(action_name)
/// @param {string} action_name The name of the action to execute
function handle_action(action_name) {
    switch(action_name) {
        case "complete_current_quest":
            with(obj_quest_manager) {
                if (current_quest != noone) {
                    complete_quest(current_quest.id);
                }
            }
            break;
            
        case "give_all_items":
            with(obj_inventory) {
                // Add all available items
                var items = get_all_item_definitions();
                for (var i = 0; i < array_length(items); i++) {
                    add_item(items[i].id, 1);
                }
            }
            break;
            
        case "reset_player":
            with(global.player_instance) {
                x = xstart;
                y = ystart;
                state = PlayerState.IDLE;
                move_spd = base_move_spd;
                image_index = 0;
                image_speed = 1;
            }
            break;
            
        case "toggle_debug_overlay":
            global.debug_overlay = !global.debug_overlay;
            break;
            
        case "reload_room":
            room_restart();
            break;
            
        case "next_room":
            if (room_next(room) != -1) {
                room_goto_next();
            }
            break;
            
        case "previous_room":
            if (room_previous(room) != -1) {
                room_goto_previous();
            }
            break;
            
        case "save_game":
            with(obj_game_manager) {
                save_game();
            }
            break;
            
        case "load_game":
            with(obj_game_manager) {
                load_game();
            }
            break;
            
        case "toggle_grid":
            global.show_room_grid = !global.show_room_grid;
            break;
            
        case "spawn_test_npc":
            var _x = global.player_instance.x + 64;
            var _y = global.player_instance.y;
            instance_create_layer(_x, _y, "Instances", obj_npc, {
                npc_type: "test",
                npc_name: "Test NPC",
                dialogue: ["This is a test NPC.", "Created by the debug menu."],
                quest_id: noone
            });
            break;
            
        case "clear_inventory":
            with(obj_inventory) {
                clear_inventory();
            }
            break;
            
        case "toggle_collision_view":
            global.show_collisions = !global.show_collisions;
            break;
            
        case "toggle_quest_areas":
            global.show_quest_areas = !global.show_quest_areas;
            break;
            
        case "toggle_npc_paths":
            global.show_npc_paths = !global.show_npc_paths;
            break;
            
        case "toggle_hitboxes":
            global.show_hitbox = !global.show_hitbox;
            break;
    }
}

/// @function draw_debug_overlay()
function draw_debug_overlay() {
    if (!global.debug_mode) return;
    
    var debug_x = 10;
    var debug_y = 10;
    var line_height = 20;
    
    draw_set_font(fnt_debug);
    draw_set_color(c_black);
    draw_set_alpha(0.7);
    
    // Draw debug info background
    draw_rectangle(5, 5, 200, 200, false);
    
    draw_set_color(c_white);
    draw_set_alpha(1);
    
    // Draw FPS
    draw_text(debug_x, debug_y, "FPS: " + string(fps) + "/" + string(room_speed));
    debug_y += line_height;
    
    // Draw player info
    with(global.player_instance) {
        draw_text(debug_x, debug_y, "Player State: " + string(state));
        debug_y += line_height;
        draw_text(debug_x, debug_y, "Position: " + string(x) + ", " + string(y));
        debug_y += line_height;
        draw_text(debug_x, debug_y, "Speed: " + string(move_spd));
        debug_y += line_height;
    }
    
    // Draw quest info
    with(obj_quest_manager) {
        if (current_quest != noone) {
            draw_text(debug_x, debug_y, "Current Quest: " + string(current_quest.title));
            debug_y += line_height;
            draw_text(debug_x, debug_y, "Progress: " + string(current_quest.progress) + "/" + string(current_quest.target));
            debug_y += line_height;
        }
    }
    
    // Draw instance count
    draw_text(debug_x, debug_y, "Instances: " + string(instance_count));
    debug_y += line_height;
    
    // Draw room info
    draw_text(debug_x, debug_y, "Room: " + room_get_name(room));
    
    // Reset draw properties
    draw_set_font(-1);
    draw_set_color(c_white);
    draw_set_alpha(1);
}

/// @function draw_collision_view()
function draw_collision_view() {
    if (!global.show_collisions) return;
    
    // Draw solid objects
    with(all) {
        if (solid) {
            draw_set_alpha(0.5);
            draw_set_color(c_red);
            draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, false);
            draw_set_alpha(1);
            draw_set_color(c_white);
            draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, true);
        }
    }
}

/// @function draw_quest_areas()
function draw_quest_areas() {
    if (!global.show_quest_areas) return;
    
    with(obj_quest_area) {
        draw_set_alpha(0.3);
        draw_set_color(active ? c_yellow : c_blue);
        draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, false);
        draw_set_alpha(1);
        draw_set_color(c_white);
        draw_rectangle(bbox_left, bbox_top, bbox_right, bbox_bottom, true);
        draw_text(x, y - 20, quest_id);
    }
}

/// @function draw_npc_paths()
function draw_npc_paths() {
    if (!global.show_npc_paths) return;
    
    with(obj_npc) {
        if (path_exists(path)) {
            draw_set_color(c_lime);
            draw_path(path, x, y, true);
        }
        
        // Draw NPC info
        draw_set_color(c_white);
        draw_text(x, y - 30, npc_name);
        draw_text(x, y - 15, "State: " + string(state));
    }
}

/// @function draw_hitboxes()
function draw_hitboxes() {
    if (!global.show_hitbox) return;
    
    with(all) {
        if (variable_instance_exists(id, "hitbox")) {
            draw_set_alpha(0.3);
            draw_set_color(c_purple);
            draw_rectangle(x + hitbox.left, y + hitbox.top, 
                         x + hitbox.right, y + hitbox.bottom, false);
            draw_set_alpha(1);
            draw_set_color(c_white);
            draw_rectangle(x + hitbox.left, y + hitbox.top, 
                         x + hitbox.right, y + hitbox.bottom, true);
        }
    }
}

/// @function draw_room_grid()
function draw_room_grid() {
    if (!global.show_room_grid) return;
    
    var grid_size = 32; // Adjust based on your game's grid size
    var room_width = room_width;
    var room_height = room_height;
    
    draw_set_alpha(0.2);
    draw_set_color(c_gray);
    
    // Draw vertical lines
    for (var i = 0; i < room_width; i += grid_size) {
        draw_line(i, 0, i, room_height);
    }
    
    // Draw horizontal lines
    for (var i = 0; i < room_height; i += grid_size) {
        draw_line(0, i, room_width, i);
    }
    
    draw_set_alpha(1);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_game_state
File: scr_game_state.gml
/// @description Game State Management System
/// @function GameState
function GameState() constructor {
    // Core game state
    static init = function() {
        // Player state
        player = {
            x: 170,
            y: 154,
            instance: noone,
            color: c_white,
            skin: "player",
            health: 100,
            controls_enabled: true,
            face: DOWN,
            move_spd: 1
        };
        
        // Game flags
        flags = {
            is_paused: false,
            is_loading: false,
            dialogue_active: false,
            inventory_open: false,
            expanded_hud_open: false,
            debug_mode: false,
            game_started: false
        };
        
        // Room state
        room_state = {
            current_room: room_first,
            last_player_x: undefined,
            last_player_y: undefined,
            last_player_face: DOWN
        };
        
        // Initialize existing global variables for compatibility
        global.player_instance = noone;
        global.player_color = c_white;
        global.current_skin = "player";
        
        show_debug_message("GameState initialized successfully");
        return self;
    }
    
    // Update global references
    static sync_globals = function() {
        if (instance_exists(player.instance)) {
            global.player_instance = player.instance;
            global.player_x = player.x;
            global.player_y = player.y;
            global.player_color = player.color;
            global.current_skin = player.skin;
            global.player_controls_enabled = player.controls_enabled;
        }
        
        // Sync game flags
        global.is_pause_menu_active = flags.is_paused;
        global.dialogue_active = flags.dialogue_active;
        global.inventory_open = flags.inventory_open;
        global.expanded_hud_open = flags.expanded_hud_open;
        global.debug_mode = flags.debug_mode;
        global.game_started = flags.game_started;
        
        // Sync room state
        global.last_player_x = room_state.last_player_x;
        global.last_player_y = room_state.last_player_y;
        global.last_player_face = room_state.last_player_face;
    }
    
    // Update state from player instance
    static update_from_player = function() {
        if (instance_exists(player.instance)) {
            player.x = player.instance.x;
            player.y = player.instance.y;
            player.color = player.instance.image_blend;
            player.face = player.instance.face;
            player.move_spd = player.instance.move_spd;
        }
    }
    
    // Save current room state
    static save_room_state = function() {
        room_state.last_player_x = player.x;
        room_state.last_player_y = player.y;
        room_state.last_player_face = player.face;
        room_state.current_room = room;
    }
    
    // Load room state
    static load_room_state = function() {
        if (room_state.last_player_x != undefined) {
            player.x = room_state.last_player_x;
            player.y = room_state.last_player_y;
            player.face = room_state.last_player_face;
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_handle_collision
File: scr_handle_collision.gml
function handle_collision(axis, speed) {
    var sign_speed = sign(speed);
    var abs_speed = abs(speed);
    var move_dist = 0;
    var step = abs_speed;
    
    if (abs_speed == 0) return 0;
    
    while (step > 0.5) {  // Precision threshold
        if (axis == "x") {
            if (!place_meeting(x + (move_dist + step) * sign_speed, y, obj_wall)) {
                move_dist += step;
            }
        } else {
            if (!place_meeting(x, y + (move_dist + step) * sign_speed, obj_wall)) {
                move_dist += step;
            }
        }
        step /= 2;
    }
    
    if (axis == "x") x += move_dist * sign_speed;
    else y += move_dist * sign_speed;
    
    return move_dist * sign_speed;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_has_item
File: scr_has_item.gml
function has_item(item_name) {
    if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
        show_debug_message("Warning: global.inventory is not initialized or not an array.");
        global.inventory = []; // Reinitialize if invalid
        return false;
    }
    for (var i = 0; i < array_length(global.inventory); i++) {
        if (global.inventory[i] == item_name) {
            return true;
        }
    }
    return false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_globals
File: scr_init_globals.gml
function init_globals() {
	global.player_x = 170;
	global.player_y = 154;
	global.warp_target_x = undefined;
	global.warp_target_y = undefined;
	global.warp_target_face = undefined;
    global.is_pause_menu_active = false;
    global.player_instance = noone;
    global.player_health = 100;
    global.score = 0;
    global.is_game_paused = false;
    global.inventory_open = false;
    global.repair_complete = false;
    global.is_loading_game = false;
	global.expanded_hud_open = false;
    
    if (!variable_global_exists("following_puffles")) {
        global.following_puffles = ds_list_create();
    }
    if (!variable_global_exists("room_states")) {
        global.room_states = ds_map_create();
    }
    if (!variable_global_exists("active_quests")) {
        global.active_quests = ds_list_create();
    }
    if (!variable_global_exists("completed_quests")) {
        global.completed_quests = ds_list_create();
    }

	global.player_instance = noone; // Reset to noone, set later
    global.camera = instance_exists(obj_camera) ? obj_camera : instance_create_layer(0, 0, "Instances", obj_camera);
    show_debug_message("Initialized global.camera with ID: " + string(global.camera));
	
    // Initialize global.item_index_map if it doesn’t exist
    if (!variable_global_exists("item_index_map") || !ds_exists(global.item_index_map, ds_type_map)) {
        global.item_index_map = ds_map_create();
        // Populate with item names and their indices (based on spr_inventory_items)
        ds_map_add(global.item_index_map, "Beta Hat", 0);
        ds_map_add(global.item_index_map, "Party Hat", 1);
        ds_map_add(global.item_index_map, "Wrench", 2);
        ds_map_add(global.item_index_map, "Tube", 3);
        ds_map_add(global.item_index_map, "Toboggan", 4);
        ds_map_add(global.item_index_map, "Battery", 5);
        ds_map_add(global.item_index_map, "Spy Phone", 6);
        ds_map_add(global.item_index_map, "Broken Spy Phone", 7);
        ds_map_add(global.item_index_map, "EPF Phone", 8);
        ds_map_add(global.item_index_map, "Fishing Rod", 9);
        ds_map_add(global.item_index_map, "Jackhammer", 10);
        ds_map_add(global.item_index_map, "Snow Shovel", 11);
        ds_map_add(global.item_index_map, "Pizza Slice", 12);
        ds_map_add(global.item_index_map, "Puffle O", 13);
        ds_map_add(global.item_index_map, "Box Puffle O", 14);
        ds_map_add(global.item_index_map, "Fish", 15);
        ds_map_add(global.item_index_map, "Mullet", 16);
        ds_map_add(global.item_index_map, "Wood", 17);
        ds_map_add(global.item_index_map, "Snow", 18);
        show_debug_message("Initialized global.item_index_map with item mappings.");
    }

	global.equipped_items = ds_map_create();
    show_debug_message("Initialized global.equipped_items.");
    
    if (!variable_global_exists("item_type_map") || !ds_exists(global.item_type_map, ds_type_map)) {
        global.item_type_map = ds_map_create();
        ds_map_add(global.item_type_map, 0, "head"); // Beta Hat
        ds_map_add(global.item_type_map, 1, "head"); // Party Hat
        // Add other items as needed
        show_debug_message("Initialized global.item_type_map.");
    }
    if (!variable_global_exists("inventory") || !is_array(global.inventory)) {
        global.inventory = array_create(42, -1); // Assuming inventory size is 42
        show_debug_message("Initialized global.inventory as an array of size 42.");
    }
    if (!variable_global_exists("equipped_items") || !ds_exists(global.equipped_items, ds_type_map)) {
        global.equipped_items = ds_map_create();
        ds_map_add(global.equipped_items, "head", -1);
        ds_map_add(global.equipped_items, "face", -1);
        ds_map_add(global.equipped_items, "neck", -1);
        ds_map_add(global.equipped_items, "body", -1);
        ds_map_add(global.equipped_items, "hand", -1);
        ds_map_add(global.equipped_items, "feet", -1);
        show_debug_message("Initialized global.equipped_items as ds_map.");
    }
    
    show_debug_message("Global variables initialized via init_globals.");
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_init_sprites
File: scr_init_sprites.gml
function init_sprites(right, up, left, down, up_right, up_left, down_right, down_left) {
    sprite[RIGHT] = right;
    sprite[UP] = up;
    sprite[LEFT] = left;
    sprite[DOWN] = down;
    sprite[UP_RIGHT] = up_right;
    sprite[UP_LEFT] = up_left;
    sprite[DOWN_RIGHT] = down_right;
    sprite[DOWN_LEFT] = down_left;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_load_game
File: scr_load_game.gml
function load_game() {
    init_globals();
    
    // Check for save file
    if (!file_exists("savegame.sav")) {
        show_debug_message("No save file found.");
        return false;
    }

    // Read save file
    var file = file_text_open_read("savegame.sav");
    if (file == -1) {
        show_debug_message("ERROR: Failed to open save file.");
        return false;
    }

    var json = file_text_read_string(file);
    file_text_close(file);
    
    try {
        var save_data = json_parse(json);
        
        // Validate save data version
        if (!variable_struct_exists(save_data, "version")) {
            throw "Save file missing version information";
        }
        
        // Version compatibility check (can be expanded for future versions)
        if (save_data.version != "1.0.0") {
            show_debug_message("WARNING: Save file version mismatch. Attempting to load anyway.");
        }

        global.is_loading_game = true;
        
        // Load player data
        if (variable_struct_exists(save_data, "player")) {
            var player_data = save_data.player;
            
            // Load basic player properties
            global.player_x = player_data.x;
            global.player_y = player_data.y;
            global.current_skin = player_data.skin;
            global.player_color = player_data.color;
            global.last_player_face = player_data.face;
            global.expanded_hud_open = player_data.expanded_hud_open;
            
            // Load inventory
            if (variable_struct_exists(player_data, "inventory")) {
                if (is_array(player_data.inventory)) {
                    global.inventory = player_data.inventory;
                } else {
                    show_debug_message("WARNING: Invalid inventory data format");
                    global.inventory = array_create(42, -1);
                }
            }
            
            // Load equipped items
            if (variable_struct_exists(player_data, "equipped_items")) {
                var equipped_string = player_data.equipped_items;
                if (is_string(equipped_string)) {
                    var equipped_buffer = buffer_create(32, buffer_grow, 1);
                    buffer_base64_decode_ext(equipped_buffer, equipped_string, 0);
                    buffer_seek(equipped_buffer, buffer_seek_start, 0);
                    
                    // Clear and repopulate equipped items
                    ds_map_clear(global.equipped_items);
                    var slots = ["head", "face", "neck", "body", "hand", "feet"];
                    for (var i = 0; i < array_length(slots); i++) {
                        var item = buffer_read(equipped_buffer, buffer_s32);
                        ds_map_add(global.equipped_items, slots[i], item);
                    }
                    
                    buffer_delete(equipped_buffer);
                } else {
                    show_debug_message("WARNING: Invalid equipped_items format");
                }
            }
        }
        
        // Load game state
        if (variable_struct_exists(save_data, "game_state")) {
            var game_state = save_data.game_state;
            
            // Load room states
            if (variable_struct_exists(game_state, "room_states")) {
                ds_map_clear(global.room_states);
                var room_states = game_state.room_states;
                var keys = variable_struct_get_names(room_states);
                for (var i = 0; i < array_length(keys); i++) {
                    ds_map_add(global.room_states, keys[i], room_states[$ keys[i]]);
                }
            }
            
            // Load quests
            if (variable_struct_exists(game_state, "active_quests")) {
                ds_list_clear(global.active_quests);
                array_copy_to_list(game_state.active_quests, global.active_quests);
            }
            if (variable_struct_exists(game_state, "completed_quests")) {
                ds_list_clear(global.completed_quests);
                array_copy_to_list(game_state.completed_quests, global.completed_quests);
            }
            
            // Set target room for loading
            global.target_room = game_state.current_room;
        }
        
        // Transition to initialization room
        room_goto(rm_init);
        show_debug_message("Game loaded successfully.");
        return true;
        
    } catch (error) {
        show_debug_message("ERROR loading save file: " + string(error));
        
        // Try to load backup if available
        if (file_exists("savegame.bak")) {
            show_debug_message("Attempting to load backup save file...");
            file = file_text_open_read("savegame.bak");
            if (file != -1) {
                json = file_text_read_string(file);
                file_text_close(file);
                save_data = json_parse(json);
                // ... (same loading logic as above)
                show_debug_message("Backup save file loaded successfully.");
                return true;
            }
        }
        return false;
    }
}

// Helper function to copy array to ds_list
function array_copy_to_list(arr, list) {
    if (!is_array(arr) || !ds_exists(list, ds_type_list)) return;
    for (var i = 0; i < array_length(arr); i++) {
        ds_list_add(list, arr[i]);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_macros
File: scr_macros.gml
#macro RIGHT 0
#macro UP 1
#macro LEFT 2
#macro DOWN 3
#macro UP_RIGHT 4
#macro UP_LEFT 5
#macro DOWN_RIGHT 6
#macro DOWN_LEFT 7
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_music_function
File: scr_music_function.gml
function set_song_ingame( _song, _fadeOutCurrentSong = 0, _fadeIn = 0 )
{
	//_song = set to any song (including "noone" to stop or fade the track out)
	//_fadeOutCurrentSong = time (in frames) the current song (if playing) will take to fade out
	//_fadeIn = time (in frames) the target song (if not "noone" will take to fade in

	with ( obj_musicmanager )
	{
		targetSongAsset = _song;
		endFadeOutTime = _fadeOutCurrentSong;
		startFadeInTime = _fadeIn;
	}
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_notification_system
File: scr_notification_system.gml
/// @description Enhanced Notification System for displaying messages to the player
function NotificationSystem() constructor {
    notifications = ds_list_create();
    stacked_notifications = ds_map_create();
    
    // Notification settings
    notification_lifetime = 5; // seconds
    notification_fade_time = 0.5; // seconds
    max_notifications = 5;
    stack_similar = true;
    enable_sounds = true;
    enable_animations = true;
    
    // Animation settings
    animation_speed = 0.2;
    slide_distance = 50;
    
    /// @function init()
    static init = function() {
        show_debug_message("Initializing Enhanced Notification System");
        return self;
    }
    
    /// @function cleanup()
    static cleanup = function() {
        ds_list_destroy(notifications);
        ds_map_destroy(stacked_notifications);
    }
    
    /// @function add_notification(text, [type="info"], [priority=1], [stackable=true])
    static add_notification = function(_text, _type = "info", _priority = 1, _stackable = true) {
        // Check for stacking if enabled and notification is stackable
        if (stack_similar && _stackable) {
            var stack_key = _text + "_" + _type;
            if (ds_map_exists(stacked_notifications, stack_key)) {
                var stacked = stacked_notifications[? stack_key];
                stacked.count++;
                stacked.creation_time = current_time;
                stacked.alpha = 1;
                play_notification_sound(_type);
                return;
            }
        }
        
        // Create new notification
        var notification = {
            text: _text,
            type: _type,
            priority: _priority,
            creation_time: current_time,
            alpha: 0, // Start invisible for fade-in
            y_offset: slide_distance, // Start offset for slide animation
            count: 1,
            stackable: _stackable,
            clicked: false
        };
        
        // Add to list and sort by priority
        ds_list_add(notifications, notification);
        sort_notifications();
        
        // Add to stacked notifications if stackable
        if (stack_similar && _stackable) {
            ds_map_add(stacked_notifications, _text + "_" + _type, notification);
        }
        
        // Remove oldest if we exceed max
        while (ds_list_size(notifications) > max_notifications) {
            var oldest = notifications[| 0];
            if (oldest.stackable) {
                ds_map_delete(stacked_notifications, oldest.text + "_" + oldest.type);
            }
            ds_list_delete(notifications, 0);
        }
        
        play_notification_sound(_type);
        show_debug_message("Notification added: " + _text + " (Priority: " + string(_priority) + ")");
    }
    
    /// @function play_notification_sound(type)
    static play_notification_sound = function(_type) {
        if (!enable_sounds) return;
        
        switch(_type) {
            case "quest":
                audio_play_sound(snd_quest_notification, 10, false);
                break;
            case "achievement":
                audio_play_sound(snd_achievement_notification, 10, false);
                break;
            case "warning":
                audio_play_sound(snd_warning_notification, 10, false);
                break;
            default: // info
                audio_play_sound(snd_info_notification, 10, false);
                break;
        }
    }
    
    /// @function sort_notifications()
    static sort_notifications = function() {
        var size = ds_list_size(notifications);
        for (var i = 0; i < size - 1; i++) {
            for (var j = i + 1; j < size; j++) {
                if (notifications[| i].priority < notifications[| j].priority) {
                    var temp = notifications[| i];
                    notifications[| i] = notifications[| j];
                    notifications[| j] = temp;
                }
            }
        }
    }
    
    /// @function update()
    static update = function() {
        var current_notifications = ds_list_size(notifications);
        var i = 0;
        
        while (i < current_notifications) {
            var notification = notifications[| i];
            var age = (current_time - notification.creation_time) / 1000; // Convert to seconds
            
            // Handle animations
            if (enable_animations) {
                // Fade in
                notification.alpha = min(1, notification.alpha + animation_speed);
                
                // Slide in
                notification.y_offset = max(0, notification.y_offset - (slide_distance * animation_speed));
            } else {
                notification.alpha = 1;
                notification.y_offset = 0;
            }
            
            // Check for removal conditions
            var should_remove = false;
            
            // Remove if clicked
            if (notification.clicked) {
                should_remove = true;
            }
            // Remove if lifetime exceeded
            else if (age >= notification_lifetime) {
                // Start fading out
                var fade_progress = (age - notification_lifetime) / notification_fade_time;
                notification.alpha = max(0, 1 - fade_progress);
                
                // Remove if completely faded
                if (notification.alpha <= 0) {
                    should_remove = true;
                }
            }
            
            // Remove notification if needed
            if (should_remove) {
                if (notification.stackable) {
                    ds_map_delete(stacked_notifications, notification.text + "_" + notification.type);
                }
                ds_list_delete(notifications, i);
                current_notifications--;
                continue;
            }
            i++;
        }
    }
    
    /// @function check_notification_click()
    static check_notification_click = function() {
        if (!mouse_check_button_pressed(mb_left)) return;
        
        var gui_width = display_get_gui_width();
        var gui_height = display_get_gui_height();
        var margin = 20;
        var notification_height = 40;
        var spacing = 5;
        var mouse_gui_x = device_mouse_x_to_gui(0);
        var mouse_gui_y = device_mouse_y_to_gui(0);
        
        for (var i = 0; i < ds_list_size(notifications); i++) {
            var notification = notifications[| i];
            var y_pos = gui_height - margin - ((notification_height + spacing) * (i + 1)) + notification.y_offset;
            
            // Check if mouse is within notification bounds
            if (point_in_rectangle(mouse_gui_x, mouse_gui_y,
                margin, y_pos,
                gui_width - margin, y_pos + notification_height)) {
                notification.clicked = true;
                break;
            }
        }
    }
    
    /// @function draw()
    static draw = function() {
        check_notification_click();
        
        var gui_width = display_get_gui_width();
        var gui_height = display_get_gui_height();
        var margin = 20;
        var padding = 10;
        var notification_height = 40;
        var spacing = 5;
        
        draw_set_font(fnt_notification);
        
        for (var i = 0; i < ds_list_size(notifications); i++) {
            var notification = notifications[| i];
            var y_pos = gui_height - margin - ((notification_height + spacing) * (i + 1)) + notification.y_offset;
            
            // Set color based on type
            var bg_color, text_color, border_color;
            switch(notification.type) {
                case "quest":
                    bg_color = make_color_rgb(0, 100, 200);
                    border_color = make_color_rgb(50, 150, 255);
                    text_color = c_white;
                    break;
                case "achievement":
                    bg_color = make_color_rgb(255, 215, 0);
                    border_color = make_color_rgb(255, 235, 100);
                    text_color = c_black;
                    break;
                case "warning":
                    bg_color = make_color_rgb(200, 0, 0);
                    border_color = make_color_rgb(255, 50, 50);
                    text_color = c_white;
                    break;
                default: // info
                    bg_color = make_color_rgb(50, 50, 50);
                    border_color = make_color_rgb(100, 100, 100);
                    text_color = c_white;
                    break;
            }
            
            // Draw background with priority indicator
            draw_set_alpha(notification.alpha * 0.9);
            draw_set_color(bg_color);
            draw_rectangle(margin, y_pos, 
                gui_width - margin, y_pos + notification_height, false);
            
            // Draw priority indicator
            var indicator_width = 3;
            draw_set_color(border_color);
            draw_rectangle(margin, y_pos, 
                margin + indicator_width, y_pos + notification_height, false);
            
            // Draw border
            draw_set_alpha(notification.alpha);
            draw_set_color(border_color);
            draw_rectangle(margin, y_pos, 
                gui_width - margin, y_pos + notification_height, true);
            
            // Draw text
            draw_set_color(text_color);
            draw_set_valign(fa_middle);
            draw_set_halign(fa_left);
            var display_text = notification.text;
            if (notification.count > 1) {
                display_text += " (x" + string(notification.count) + ")";
            }
            draw_text(margin + padding + indicator_width, y_pos + notification_height/2, display_text);
            
            // Draw close button
            var close_x = gui_width - margin - padding - 16;
            var close_y = y_pos + notification_height/2 - 8;
            draw_set_color(text_color);
            draw_set_alpha(notification.alpha * 0.7);
            draw_line_width(close_x, close_y, close_x + 16, close_y + 16, 2);
            draw_line_width(close_x + 16, close_y, close_x, close_y + 16, 2);
        }
        
        // Reset drawing properties
        draw_set_alpha(1);
        draw_set_color(c_white);
        draw_set_valign(fa_top);
        draw_set_halign(fa_left);
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_puffle
File: scr_puffle.gml
/// @function get_puffle_sprite_data(direction)
/// @param direction - The facing direction (e.g., DOWN, LEFT)
/// @returns Array [base_subimage, xscale]
function get_puffle_sprite_data(direction) {
    switch (direction) {
        case DOWN: return [0, 1];       // Row 1: Subimages 0-7
        case DOWN_LEFT: return [8, 1];  // Row 2: Subimages 8-15
        case LEFT: return [16, 1];      // Row 3: Subimages 16-23
        case UP_LEFT: return [24, 1];   // Row 4: Subimages 24-31
        case UP: return [32, 1];        // Row 5: Subimages 32-39
        case DOWN_RIGHT: return [8, -1]; // Use Down-Left, flipped
        case RIGHT: return [16, -1];    // Use Left, flipped
        case UP_RIGHT: return [24, -1]; // Use Up-Left, flipped
        default: return [0, 1];         // Default to Down
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_puffle_tricks
File: scr_puffle_tricks.gml
/// @function perform_trick(trick_name)
/// @description Makes the puffle perform a specific trick
/// @param {string} trick_name The name of the trick to perform
function perform_trick(trick_name) {
    var original_state = state;
    state = PuffleState.PLAYING;
    
    switch(trick_name) {
        case "backflip":
            // Perform backflip animation
            image_angle = 0;
            var flip_duration = 30;
            var angle_per_step = 360 / flip_duration;
            
            for(var i = 0; i < flip_duration; i++) {
                image_angle += angle_per_step;
                if (i == flip_duration - 1) image_angle = 0;
            }
            break;
            
        case "spin":
            // Perform spin animation
            var spin_speed = 15;
            var spin_duration = 60;
            
            for(var i = 0; i < spin_duration; i++) {
                image_angle += spin_speed;
                if (i == spin_duration - 1) image_angle = 0;
            }
            break;
            
        case "roll":
            // Perform roll animation
            var roll_distance = 32;
            var roll_speed = 2;
            var roll_direction = face;
            
            var move_x = lengthdir_x(roll_speed, roll_direction);
            var move_y = lengthdir_y(roll_speed, roll_direction);
            
            for(var i = 0; i < roll_distance; i++) {
                if (!place_meeting(x + move_x, y + move_y, obj_wall)) {
                    x += move_x;
                    y += move_y;
                }
                image_angle += 15;
            }
            image_angle = 0;
            break;
            
        case "jump":
            // Perform jump animation
            var jump_height = 16;
            var jump_duration = 30;
            var original_y = y;
            
            for(var i = 0; i < jump_duration; i++) {
                var t = i / jump_duration;
                y = original_y - sin(t * pi) * jump_height;
                if (i == jump_duration - 1) y = original_y;
            }
            break;
            
        case "wave":
            // Perform wave animation
            show_emote("wave");
            break;
            
        case "dance":
            // Perform dance animation
            state = PuffleState.DANCING;
            dance_timer = 120;
            break;
            
        case "bounce":
            // Perform bounce animation
            var bounce_count = 3;
            var bounce_height = 8;
            var bounce_duration = 20;
            var original_y = y;
            
            for(var b = 0; b < bounce_count; b++) {
                for(var i = 0; i < bounce_duration; i++) {
                    var t = i / bounce_duration;
                    y = original_y - sin(t * pi) * bounce_height;
                    if (i == bounce_duration - 1) y = original_y;
                }
            }
            break;
            
        case "twirl":
            // Perform twirl animation
            var twirl_duration = 45;
            var original_scale = image_xscale;
            
            for(var i = 0; i < twirl_duration; i++) {
                var t = i / twirl_duration;
                image_xscale = original_scale * cos(t * pi * 2);
                if (i == twirl_duration - 1) image_xscale = original_scale;
            }
            break;
    }
    
    // Return to original state after trick
    state = original_state;
}

/// @function show_emote(emote_type)
/// @description Shows an emote above the puffle
/// @param {string} emote_type The type of emote to show
function show_emote(emote_type) {
    switch(emote_type) {
        case "happy":
            emote_sprite = spr_emote_happy;
            break;
        case "hungry":
            emote_sprite = spr_emote_hungry;
            break;
        case "sleepy":
            emote_sprite = spr_emote_sleepy;
            break;
        case "wave":
            emote_sprite = spr_emote_wave;
            break;
        case "wake":
            emote_sprite = spr_emote_wake;
            break;
    }
    emote_timer = emote_duration;
}

/// @function learn_trick()
/// @description Attempts to teach the puffle a new trick based on level and personality
function learn_trick() {
    var all_tricks = ["backflip", "spin", "roll", "jump", "wave", "dance", "bounce", "twirl"];
    var learnable_tricks = [];
    
    // Filter out tricks the puffle already knows
    for(var i = 0; i < array_length(all_tricks); i++) {
        var trick = all_tricks[i];
        if (ds_list_find_index(known_tricks, trick) == -1) {
            array_push(learnable_tricks, trick);
        }
    }
    
    // Check if there are any tricks left to learn
    if (array_length(learnable_tricks) > 0) {
        // Higher playfulness increases chance of learning tricks
        if (random(1) < 0.3 + (personality.playfulness * 0.2)) {
            var new_trick = learnable_tricks[irandom(array_length(learnable_tricks) - 1)];
            ds_list_add(known_tricks, new_trick);
            show_emote("happy");
            return true;
        }
    }
    return false;
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_quest_system
File: scr_quest_system.gml
/// @description Quest System for managing game quests and objectives
/// @function QuestSystem

function QuestSystem() constructor {
    static init = function() {
        show_debug_message("Initializing Quest System");
        return self;
    }
    
    // Quest status enums
    enum QuestStatus {
        NOT_STARTED,
        IN_PROGRESS,
        COMPLETED,
        FAILED
    }
    
    // Quest objective types
    enum QuestObjectiveType {
        COLLECT,
        TALK_TO,
        VISIT_LOCATION,
        PERFORM_ACTION,
        MINI_GAME
    }
    
    // Initialize quest data structures
    static initialize = function() {
        quest_definitions = ds_map_create();
        active_quests = ds_list_create();
        completed_quests = ds_list_create();
        quest_progress = ds_map_create();
        
        // Register with resource manager
        with(global.resource_manager) {
            set_structure("quest_definitions", other.quest_definitions);
            set_structure("active_quests", other.active_quests);
            set_structure("completed_quests", other.completed_quests);
            set_structure("quest_progress", other.quest_progress);
        }
    }
    
    // Define a new quest
    static define_quest = function(quest_id, quest_data) {
        ds_map_add(quest_definitions, quest_id, {
            title: quest_data.title,
            description: quest_data.description,
            objectives: quest_data.objectives,
            rewards: quest_data.rewards,
            prerequisites: quest_data.prerequisites,
            next_quests: quest_data.next_quests,
            is_main_quest: quest_data.is_main_quest ?? false,
            min_level: quest_data.min_level ?? 1,
            time_limit: quest_data.time_limit ?? -1
        });
    }
    
    // Start a quest
    static start_quest = function(quest_id) {
        if (!ds_map_exists(quest_definitions, quest_id)) {
            show_debug_message("Quest " + string(quest_id) + " does not exist!");
            return false;
        }
        
        var quest = quest_definitions[? quest_id];
        
        // Check prerequisites
        if (array_length(quest.prerequisites) > 0) {
            for (var i = 0; i < array_length(quest.prerequisites); i++) {
                var prereq = quest.prerequisites[i];
                if (!ds_list_find_index(completed_quests, prereq) != -1) {
                    show_debug_message("Prerequisites not met for quest " + string(quest_id));
                    return false;
                }
            }
        }
        
        // Check level requirement
        if (quest.min_level > global.game_state.player.level) {
            show_debug_message("Player level too low for quest " + string(quest_id));
            return false;
        }
        
        // Initialize quest progress
        var progress_data = {
            status: QuestStatus.IN_PROGRESS,
            start_time: current_time,
            objectives_progress: array_create(array_length(quest.objectives), 0),
            time_remaining: quest.time_limit
        };
        
        ds_map_add(quest_progress, quest_id, progress_data);
        ds_list_add(active_quests, quest_id);
        
        show_debug_message("Started quest: " + quest.title);
        return true;
    }
    
    // Update quest progress
    static update_quest_progress = function(quest_id, objective_index, progress) {
        if (!ds_map_exists(quest_progress, quest_id)) return false;
        
        var quest_data = quest_definitions[? quest_id];
        var progress_data = quest_progress[? quest_id];
        
        if (objective_index >= array_length(quest_data.objectives)) return false;
        
        progress_data.objectives_progress[objective_index] = progress;
        
        // Check if quest is completed
        var all_completed = true;
        for (var i = 0; i < array_length(quest_data.objectives); i++) {
            var objective = quest_data.objectives[i];
            if (progress_data.objectives_progress[i] < objective.required_amount) {
                all_completed = false;
                break;
            }
        }
        
        if (all_completed) {
            complete_quest(quest_id);
        }
        
        return true;
    }
    
    // Complete a quest
    static complete_quest = function(quest_id) {
        if (!ds_map_exists(quest_progress, quest_id)) return false;
        
        var quest_data = quest_definitions[? quest_id];
        var progress_data = quest_progress[? quest_id];
        
        // Update status
        progress_data.status = QuestStatus.COMPLETED;
        
        // Move from active to completed
        var index = ds_list_find_index(active_quests, quest_id);
        if (index != -1) {
            ds_list_delete(active_quests, index);
        }
        ds_list_add(completed_quests, quest_id);
        
        // Grant rewards
        grant_quest_rewards(quest_data.rewards);
        
        // Start next quests if any
        if (array_length(quest_data.next_quests) > 0) {
            for (var i = 0; i < array_length(quest_data.next_quests); i++) {
                start_quest(quest_data.next_quests[i]);
            }
        }
        
        show_debug_message("Completed quest: " + quest_data.title);
        return true;
    }
    
    // Grant quest rewards
    static grant_quest_rewards = function(rewards) {
        with(global.game_state) {
            // Add experience
            if (variable_struct_exists(rewards, "experience")) {
                player.experience += rewards.experience;
            }
            
            // Add coins
            if (variable_struct_exists(rewards, "coins")) {
                player.coins += rewards.coins;
            }
            
            // Add items
            if (variable_struct_exists(rewards, "items")) {
                for (var i = 0; i < array_length(rewards.items); i++) {
                    var item = rewards.items[i];
                    global.inventory.add_item(item.name, item.count);
                }
            }
        }
    }
    
    // Check quest status
    static get_quest_status = function(quest_id) {
        if (!ds_map_exists(quest_progress, quest_id)) {
            return QuestStatus.NOT_STARTED;
        }
        return quest_progress[? quest_id].status;
    }
    
    // Get active quest list
    static get_active_quests = function() {
        var quest_list = [];
        for (var i = 0; i < ds_list_size(active_quests); i++) {
            var quest_id = active_quests[| i];
            var quest_data = quest_definitions[? quest_id];
            var progress_data = quest_progress[? quest_id];
            
            array_push(quest_list, {
                id: quest_id,
                title: quest_data.title,
                description: quest_data.description,
                progress: progress_data.objectives_progress,
                objectives: quest_data.objectives,
                is_main_quest: quest_data.is_main_quest
            });
        }
        return quest_list;
    }
    
    // Update quest timers
    static update = function() {
        var current_timestamp = current_time;
        
        for (var i = 0; i < ds_list_size(active_quests); i++) {
            var quest_id = active_quests[| i];
            var quest_data = quest_definitions[? quest_id];
            var progress_data = quest_progress[? quest_id];
            
            if (quest_data.time_limit > 0) {
                var elapsed_time = (current_timestamp - progress_data.start_time) / 1000; // Convert to seconds
                progress_data.time_remaining = max(0, quest_data.time_limit - elapsed_time);
                
                if (progress_data.time_remaining <= 0) {
                    fail_quest(quest_id);
                }
            }
        }
    }
    
    // Fail a quest
    static fail_quest = function(quest_id) {
        if (!ds_map_exists(quest_progress, quest_id)) return false;
        
        var progress_data = quest_progress[? quest_id];
        progress_data.status = QuestStatus.FAILED;
        
        var index = ds_list_find_index(active_quests, quest_id);
        if (index != -1) {
            ds_list_delete(active_quests, index);
        }
        
        show_debug_message("Failed quest: " + quest_definitions[? quest_id].title);
        return true;
    }
    
    // Cleanup
    static cleanup = function() {
        ds_map_destroy(quest_definitions);
        ds_list_destroy(active_quests);
        ds_list_destroy(completed_quests);
        ds_map_destroy(quest_progress);
    }
    
    // Initialize on creation
    initialize();
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_resource_manager
File: scr_resource_manager.gml
/// @description Resource Management System
/// @function ResourceManager
function ResourceManager() constructor {
    static init = function() {
        // Initialize data structures with compatibility layer
        data_structures = {
            following_puffles: undefined,
            room_states: undefined,
            active_quests: undefined,
            completed_quests: undefined,
            quest_progress: undefined,
            quest_definitions: undefined,
            equipped_items: undefined,
            item_player_sprites: undefined,
            item_object_map: undefined,
            item_index_map: undefined
        };
        
        // Initialize or preserve existing data structures
        init_data_structure("following_puffles", ds_type_list);
        init_data_structure("room_states", ds_type_map);
        init_data_structure("active_quests", ds_type_list);
        init_data_structure("completed_quests", ds_type_list);
        init_data_structure("quest_progress", ds_type_map);
        init_data_structure("quest_definitions", ds_type_map);
        init_data_structure("equipped_items", ds_type_map);
        init_data_structure("item_player_sprites", ds_type_map);
        init_data_structure("item_object_map", ds_type_map);
        init_data_structure("item_index_map", ds_type_map);
        
        show_debug_message("ResourceManager initialized successfully");
        return self;
    }
    
    // Initialize or preserve a single data structure
    static init_data_structure = function(name, type) {
        var global_name = "global." + name;
        
        if (variable_global_exists(name)) {
            // Preserve existing structure if valid
            var existing_struct = variable_global_get(name);
            if (ds_exists(existing_struct, type)) {
                data_structures[$ name] = existing_struct;
                show_debug_message("Preserved existing " + name);
                return;
            }
        }
        
        // Create new structure
        switch(type) {
            case ds_type_list:
                data_structures[$ name] = ds_list_create();
                break;
            case ds_type_map:
                data_structures[$ name] = ds_map_create();
                break;
        }
        
        // Set global reference
        variable_global_set(name, data_structures[$ name]);
        show_debug_message("Created new " + name);
    }
    
    // Clean up all data structures
    static cleanup = function() {
        var names = variable_struct_get_names(data_structures);
        for (var i = 0; i < array_length(names); i++) {
            var name = names[i];
            var structure = data_structures[$ name];
            
            if (structure != undefined) {
                if (ds_exists(structure, ds_type_list)) {
                    ds_list_destroy(structure);
                    show_debug_message("Destroyed list: " + name);
                }
                else if (ds_exists(structure, ds_type_map)) {
                    ds_map_destroy(structure);
                    show_debug_message("Destroyed map: " + name);
                }
            }
        }
        show_debug_message("ResourceManager cleanup complete");
    }
    
    // Get a data structure safely
    static get_structure = function(name) {
        return data_structures[$ name];
    }
    
    // Check if a structure exists and is valid
    static structure_exists = function(name, type) {
        var structure = data_structures[$ name];
        return (structure != undefined && ds_exists(structure, type));
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_room_state
File: scr_room_state.gml
function save_room_state(room_id) {
    show_debug_message("Saving state for room: " + room_get_name(room_id));
    var room_name = room_get_name(room_id);
    if (ds_map_exists(global.room_states, room_name)) {
        var old_list = ds_map_find_value(global.room_states, room_name);
        if (ds_exists(old_list, ds_type_list)) {
            ds_list_destroy(old_list);
        }
    }
    var state_list = ds_list_create();
    ds_map_replace(global.room_states, room_name, state_list);

    with (all) {
        if (variable_instance_exists(id, "is_savable") && is_savable && object_index != obj_player && object_index != obj_player_tube) {
            if (object_index == obj_puffle && variable_instance_get(id, "following_player") == true) {
                continue;
            }
            var state = {
                object_index: object_index,
                x: x,
                y: y,
                direction: variable_instance_exists(id, "face") ? variable_instance_get(id, "face") : 0
            };
            if (object_index == obj_icetruck || object_index == obj_icetruck_broken) {
                state.repair_required = variable_instance_exists(id, "repair_required") ? variable_instance_get(id, "repair_required") : false;
                state.is_driveable = variable_instance_exists(id, "is_driveable") ? variable_instance_get(id, "is_driveable") : false;
            } else if (object_index == obj_dropped_item) {
                var item_type = variable_instance_get(id, "item_type");
                state.item_type = (item_type != undefined) ? item_type : "";
            } else if (object_index == obj_puffle) {
                state.following_player = variable_instance_exists(id, "following_player") ? variable_instance_get(id, "following_player") : false;
                var color = variable_instance_get(id, "color");
                state.color = (color != undefined) ? color : "";
                var puffle_state = variable_instance_get(id, "state");
                state.state = (puffle_state != undefined) ? puffle_state : "";
            }
            ds_list_add(state_list, state);
        }
    }
    show_debug_message("Saved state for room: " + room_name + " with " + string(ds_list_size(state_list)) + " objects.");
}

function load_room_state(room_id) {
    var room_name = room_get_name(room_id);
    if (ds_map_exists(global.room_states, room_name)) {
        var state_list = ds_map_find_value(global.room_states, room_name);
        if (ds_exists(state_list, ds_type_list)) {
            with (all) {
                if (variable_instance_exists(id, "is_savable") && is_savable && object_index != obj_player && object_index != obj_player_tube) {
                    if (object_index == obj_puffle && variable_instance_get(id, "following_player") == true) {
                        continue;
                    }
                    instance_destroy();
                }
            }
            for (var i = 0; i < ds_list_size(state_list); i++) {
                var state = state_list[| i];
                var inst;
                if (state.object_index == obj_puffle && state.following_player) {
                    if (ds_list_find_index(global.following_puffles, id) == -1) {
                        inst = instance_create_layer(state.x, state.y, "Instances", state.object_index);
                        ds_list_add(global.following_puffles, inst);
                    } else {
                        continue;
                    }
                } else {
                    inst = instance_create_layer(state.x, state.y, "Instances", state.object_index);
                }
                if (variable_instance_exists(inst, "face")) {
                    inst.face = state.direction;
                }
                if (state.object_index == obj_icetruck || state.object_index == obj_icetruck_broken) {
                    inst.repair_required = state.repair_required;
                    inst.is_driveable = state.is_driveable;
                } else if (state.object_index == obj_dropped_item) {
                    inst.item_type = state.item_type;
                } else if (state.object_index == obj_puffle) {
                    inst.following_player = state.following_player;
                    inst.color = state.color;
                    inst.state = state.state;
                    switch (inst.color) {
                        case "red": inst.image_blend = make_color_rgb(255, 0, 0); break;
                        case "blue": inst.image_blend = make_color_rgb(0, 0, 255); break;
                        case "green": inst.image_blend = make_color_rgb(0, 255, 0); break;
                        case "yellow": inst.image_blend = make_color_rgb(255, 255, 0); break;
                        default: inst.image_blend = c_white;
                    }
                    if (inst.following_player) {
                        inst.state = PuffleState.FOLLOWING;
                        inst.persistent = true;
                    }
                }
                show_debug_message("Loaded " + object_get_name(state.object_index) + " at (" + string(state.x) + ", " + string(state.y) + ")");
            }
            show_debug_message("Loaded state for room: " + room_name);
        }
    } else {
        show_debug_message("No saved state found for room: " + room_name);
    }
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_room_transition
File: scr_room_transition.gml
/// @description Room Transition Management System
/// @function RoomTransitionManager

function RoomTransitionManager() constructor {
    // Transition states
    enum TRANSITION_STATE {
        NONE,
        FADING_OUT,
        CHANGING_ROOM,
        FADING_IN,
        ERROR
    }
    
    // Configuration
    transition_speed = 0.05;
    fade_alpha = 0;
    current_state = TRANSITION_STATE.NONE;
    error_message = "";
    transition_color = c_black;
    
    // Transition data
    transition_data = {
        source_room: noone,
        target_room: noone,
        player_x: undefined,
        player_y: undefined,
        player_face: undefined,
        callback: undefined
    };
    
    /// @function start_transition
    /// @param {room} target_room The room to transition to
    /// @param {real} [target_x] Optional x position for the player
    /// @param {real} [target_y] Optional y position for the player
    /// @param {real} [target_face] Optional facing direction for the player
    /// @param {function} [callback] Optional callback to run after transition
    static start_transition = function(target_room, target_x = undefined, target_y = undefined, target_face = undefined, callback = undefined) {
        try {
            // Validate parameters
            if (!room_exists(target_room)) {
                throw "Invalid target room specified";
            }
            
            // Store transition data
            transition_data.source_room = room;
            transition_data.target_room = target_room;
            transition_data.player_x = target_x;
            transition_data.player_y = target_y;
            transition_data.player_face = target_face;
            transition_data.callback = callback;
            
            // Start transition
            current_state = TRANSITION_STATE.FADING_OUT;
            show_debug_message("Starting room transition to: " + room_get_name(target_room));
            
            // Save current room state if not loading
            if (!global.game_state.flags.is_loading) {
                save_room_state(room);
            }
            
            return true;
        } catch (error) {
            error_message = "Transition error: " + string(error);
            current_state = TRANSITION_STATE.ERROR;
            show_debug_message(error_message);
            return false;
        }
    }
    
    /// @function update
    /// @description Updates the transition state and handles room changes
    static update = function() {
        try {
            switch(current_state) {
                case TRANSITION_STATE.FADING_OUT:
                    fade_alpha = min(fade_alpha + transition_speed, 1);
                    if (fade_alpha >= 1) {
                        current_state = TRANSITION_STATE.CHANGING_ROOM;
                        perform_room_change();
                    }
                    break;
                    
                case TRANSITION_STATE.CHANGING_ROOM:
                    // Room change is handled in perform_room_change()
                    break;
                    
                case TRANSITION_STATE.FADING_IN:
                    fade_alpha = max(fade_alpha - transition_speed, 0);
                    if (fade_alpha <= 0) {
                        current_state = TRANSITION_STATE.NONE;
                        if (transition_data.callback != undefined) {
                            transition_data.callback();
                        }
                    }
                    break;
                    
                case TRANSITION_STATE.ERROR:
                    // Handle error state (maybe show error message)
                    fade_alpha = 0;
                    break;
            }
        } catch (error) {
            error_message = "Update error: " + string(error);
            current_state = TRANSITION_STATE.ERROR;
            show_debug_message(error_message);
        }
    }
    
    /// @function perform_room_change
    /// @description Internal function to handle the actual room change
    static perform_room_change = function() {
        try {
            // Update game state
            with(global.game_state) {
                room_state.current_room = other.transition_data.target_room;
                if (other.transition_data.player_x != undefined) {
                    player.x = other.transition_data.player_x;
                    player.y = other.transition_data.player_y;
                }
                if (other.transition_data.player_face != undefined) {
                    player.face = other.transition_data.player_face;
                }
            }
            
            // Perform room transition
            room_goto(transition_data.target_room);
            
            // Update state
            current_state = TRANSITION_STATE.FADING_IN;
            
        } catch (error) {
            error_message = "Room change error: " + string(error);
            current_state = TRANSITION_STATE.ERROR;
            show_debug_message(error_message);
        }
    }
    
    /// @function draw_transition
    /// @description Draws the transition effect
    static draw_transition = function() {
        if (current_state != TRANSITION_STATE.NONE) {
            draw_set_alpha(fade_alpha);
            draw_set_color(transition_color);
            draw_rectangle(0, 0, display_get_gui_width(), display_get_gui_height(), false);
            draw_set_alpha(1);
            
            // Draw error message if in error state
            if (current_state == TRANSITION_STATE.ERROR) {
                draw_set_color(c_red);
                draw_set_halign(fa_center);
                draw_set_valign(fa_middle);
                draw_text(display_get_gui_width()/2, display_get_gui_height()/2, error_message);
            }
        }
    }
    
    /// @function is_transitioning
    /// @description Returns whether a transition is in progress
    /// @returns {boolean}
    static is_transitioning = function() {
        return current_state != TRANSITION_STATE.NONE;
    }
    
    show_debug_message("RoomTransitionManager initialized");
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_save_game
File: scr_save_game.gml
function save_game() {
    // Create save data structure with version control
    var save_data = {
        version: "1.0.0",
        timestamp: date_current_datetime(),
        player: {
            x: global.player_x,
            y: global.player_y,
            skin: global.current_skin,
            color: global.player_color,
            face: global.last_player_face,
            expanded_hud_open: global.expanded_hud_open,
            inventory: global.inventory,
            equipped_items: undefined  // Will be set below
        },
        game_state: {
            current_room: room,
            active_quests: ds_list_to_array(global.active_quests),
            completed_quests: ds_list_to_array(global.completed_quests),
            room_states: ds_map_to_struct(global.room_states)
        }
    };

    // Handle equipped items
    if (ds_exists(global.equipped_items, ds_type_map)) {
        var equipped_buffer = buffer_create(32, buffer_grow, 1);
        buffer_seek(equipped_buffer, buffer_seek_start, 0);
        
        // Write equipped items to buffer
        var slots = ["head", "face", "neck", "body", "hand", "feet"];
        for (var i = 0; i < array_length(slots); i++) {
            var item = ds_map_find_value(global.equipped_items, slots[i]);
            buffer_write(equipped_buffer, buffer_s32, item ?? -1);
        }
        
        // Convert buffer to base64 string for storage
        buffer_seek(equipped_buffer, buffer_seek_start, 0);
        var equipped_string = buffer_base64_encode(equipped_buffer, 0, buffer_tell(equipped_buffer));
        buffer_delete(equipped_buffer);
        
        save_data.player.equipped_items = equipped_string;
    }

    // Create backup of previous save if it exists
    if (file_exists("savegame.sav")) {
        file_copy("savegame.sav", "savegame.bak");
    }

    // Save to file
    var file = file_text_open_write("savegame.sav");
    if (file != -1) {
        var json_string = json_stringify(save_data);
        file_text_write_string(file, json_string);
        file_text_close(file);
        show_debug_message("Game saved successfully with version " + save_data.version);
        return true;
    } else {
        show_debug_message("ERROR: Failed to open save file for writing");
        return false;
    }
}

// Helper function to convert ds_list to array
function ds_list_to_array(list) {
    if (!ds_exists(list, ds_type_list)) return [];
    var arr = array_create(ds_list_size(list));
    for (var i = 0; i < ds_list_size(list); i++) {
        arr[i] = list[| i];
    }
    return arr;
}

// Helper function to convert ds_map to struct
function ds_map_to_struct(map) {
    if (!ds_exists(map, ds_type_map)) return {};
    var struct = {};
    var key = ds_map_find_first(map);
    while (!is_undefined(key)) {
        variable_struct_set(struct, string(key), map[? key]);
        key = ds_map_find_next(map, key);
    }
    return struct;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_save_load_system
File: scr_save_load_system.gml
/// @description Save/Load System for managing game state
/// @function SaveLoadSystem

function SaveLoadSystem() constructor {
    static init = function() {
        show_debug_message("Initializing Save/Load System");
        return self;
    }
    
    // Save game state to file
    static save_game = function(slot_number) {
        var save_data = {
            // Player state
            player: {
                x: global.game_state.player.x,
                y: global.game_state.player.y,
                face: global.game_state.player.face,
                color: global.game_state.player.color,
                skin: global.game_state.player.skin,
                health: global.game_state.player.health,
                move_spd: global.game_state.player.move_spd
            },
            
            // Game flags
            flags: global.game_state.flags,
            
            // Room state
            room_state: global.game_state.room_state,
            
            // Resource data
            resources: {
                following_puffles: ds_list_to_array(global.resource_manager.get_structure("following_puffles")),
                room_states: ds_map_to_struct(global.resource_manager.get_structure("room_states")),
                active_quests: ds_list_to_array(global.resource_manager.get_structure("active_quests")),
                completed_quests: ds_list_to_array(global.resource_manager.get_structure("completed_quests")),
                quest_progress: ds_map_to_struct(global.resource_manager.get_structure("quest_progress")),
                equipped_items: ds_map_to_struct(global.resource_manager.get_structure("equipped_items"))
            },
            
            // Save metadata
            metadata: {
                version: "1.0",
                timestamp: date_current_datetime(),
                play_time: global.play_time
            }
        };
        
        // Convert save data to string
        var save_string = json_stringify(save_data);
        
        // Create save directory if it doesn't exist
        var save_dir = "saves";
        if (!directory_exists(save_dir)) {
            directory_create(save_dir);
        }
        
        // Save to file
        var file = file_text_open_write(save_dir + "/save_" + string(slot_number) + ".sav");
        if (file != -1) {
            file_text_write_string(file, save_string);
            file_text_close(file);
            show_debug_message("Game saved successfully to slot " + string(slot_number));
            return true;
        }
        
        show_debug_message("Failed to save game to slot " + string(slot_number));
        return false;
    }
    
    // Load game state from file
    static load_game = function(slot_number) {
        var save_dir = "saves";
        var file = file_text_open_read(save_dir + "/save_" + string(slot_number) + ".sav");
        
        if (file != -1) {
            var save_string = file_text_read_string(file);
            file_text_close(file);
            
            try {
                var save_data = json_parse(save_string);
                
                // Verify save data version
                if (save_data.metadata.version != "1.0") {
                    show_debug_message("Warning: Save data version mismatch");
                }
                
                // Update game state
                with(global.game_state) {
                    // Update player state
                    player = save_data.player;
                    
                    // Update flags
                    flags = save_data.flags;
                    
                    // Update room state
                    room_state = save_data.room_state;
                }
                
                // Update resource manager
                with(global.resource_manager) {
                    // Convert arrays back to lists
                    array_to_ds_list(save_data.resources.following_puffles, get_structure("following_puffles"));
                    array_to_ds_list(save_data.resources.active_quests, get_structure("active_quests"));
                    array_to_ds_list(save_data.resources.completed_quests, get_structure("completed_quests"));
                    
                    // Convert structs back to maps
                    struct_to_ds_map(save_data.resources.room_states, get_structure("room_states"));
                    struct_to_ds_map(save_data.resources.quest_progress, get_structure("quest_progress"));
                    struct_to_ds_map(save_data.resources.equipped_items, get_structure("equipped_items"));
                }
                
                // Update global variables
                global.play_time = save_data.metadata.play_time;
                
                show_debug_message("Game loaded successfully from slot " + string(slot_number));
                return true;
            } catch(e) {
                show_debug_message("Error loading save data: " + string(e));
            }
        }
        
        show_debug_message("Failed to load game from slot " + string(slot_number));
        return false;
    }
    
    // Helper function to convert ds_list to array
    static ds_list_to_array = function(list) {
        var arr = array_create(ds_list_size(list));
        for (var i = 0; i < ds_list_size(list); i++) {
            arr[i] = list[| i];
        }
        return arr;
    }
    
    // Helper function to convert array to ds_list
    static array_to_ds_list = function(arr, list) {
        ds_list_clear(list);
        for (var i = 0; i < array_length(arr); i++) {
            ds_list_add(list, arr[i]);
        }
    }
    
    // Helper function to convert ds_map to struct
    static ds_map_to_struct = function(map) {
        var struct = {};
        var key = ds_map_find_first(map);
        while (ds_map_exists(map, key)) {
            variable_struct_set(struct, string(key), map[? key]);
            key = ds_map_find_next(map, key);
        }
        return struct;
    }
    
    // Helper function to convert struct to ds_map
    static struct_to_ds_map = function(struct, map) {
        ds_map_clear(map);
        var names = variable_struct_get_names(struct);
        for (var i = 0; i < array_length(names); i++) {
            var name = names[i];
            ds_map_add(map, name, variable_struct_get(struct, name));
        }
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_set_depth
File: scr_set_depth.gml
// scr_set_depth.gml
function set_depth() {
    depth = -bbox_bottom;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_shop_management
File: scr_shop_management.gml
/// @function init_shop_system()
/// @description Initialize the shop system and create item databases
function init_shop_system() {
    // Initialize global variables if they don't exist
    if (!variable_global_exists("shop_items")) {
        global.shop_items = ds_map_create();
        global.shop_items[? SHOP_TYPE.CLOTHING] = ds_map_create();
        global.shop_items[? SHOP_TYPE.FURNITURE] = ds_map_create();
        global.shop_items[? SHOP_TYPE.SPECIAL] = ds_map_create();
        global.shop_items[? SHOP_TYPE.SEASONAL] = ds_map_create();
    }
    
    // Initialize default items
    init_clothing_shop();
    init_furniture_shop();
    init_special_shop();
    init_seasonal_shop();
}

/// @function init_clothing_shop()
/// @description Initialize clothing shop items
function init_clothing_shop() {
    var shop = global.shop_items[? SHOP_TYPE.CLOTHING];
    
    // Add default clothing items
    add_shop_item(shop, "basic_hat", {
        name: "Basic Hat",
        sprite: spr_basic_hat,
        price: 100,
        description: "A simple hat to keep you warm",
        wearable: true,
        slot: "head"
    });
    
    add_shop_item(shop, "winter_coat", {
        name: "Winter Coat",
        sprite: spr_winter_coat,
        price: 250,
        description: "Cozy winter coat",
        wearable: true,
        slot: "body"
    });
    
    // Add more clothing items as needed
}

/// @function init_furniture_shop()
/// @description Initialize furniture shop items
function init_furniture_shop() {
    var shop = global.shop_items[? SHOP_TYPE.FURNITURE];
    
    add_shop_item(shop, "ice_chair", {
        name: "Ice Chair",
        sprite: spr_ice_chair,
        price: 150,
        description: "A chair made of ice",
        placeable: true
    });
    
    add_shop_item(shop, "snow_table", {
        name: "Snow Table",
        sprite: spr_snow_table,
        price: 200,
        description: "A table made of packed snow",
        placeable: true
    });
    
    // Add more furniture items as needed
}

/// @function init_special_shop()
/// @description Initialize special shop items
function init_special_shop() {
    var shop = global.shop_items[? SHOP_TYPE.SPECIAL];
    
    add_shop_item(shop, "fishing_rod", {
        name: "Fishing Rod",
        sprite: spr_fishing_rod,
        price: 500,
        description: "For ice fishing",
        usable: true
    });
    
    add_shop_item(shop, "snowball_maker", {
        name: "Snowball Maker",
        sprite: spr_snowball_maker,
        price: 300,
        description: "Makes perfect snowballs",
        usable: true
    });
    
    // Add more special items as needed
}

/// @function init_seasonal_shop()
/// @description Initialize seasonal shop items
function init_seasonal_shop() {
    var shop = global.shop_items[? SHOP_TYPE.SEASONAL];
    
    // Add seasonal items based on current month
    var current_month = current_datetime_get_month();
    
    // Winter items (December - February)
    if (current_month >= 12 || current_month <= 2) {
        add_shop_item(shop, "christmas_hat", {
            name: "Christmas Hat",
            sprite: spr_christmas_hat,
            price: 400,
            description: "Festive hat for the holidays",
            wearable: true,
            slot: "head",
            seasonal: true
        });
    }
    
    // Spring items (March - May)
    if (current_month >= 3 && current_month <= 5) {
        add_shop_item(shop, "spring_umbrella", {
            name: "Spring Umbrella",
            sprite: spr_spring_umbrella,
            price: 350,
            description: "Protection from spring showers",
            wearable: true,
            slot: "accessory",
            seasonal: true
        });
    }
    
    // Add more seasonal items as needed
}

/// @function add_shop_item(shop_map, item_id, item_data)
/// @description Add an item to a shop
/// @param {ds_map} shop_map The shop to add the item to
/// @param {string} item_id The unique identifier for the item
/// @param {struct} item_data The item data structure
function add_shop_item(shop_map, item_id, item_data) {
    if (!ds_map_exists(shop_map, item_id)) {
        shop_map[? item_id] = item_data;
    }
}

/// @function get_shop_items(shop_type)
/// @description Get all items from a specific shop type
/// @param {real} shop_type The type of shop to get items from
/// @returns {ds_map} Map of items in the shop
function get_shop_items(shop_type) {
    return global.shop_items[? shop_type];
}

/// @function update_seasonal_shop()
/// @description Update seasonal shop items based on current month
function update_seasonal_shop() {
    var shop = global.shop_items[? SHOP_TYPE.SEASONAL];
    ds_map_clear(shop);
    init_seasonal_shop();
}

/// @function cleanup_shop_system()
/// @description Clean up shop system resources
function cleanup_shop_system() {
    if (variable_global_exists("shop_items")) {
        var shop_types = ds_map_keys_to_array(global.shop_items);
        for (var i = 0; i < array_length(shop_types); i++) {
            ds_map_destroy(global.shop_items[? shop_types[i]]);
        }
        ds_map_destroy(global.shop_items);
    }
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_shop_system
File: scr_shop_system.gml
/// @description Shop System Scripts

// Shop Types Enum
enum ShopType {
    CLOTHING,
    FURNITURE,
    SPECIAL,
    SEASONAL
}

/// @function init_shop_system()
function init_shop_system() {
    // Initialize global shop variables
    global.player_coins = 500; // Starting coins
    global.shop_inventory = ds_map_create();
    global.seasonal_items = ds_list_create();
    
    // Initialize different shop types
    init_clothing_shop();
    init_furniture_shop();
    init_special_shop();
    init_seasonal_shop();
}

/// @function init_clothing_shop()
function init_clothing_shop() {
    var clothing_items = ds_map_create();
    
    // Add clothing items with their properties
    add_shop_item(clothing_items, "Beta Hat", 100, spr_beta_hat, "A rare beta tester hat", true);
    add_shop_item(clothing_items, "Party Hat", 50, spr_party_hat, "Perfect for celebrations", true);
    add_shop_item(clothing_items, "Snow Gear", 150, spr_snow_gear, "Keep warm in style", true);
    add_shop_item(clothing_items, "Ninja Suit", 500, spr_ninja_suit, "Become one with the shadows", true);
    
    global.shop_inventory[? ShopType.CLOTHING] = clothing_items;
}

/// @function init_furniture_shop()
function init_furniture_shop() {
    var furniture_items = ds_map_create();
    
    // Add furniture items
    add_shop_item(furniture_items, "Lamp", 75, spr_lamp, "A cozy lamp for your igloo", false);
    add_shop_item(furniture_items, "Small Bush", 30, spr_small_bushes, "Add some greenery", false);
    add_shop_item(furniture_items, "Crates", 45, spr_crates, "Storage with style", false);
    
    global.shop_inventory[? ShopType.FURNITURE] = furniture_items;
}

/// @function init_special_shop()
function init_special_shop() {
    var special_items = ds_map_create();
    
    // Add special items
    add_shop_item(special_items, "EPF Phone", 1000, spr_epfphone_item, "Top secret gadget", true);
    add_shop_item(special_items, "Puffle Whistle", 250, spr_pufflewhistle_item, "Call your puffle friends", true);
    add_shop_item(special_items, "Starter Card Deck", 300, spr_starterdeck_item, "Begin your Card-Jitsu journey", true);
    
    global.shop_inventory[? ShopType.SPECIAL] = special_items;
}

/// @function init_seasonal_shop()
function init_seasonal_shop() {
    var seasonal_items = ds_map_create();
    global.shop_inventory[? ShopType.SEASONAL] = seasonal_items;
    
    // Seasonal items will be updated through update_seasonal_shop()
}

/// @function add_shop_item(shop_inventory, name, price, sprite, description, is_wearable)
function add_shop_item(shop_inventory, name, price, sprite, description, is_wearable) {
    var item = {
        name: name,
        price: price,
        sprite: sprite,
        description: description,
        is_wearable: is_wearable,
        discount: 0,
        stock: -1 // -1 means unlimited
    };
    
    shop_inventory[? name] = item;
}

/// @function update_seasonal_shop()
function update_seasonal_shop() {
    var seasonal = global.shop_inventory[? ShopType.SEASONAL];
    ds_map_clear(seasonal);
    
    var current_month = current_datetime_get_month();
    
    switch(current_month) {
        case 12: // December - Winter
        case 1:
        case 2:
            add_shop_item(seasonal, "Winter Scarf", 75, spr_winter_scarf, "Stay warm and stylish", true);
            add_shop_item(seasonal, "Ice Crown", 200, spr_ice_crown, "Rule the winter wonderland", true);
            break;
            
        case 3: // Spring
        case 4:
        case 5:
            add_shop_item(seasonal, "Flower Crown", 100, spr_flower_crown, "Welcome spring!", true);
            add_shop_item(seasonal, "Rain Boots", 80, spr_rain_boots, "Splash in style", true);
            break;
            
        case 6: // Summer
        case 7:
        case 8:
            add_shop_item(seasonal, "Sunglasses", 90, spr_sunglasses, "Cool shades for summer", true);
            add_shop_item(seasonal, "Beach Hat", 70, spr_beach_hat, "Perfect for the beach", true);
            break;
            
        case 9: // Fall
        case 10:
        case 11:
            add_shop_item(seasonal, "Leaf Crown", 85, spr_leaf_crown, "Autumn royalty", true);
            add_shop_item(seasonal, "Cozy Sweater", 120, spr_cozy_sweater, "Perfect for fall", true);
            break;
    }
}

/// @function purchase_item(shop_type, item_name)
function purchase_item(shop_type, item_name) {
    var shop = global.shop_inventory[? shop_type];
    if (!ds_map_exists(shop, item_name)) {
        show_debug_message("Item doesn't exist: " + item_name);
        return false;
    }
    
    var item = shop[? item_name];
    var final_price = item.price * (1 - item.discount);
    
    if (global.player_coins >= final_price) {
        // Check if item is in stock
        if (item.stock != 0) {
            // Deduct coins
            global.player_coins -= final_price;
            
            // Add to inventory
            with(obj_inventory) {
                add_item(item_name);
            }
            
            // Update stock if limited
            if (item.stock > 0) {
                item.stock--;
            }
            
            // Play purchase sound
            audio_play_sound(snd_purchase, 1, false);
            
            return true;
        }
    }
    
    return false;
}

/// @function get_shop_items(shop_type)
function get_shop_items(shop_type) {
    if (ds_map_exists(global.shop_inventory, shop_type)) {
        return global.shop_inventory[? shop_type];
    }
    return noone;
}

/// @function apply_discount(shop_type, item_name, discount_percent)
function apply_discount(shop_type, item_name, discount_percent) {
    var shop = global.shop_inventory[? shop_type];
    if (ds_map_exists(shop, item_name)) {
        var item = shop[? item_name];
        item.discount = clamp(discount_percent / 100, 0, 1);
    }
}

/// @function set_item_stock(shop_type, item_name, stock)
function set_item_stock(shop_type, item_name, stock) {
    var shop = global.shop_inventory[? shop_type];
    if (ds_map_exists(shop, item_name)) {
        var item = shop[? item_name];
        item.stock = stock;
    }
}

/// @function cleanup_shop_system()
function cleanup_shop_system() {
    // Clean up all shop data structures
    var shop_types = ds_map_keys_to_array(global.shop_inventory);
    for (var i = 0; i < array_length(shop_types); i++) {
        var shop = global.shop_inventory[? shop_types[i]];
        ds_map_destroy(shop);
    }
    
    ds_map_destroy(global.shop_inventory);
    ds_list_destroy(global.seasonal_items);
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_shop_types
File: scr_shop_types.gml
/// @description Enumeration for different shop types

enum SHOP_TYPE {
    CLOTHING,
    FURNITURE,
    SPECIAL,
    SEASONAL
} 
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_skin_switch
File: scr_skin_switch.gml
function switch_skin(new_skin) {
    if (global.skin_switching) return;
    global.skin_switching = true;

    var player_x = global.player_instance != noone ? global.player_instance.x : global.last_player_x;
    var player_y = global.player_instance != noone ? global.player_instance.y : global.last_player_y;
    var player_face = DOWN;

    if (instance_exists(global.player_instance)) {
        if (variable_instance_exists(global.player_instance, "face")) {
            player_face = global.player_instance.face;
        }
        instance_destroy(global.player_instance);
    }

    var new_instance = noone;
    for (var i = 0; i < array_length(global.skins); i++) {
        if (global.skins[i].name == new_skin) {
            new_instance = instance_create_layer(player_x, player_y, "Instances", global.skins[i].object);
            global.current_skin = new_skin;
            break;
        }
    }

    if (new_instance == noone) {
        new_instance = instance_create_layer(player_x, player_y, "Instances", obj_player);
        global.current_skin = "player";
    }

    if (variable_instance_exists(new_instance, "face")) {
        new_instance.face = player_face;
    }

    global.player_instance = new_instance;
    camera_set_view_target(global.camera, global.player_instance);
    global.skin_switching = false;
}
Folder: D:\PenguinIsleProject\Penguin Isles\scripts\scr_throwable
File: scr_throwable.gml
/// @description Throwable object handling and physics
function init_throwable(throw_speed = 8, gravity_force = 0.5, bounce_factor = 0.6) {
    // Initialize throwing variables
    throwing_speed = throw_speed;
    throwing_gravity = gravity_force;
    throwing_bounce = bounce_factor;
    throwing_angle = 0;
    throwing_vspeed = 0;
    throwing_hspeed = 0;
    is_thrown = false;
    z = 0;  // Height above ground
    
    return {
        speed: throwing_speed,
        gravity: throwing_gravity,
        bounce: throwing_bounce
    };
}

function update_throwable() {
    if (!is_thrown) return false;
    
    // Update position based on velocity
    var next_x = x + throwing_hspeed;
    var next_y = y + throwing_vspeed;
    
    // Check for wall collisions
    if (place_meeting(next_x, y, obj_wall)) {
        throwing_hspeed *= -throwing_bounce;
        next_x = x + throwing_hspeed;
    }
    
    if (place_meeting(x, next_y, obj_wall)) {
        throwing_vspeed *= -throwing_bounce;
        next_y = y + throwing_vspeed;
    }
    
    // Update position
    x = next_x;
    y = next_y;
    
    // Update z position (height)
    z += throwing_vspeed;
    
    // Apply gravity
    throwing_vspeed += throwing_gravity;
    
    // Ground collision
    if (z <= 0) {
        z = 0;
        throwing_vspeed *= -throwing_bounce;
        
        // Stop if moving very slowly
        if (abs(throwing_vspeed) < 0.1 && abs(throwing_hspeed) < 0.1) {
            is_thrown = false;
            throwing_vspeed = 0;
            throwing_hspeed = 0;
            return true; // Indicates throw has ended
        }
    }
    
    // Apply air resistance
    throwing_hspeed *= 0.99;
    
    return false; // Throw continues
}

function throw_object(direction, strength = 1) {
    is_thrown = true;
    throwing_angle = direction;
    
    // Calculate velocity components
    var angle_rad = degtorad(direction);
    throwing_hspeed = cos(angle_rad) * throwing_speed * strength;
    throwing_vspeed = -sin(angle_rad) * throwing_speed * strength;
    
    // Initial upward velocity
    z = 1; // Small initial height to ensure it's not stuck on ground
}

function draw_throwable() {
    if (is_thrown && z > 0) {
        // Draw shadow
        var shadow_scale = max(0.5, 1 - (z / 100)); // Shadow gets smaller with height
        draw_sprite_ext(sprite_index, image_index, x, y, 
            shadow_scale, shadow_scale, image_angle, c_black, 0.3);
        
        // Draw object at height
        draw_sprite_ext(sprite_index, image_index, x, y - z, 
            image_xscale, image_yscale, image_angle, image_blend, image_alpha);
    } else {
        // Normal draw when not thrown or on ground
        draw_self();
    }
} 
